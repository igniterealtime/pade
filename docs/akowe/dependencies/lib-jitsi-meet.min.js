! function(e, t) {
    "object" == typeof exports && "object" == typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define([], t) : "object" == typeof exports ? exports.JitsiMeetJS = t() : e.JitsiMeetJS = t()
}(window, (function() {
    return function(e) {
        var t = {};

        function n(r) {
            if (t[r]) return t[r].exports;
            var i = t[r] = {
                i: r,
                l: !1,
                exports: {}
            };
            return e[r].call(i.exports, i, i.exports, n), i.l = !0, i.exports
        }
        return n.m = e, n.c = t, n.d = function(e, t, r) {
            n.o(e, t) || Object.defineProperty(e, t, {
                enumerable: !0,
                get: r
            })
        }, n.r = function(e) {
            "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
                value: "Module"
            }), Object.defineProperty(e, "__esModule", {
                value: !0
            })
        }, n.t = function(e, t) {
            if (1 & t && (e = n(e)), 8 & t) return e;
            if (4 & t && "object" == typeof e && e && e.__esModule) return e;
            var r = Object.create(null);
            if (n.r(r), Object.defineProperty(r, "default", {
                    enumerable: !0,
                    value: e
                }), 2 & t && "string" != typeof e)
                for (var i in e) n.d(r, i, function(t) {
                    return e[t]
                }.bind(null, i));
            return r
        }, n.n = function(e) {
            var t = e && e.__esModule ? function() {
                return e.default
            } : function() {
                return e
            };
            return n.d(t, "a", t), t
        }, n.o = function(e, t) {
            return Object.prototype.hasOwnProperty.call(e, t)
        }, n.p = "", n(n.s = 118)
    }([function(e, t) {
        e.exports = {
            ADD_ICE_CANDIDATE_FAILED: "xmpp.add_ice_candidate_failed",
            AUDIO_MUTED_BY_FOCUS: "xmpp.audio_muted_by_focus",
            AUTHENTICATION_REQUIRED: "xmpp.authentication_required",
            BRIDGE_DOWN: "xmpp.bridge_down",
            CALL_ACCEPTED: "xmpp.callaccepted.jingle",
            CALL_INCOMING: "xmpp.callincoming.jingle",
            CALL_ENDED: "xmpp.callended.jingle",
            CHAT_ERROR_RECEIVED: "xmpp.chat_error_received",
            CONFERENCE_PROPERTIES_CHANGED: "xmpp.conference_properties_changed",
            CONNECTION_ESTABLISHED: "xmpp.connection.connected",
            CONNECTION_FAILED: "xmpp.connection.failed",
            CONNECTION_INTERRUPTED: "xmpp.connection.interrupted",
            CONNECTION_RESTORED: "xmpp.connection.restored",
            CONNECTION_ICE_FAILED: "xmpp.connection.ice.failed",
            CONNECTION_STATUS_CHANGED: "xmpp.connection.status.changed",
            DISPLAY_NAME_CHANGED: "xmpp.display_name_changed",
            EMUC_ROOM_ADDED: "xmpp.emuc_room_added",
            EMUC_ROOM_REMOVED: "xmpp.emuc_room_removed",
            ETHERPAD: "xmpp.etherpad",
            FOCUS_DISCONNECTED: "xmpp.focus_disconnected",
            FOCUS_LEFT: "xmpp.focus_left",
            GRACEFUL_SHUTDOWN: "xmpp.graceful_shutdown",
            ICE_RESTARTING: "rtc.ice_restarting",
            ICE_RESTART_SUCCESS: "rtc.ice_restart_success",
            KICKED: "xmpp.kicked",
            LOCAL_ROLE_CHANGED: "xmpp.localrole_changed",
            MESSAGE_RECEIVED: "xmpp.message_received",
            PRIVATE_MESSAGE_RECEIVED: "xmpp.private_message_received",
            MUC_MEMBER_BOT_TYPE_CHANGED: "xmpp.muc_member_bot_type_changed",
            MUC_DESTROYED: "xmpp.muc_destroyed",
            MUC_JOINED: "xmpp.muc_joined",
            MUC_MEMBER_JOINED: "xmpp.muc_member_joined",
            MUC_MEMBER_LEFT: "xmpp.muc_member_left",
            MUC_LEFT: "xmpp.muc_left",
            MUC_ROLE_CHANGED: "xmpp.muc_role_changed",
            MUC_LOCK_CHANGED: "xmpp.muc_lock_changed",
            PARTICIPANT_AUDIO_MUTED: "xmpp.audio_muted",
            PARTICIPANT_VIDEO_MUTED: "xmpp.video_muted",
            PARTICIPANT_VIDEO_TYPE_CHANGED: "xmpp.video_type",
            PARTCIPANT_FEATURES_CHANGED: "xmpp.partcipant_features_changed",
            PASSWORD_REQUIRED: "xmpp.password_required",
            PEERCONNECTION_READY: "xmpp.peerconnection_ready",
            PHONE_NUMBER_CHANGED: "conference.phoneNumberChanged",
            PRESENCE_RECEIVED: "xmpp.presence_received",
            PRESENCE_STATUS: "xmpp.presence_status",
            PROMPT_FOR_LOGIN: "xmpp.prompt_for_login",
            READY_TO_JOIN: "xmpp.ready_to_join",
            RECORDER_STATE_CHANGED: "xmpp.recorderStateChanged",
            REMOTE_STATS: "xmpp.remote_stats",
            RENEGOTIATION_FAILED: "xmpp.renegotiation_failed",
            RESERVATION_ERROR: "xmpp.room_reservation_error",
            ROOM_CONNECT_ERROR: "xmpp.room_connect_error",
            ROOM_CONNECT_NOT_ALLOWED_ERROR: "xmpp.room_connect_error.not_allowed",
            ROOM_JOIN_ERROR: "xmpp.room_join_error",
            ROOM_MAX_USERS_ERROR: "xmpp.room_max_users_error",
            SENDING_CHAT_MESSAGE: "xmpp.sending_chat_message",
            SENDING_PRIVATE_CHAT_MESSAGE: "xmpp.sending_private_chat_message",
            SESSION_ACCEPT_TIMEOUT: "xmpp.session_accept_timeout",
            SPEAKER_STATS_RECEIVED: "xmpp.speaker_stats_received",
            START_MUTED_FROM_FOCUS: "xmpp.start_muted_from_focus",
            SUBJECT_CHANGED: "xmpp.subject_changed",
            SUSPEND_DETECTED: "xmpp.suspend_detected",
            TRANSCRIPTION_STATUS_CHANGED: "xmpp.transcription_status_changed",
            TRANSPORT_INFO: "xmpp.transportinfo.jingle",
            VIDEO_SIP_GW_AVAILABILITY_CHANGED: "xmpp.videoSIPGWAvailabilityChanged",
            VIDEO_SIP_GW_SESSION_STATE_CHANGED: "xmpp.videoSIPGWSessionStateChanged",
            ICE_CONNECTION_STATE_CHANGED: "xmpp.ice_connection_state_changed",
            JSON_MESSAGE_RECEIVED: "xmmp.json_message_received"
        }
    }, function(e, t, n) {
        var r, i, o;

        function a(e) {
            return (a = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                return typeof e
            } : function(e) {
                return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
            })(e)
        }
        i = [], void 0 === (o = "function" == typeof(r = function() {
            /**
             * @license almond 0.3.3 Copyright jQuery Foundation and other contributors.
             * Released under MIT license, http://github.com/requirejs/almond/LICENSE
             */
            var n, r, i, o, s;
            return function(e) {
                    var t, o, s, c, u = {},
                        l = {},
                        d = {},
                        p = {},
                        h = Object.prototype.hasOwnProperty,
                        f = [].slice,
                        m = /\.js$/;

                    function v(e, t) {
                        return h.call(e, t)
                    }

                    function y(e, t) {
                        var n, r, i, o, a, s, c, u, l, p, h, f = t && t.split("/"),
                            v = d.map,
                            y = v && v["*"] || {};
                        if (e) {
                            for (a = (e = e.split("/")).length - 1, d.nodeIdCompat && m.test(e[a]) && (e[a] = e[a].replace(m, "")), "." === e[0].charAt(0) && f && (e = f.slice(0, f.length - 1).concat(e)), l = 0; l < e.length; l++)
                                if ("." === (h = e[l])) e.splice(l, 1), l -= 1;
                                else if (".." === h) {
                                if (0 === l || 1 === l && ".." === e[2] || ".." === e[l - 1]) continue;
                                l > 0 && (e.splice(l - 1, 2), l -= 2)
                            }
                            e = e.join("/")
                        }
                        if ((f || y) && v) {
                            for (l = (n = e.split("/")).length; l > 0; l -= 1) {
                                if (r = n.slice(0, l).join("/"), f)
                                    for (p = f.length; p > 0; p -= 1)
                                        if ((i = v[f.slice(0, p).join("/")]) && (i = i[r])) {
                                            o = i, s = l;
                                            break
                                        } if (o) break;
                                !c && y && y[r] && (c = y[r], u = l)
                            }!o && c && (o = c, s = u), o && (n.splice(0, s, o), e = n.join("/"))
                        }
                        return e
                    }

                    function g(t, n) {
                        return function() {
                            var r = f.call(arguments, 0);
                            return "string" != typeof r[0] && 1 === r.length && r.push(null), o.apply(e, r.concat([t, n]))
                        }
                    }

                    function _(e) {
                        return function(t) {
                            u[e] = t
                        }
                    }

                    function S(n) {
                        if (v(l, n)) {
                            var r = l[n];
                            delete l[n], p[n] = !0, t.apply(e, r)
                        }
                        if (!v(u, n) && !v(p, n)) throw new Error("No " + n);
                        return u[n]
                    }

                    function b(e) {
                        var t, n = e ? e.indexOf("!") : -1;
                        return n > -1 && (t = e.substring(0, n), e = e.substring(n + 1, e.length)), [t, e]
                    }

                    function E(e) {
                        return e ? b(e) : []
                    }

                    function T(e) {
                        return function() {
                            return d && d.config && d.config[e] || {}
                        }
                    }
                    s = function(e, t) {
                        var n, r, i = b(e),
                            o = i[0],
                            a = t[1];
                        return e = i[1], o && (n = S(o = y(o, a))), o ? e = n && n.normalize ? n.normalize(e, (r = a, function(e) {
                            return y(e, r)
                        })) : y(e, a) : (o = (i = b(e = y(e, a)))[0], e = i[1], o && (n = S(o))), {
                            f: o ? o + "!" + e : e,
                            n: e,
                            pr: o,
                            p: n
                        }
                    }, c = {
                        require: function(e) {
                            return g(e)
                        },
                        exports: function(e) {
                            var t = u[e];
                            return void 0 !== t ? t : u[e] = {}
                        },
                        module: function(e) {
                            return {
                                id: e,
                                uri: "",
                                exports: u[e],
                                config: T(e)
                            }
                        }
                    }, t = function(t, n, r, i) {
                        var o, d, h, f, m, y, b, T = [],
                            C = a(r);
                        if (y = E(i = i || t), "undefined" === C || "function" === C) {
                            for (n = !n.length && r.length ? ["require", "exports", "module"] : n, m = 0; m < n.length; m += 1)
                                if ("require" === (d = (f = s(n[m], y)).f)) T[m] = c.require(t);
                                else if ("exports" === d) T[m] = c.exports(t), b = !0;
                            else if ("module" === d) o = T[m] = c.module(t);
                            else if (v(u, d) || v(l, d) || v(p, d)) T[m] = S(d);
                            else {
                                if (!f.p) throw new Error(t + " missing " + d);
                                f.p.load(f.n, g(i, !0), _(d), {}), T[m] = u[d]
                            }
                            h = r ? r.apply(u[t], T) : void 0, t && (o && o.exports !== e && o.exports !== u[t] ? u[t] = o.exports : h === e && b || (u[t] = h))
                        } else t && (u[t] = r)
                    }, n = r = o = function(n, r, i, a, u) {
                        if ("string" == typeof n) return c[n] ? c[n](r) : S(s(n, E(r)).f);
                        if (!n.splice) {
                            if ((d = n).deps && o(d.deps, d.callback), !r) return;
                            r.splice ? (n = r, r = i, i = null) : n = e
                        }
                        return r = r || function() {}, "function" == typeof i && (i = a, a = u), a ? t(e, n, r, i) : setTimeout((function() {
                            t(e, n, r, i)
                        }), 4), o
                    }, o.config = function(e) {
                        return o(e)
                    }, n._defined = u, (i = function(e, t, n) {
                        if ("string" != typeof e) throw new Error("See almond README: incorrect module build, no module name");
                        t.splice || (n = t, t = []), v(u, e) || v(l, e) || (l[e] = [e, t, n])
                    }).amd = {
                        jQuery: !0
                    }
                }(), i("node_modules/almond/almond.js", (function() {})),
                function(e, t) {
                    "function" == typeof i && i.amd ? i("strophe-polyfill", [], (function() {
                        return t(e)
                    })) : t(e)
                }(this, (function(e) {
                    Function.prototype.bind || (Function.prototype.bind = function(e) {
                        var t = this,
                            n = Array.prototype.slice,
                            r = Array.prototype.concat,
                            i = n.call(arguments, 1);
                        return function() {
                            return t.apply(e || this, r.call(i, n.call(arguments, 0)))
                        }
                    }), Array.isArray || (Array.isArray = function(e) {
                        return "[object Array]" === Object.prototype.toString.call(e)
                    }), Array.prototype.indexOf || (Array.prototype.indexOf = function(e) {
                        var t = this.length,
                            n = Number(arguments[1]) || 0;
                        for ((n = n < 0 ? Math.ceil(n) : Math.floor(n)) < 0 && (n += t); n < t; n++)
                            if (n in this && this[n] === e) return n;
                        return -1
                    }), Array.prototype.forEach || (Array.prototype.forEach = function(e, t) {
                        var n, r;
                        if (null === this) throw new TypeError(" this is null or not defined");
                        var i = Object(this),
                            o = i.length >>> 0;
                        if ("function" != typeof e) throw new TypeError(e + " is not a function");
                        for (arguments.length > 1 && (n = t), r = 0; r < o;) {
                            var a;
                            r in i && (a = i[r], e.call(n, a, r, i)), r++
                        }
                    });
                    var t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
                    e.btoa || (e.btoa = function(e) {
                        var n, r, i, o, a, s, c, u = "",
                            l = 0;
                        do {
                            o = (n = e.charCodeAt(l++)) >> 2, a = (3 & n) << 4 | (r = e.charCodeAt(l++)) >> 4, s = (15 & r) << 2 | (i = e.charCodeAt(l++)) >> 6, c = 63 & i, isNaN(r) ? (a = (3 & n) << 4, s = c = 64) : isNaN(i) && (c = 64), u = u + t.charAt(o) + t.charAt(a) + t.charAt(s) + t.charAt(c)
                        } while (l < e.length);
                        return u
                    }), e.atob || (e.atob = function(e) {
                        var n, r, i, o, a, s, c = "",
                            u = 0;
                        e = e.replace(/[^A-Za-z0-9\+\/\=]/g, "");
                        do {
                            n = t.indexOf(e.charAt(u++)) << 2 | (o = t.indexOf(e.charAt(u++))) >> 4, r = (15 & o) << 4 | (a = t.indexOf(e.charAt(u++))) >> 2, i = (3 & a) << 6 | (s = t.indexOf(e.charAt(u++))), c += String.fromCharCode(n), 64 !== a && (c += String.fromCharCode(r)), 64 !== s && (c += String.fromCharCode(i))
                        } while (u < e.length);
                        return c
                    })
                })), o = this, s = function() {
                    function e(e, r) {
                        e[r >> 5] |= 128 << 24 - r % 32, e[15 + (r + 64 >> 9 << 4)] = r;
                        var a, s, c, u, l, d, p, h, f = new Array(80),
                            m = 1732584193,
                            v = -271733879,
                            y = -1732584194,
                            g = 271733878,
                            _ = -1009589776;
                        for (a = 0; a < e.length; a += 16) {
                            for (u = m, l = v, d = y, p = g, h = _, s = 0; s < 80; s++) f[s] = s < 16 ? e[a + s] : o(f[s - 3] ^ f[s - 8] ^ f[s - 14] ^ f[s - 16], 1), c = i(i(o(m, 5), t(s, v, y, g)), i(i(_, f[s]), n(s))), _ = g, g = y, y = o(v, 30), v = m, m = c;
                            m = i(m, u), v = i(v, l), y = i(y, d), g = i(g, p), _ = i(_, h)
                        }
                        return [m, v, y, g, _]
                    }

                    function t(e, t, n, r) {
                        return e < 20 ? t & n | ~t & r : e < 40 ? t ^ n ^ r : e < 60 ? t & n | t & r | n & r : t ^ n ^ r
                    }

                    function n(e) {
                        return e < 20 ? 1518500249 : e < 40 ? 1859775393 : e < 60 ? -1894007588 : -899497514
                    }

                    function r(t, n) {
                        var r = a(t);
                        r.length > 16 && (r = e(r, 8 * t.length));
                        for (var i = new Array(16), o = new Array(16), s = 0; s < 16; s++) i[s] = 909522486 ^ r[s], o[s] = 1549556828 ^ r[s];
                        var c = e(i.concat(a(n)), 512 + 8 * n.length);
                        return e(o.concat(c), 672)
                    }

                    function i(e, t) {
                        var n = (65535 & e) + (65535 & t);
                        return (e >> 16) + (t >> 16) + (n >> 16) << 16 | 65535 & n
                    }

                    function o(e, t) {
                        return e << t | e >>> 32 - t
                    }

                    function a(e) {
                        for (var t = [], n = 0; n < 8 * e.length; n += 8) t[n >> 5] |= (255 & e.charCodeAt(n / 8)) << 24 - n % 32;
                        return t
                    }

                    function s(e) {
                        for (var t = "", n = 0; n < 32 * e.length; n += 8) t += String.fromCharCode(e[n >> 5] >>> 24 - n % 32 & 255);
                        return t
                    }

                    function c(e) {
                        for (var t, n, r = "", i = 0; i < 4 * e.length; i += 3)
                            for (t = (e[i >> 2] >> 8 * (3 - i % 4) & 255) << 16 | (e[i + 1 >> 2] >> 8 * (3 - (i + 1) % 4) & 255) << 8 | e[i + 2 >> 2] >> 8 * (3 - (i + 2) % 4) & 255, n = 0; n < 4; n++) 8 * i + 6 * n > 32 * e.length ? r += "=" : r += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(t >> 6 * (3 - n) & 63);
                        return r
                    }
                    return {
                        b64_hmac_sha1: function(e, t) {
                            return c(r(e, t))
                        },
                        b64_sha1: function(t) {
                            return c(e(a(t), 8 * t.length))
                        },
                        binb2str: s,
                        core_hmac_sha1: r,
                        str_hmac_sha1: function(e, t) {
                            return s(r(e, t))
                        },
                        str_sha1: function(t) {
                            return s(e(a(t), 8 * t.length))
                        }
                    }
                }, "function" == typeof i && i.amd ? i("strophe-sha1", [], (function() {
                    return s()
                })) : "object" === a(t) ? e.exports = s() : o.SHA1 = s(),
                function(n, r) {
                    "function" == typeof i && i.amd ? i("strophe-md5", [], (function() {
                        return r()
                    })) : "object" === a(t) ? e.exports = r() : n.MD5 = r()
                }(this, (function() {
                    var e = function(e, t) {
                            var n = (65535 & e) + (65535 & t);
                            return (e >> 16) + (t >> 16) + (n >> 16) << 16 | 65535 & n
                        },
                        t = function(e) {
                            for (var t = [], n = 0; n < 8 * e.length; n += 8) t[n >> 5] |= (255 & e.charCodeAt(n / 8)) << n % 32;
                            return t
                        },
                        n = function(t, n, r, i, o, a) {
                            return e((s = e(e(n, t), e(i, a))) << (c = o) | s >>> 32 - c, r);
                            var s, c
                        },
                        r = function(e, t, r, i, o, a, s) {
                            return n(t & r | ~t & i, e, t, o, a, s)
                        },
                        i = function(e, t, r, i, o, a, s) {
                            return n(t & i | r & ~i, e, t, o, a, s)
                        },
                        o = function(e, t, r, i, o, a, s) {
                            return n(t ^ r ^ i, e, t, o, a, s)
                        },
                        a = function(e, t, r, i, o, a, s) {
                            return n(r ^ (t | ~i), e, t, o, a, s)
                        },
                        s = function(t, n) {
                            t[n >> 5] |= 128 << n % 32, t[14 + (n + 64 >>> 9 << 4)] = n;
                            for (var s, c, u, l, d = 1732584193, p = -271733879, h = -1732584194, f = 271733878, m = 0; m < t.length; m += 16) s = d, c = p, u = h, l = f, d = r(d, p, h, f, t[m + 0], 7, -680876936), f = r(f, d, p, h, t[m + 1], 12, -389564586), h = r(h, f, d, p, t[m + 2], 17, 606105819), p = r(p, h, f, d, t[m + 3], 22, -1044525330), d = r(d, p, h, f, t[m + 4], 7, -176418897), f = r(f, d, p, h, t[m + 5], 12, 1200080426), h = r(h, f, d, p, t[m + 6], 17, -1473231341), p = r(p, h, f, d, t[m + 7], 22, -45705983), d = r(d, p, h, f, t[m + 8], 7, 1770035416), f = r(f, d, p, h, t[m + 9], 12, -1958414417), h = r(h, f, d, p, t[m + 10], 17, -42063), p = r(p, h, f, d, t[m + 11], 22, -1990404162), d = r(d, p, h, f, t[m + 12], 7, 1804603682), f = r(f, d, p, h, t[m + 13], 12, -40341101), h = r(h, f, d, p, t[m + 14], 17, -1502002290), p = r(p, h, f, d, t[m + 15], 22, 1236535329), d = i(d, p, h, f, t[m + 1], 5, -165796510), f = i(f, d, p, h, t[m + 6], 9, -1069501632), h = i(h, f, d, p, t[m + 11], 14, 643717713), p = i(p, h, f, d, t[m + 0], 20, -373897302), d = i(d, p, h, f, t[m + 5], 5, -701558691), f = i(f, d, p, h, t[m + 10], 9, 38016083), h = i(h, f, d, p, t[m + 15], 14, -660478335), p = i(p, h, f, d, t[m + 4], 20, -405537848), d = i(d, p, h, f, t[m + 9], 5, 568446438), f = i(f, d, p, h, t[m + 14], 9, -1019803690), h = i(h, f, d, p, t[m + 3], 14, -187363961), p = i(p, h, f, d, t[m + 8], 20, 1163531501), d = i(d, p, h, f, t[m + 13], 5, -1444681467), f = i(f, d, p, h, t[m + 2], 9, -51403784), h = i(h, f, d, p, t[m + 7], 14, 1735328473), p = i(p, h, f, d, t[m + 12], 20, -1926607734), d = o(d, p, h, f, t[m + 5], 4, -378558), f = o(f, d, p, h, t[m + 8], 11, -2022574463), h = o(h, f, d, p, t[m + 11], 16, 1839030562), p = o(p, h, f, d, t[m + 14], 23, -35309556), d = o(d, p, h, f, t[m + 1], 4, -1530992060), f = o(f, d, p, h, t[m + 4], 11, 1272893353), h = o(h, f, d, p, t[m + 7], 16, -155497632), p = o(p, h, f, d, t[m + 10], 23, -1094730640), d = o(d, p, h, f, t[m + 13], 4, 681279174), f = o(f, d, p, h, t[m + 0], 11, -358537222), h = o(h, f, d, p, t[m + 3], 16, -722521979), p = o(p, h, f, d, t[m + 6], 23, 76029189), d = o(d, p, h, f, t[m + 9], 4, -640364487), f = o(f, d, p, h, t[m + 12], 11, -421815835), h = o(h, f, d, p, t[m + 15], 16, 530742520), p = o(p, h, f, d, t[m + 2], 23, -995338651), d = a(d, p, h, f, t[m + 0], 6, -198630844), f = a(f, d, p, h, t[m + 7], 10, 1126891415), h = a(h, f, d, p, t[m + 14], 15, -1416354905), p = a(p, h, f, d, t[m + 5], 21, -57434055), d = a(d, p, h, f, t[m + 12], 6, 1700485571), f = a(f, d, p, h, t[m + 3], 10, -1894986606), h = a(h, f, d, p, t[m + 10], 15, -1051523), p = a(p, h, f, d, t[m + 1], 21, -2054922799), d = a(d, p, h, f, t[m + 8], 6, 1873313359), f = a(f, d, p, h, t[m + 15], 10, -30611744), h = a(h, f, d, p, t[m + 6], 15, -1560198380), p = a(p, h, f, d, t[m + 13], 21, 1309151649), d = a(d, p, h, f, t[m + 4], 6, -145523070), f = a(f, d, p, h, t[m + 11], 10, -1120210379), h = a(h, f, d, p, t[m + 2], 15, 718787259), p = a(p, h, f, d, t[m + 9], 21, -343485551), d = e(d, s), p = e(p, c), h = e(h, u), f = e(f, l);
                            return [d, p, h, f]
                        };
                    return {
                        hexdigest: function(e) {
                            return function(e) {
                                for (var t = "", n = 0; n < 4 * e.length; n++) t += "0123456789abcdef".charAt(e[n >> 2] >> n % 4 * 8 + 4 & 15) + "0123456789abcdef".charAt(e[n >> 2] >> n % 4 * 8 & 15);
                                return t
                            }(s(t(e), 8 * e.length))
                        },
                        hash: function(e) {
                            return function(e) {
                                for (var t = "", n = 0; n < 32 * e.length; n += 8) t += String.fromCharCode(e[n >> 5] >>> n % 32 & 255);
                                return t
                            }(s(t(e), 8 * e.length))
                        }
                    }
                })),
                function(n, r) {
                    "function" == typeof i && i.amd ? i("strophe-utils", [], (function() {
                        return r()
                    })) : "object" === a(t) ? e.exports = r() : n.stropheUtils = r()
                }(this, (function() {
                    return {
                        utf16to8: function(e) {
                            var t, n, r = "",
                                i = e.length;
                            for (t = 0; t < i; t++)(n = e.charCodeAt(t)) >= 0 && n <= 127 ? r += e.charAt(t) : n > 2047 ? (r += String.fromCharCode(224 | n >> 12 & 15), r += String.fromCharCode(128 | n >> 6 & 63), r += String.fromCharCode(128 | n >> 0 & 63)) : (r += String.fromCharCode(192 | n >> 6 & 31), r += String.fromCharCode(128 | n >> 0 & 63));
                            return r
                        },
                        addCookies: function(e) {
                            var t, n, r, i, o, s, c;
                            for (t in e || {}) o = "", s = "", c = "", r = "object" === a(n = e[t]), i = escape(unescape(r ? n.value : n)), r && (o = n.expires ? ";expires=" + n.expires : "", s = n.domain ? ";domain=" + n.domain : "", c = n.path ? ";path=" + n.path : ""), document.cookie = t + "=" + i + o + s + c
                        }
                    }
                })),
                function(n, o) {
                    if ("function" == typeof i && i.amd) i("strophe-core", ["strophe-sha1", "strophe-md5", "strophe-utils"], (function() {
                        return o.apply(this, arguments)
                    }));
                    else if ("object" === a(t)) e.exports = o(r("./sha1"), r("./md5"), r("./utils"));
                    else {
                        var s = o(n.SHA1, n.MD5, n.stropheUtils);
                        n.Strophe = s.Strophe, n.$build = s.$build, n.$iq = s.$iq, n.$msg = s.$msg, n.$pres = s.$pres, n.SHA1 = s.SHA1, n.MD5 = s.MD5, n.b64_hmac_sha1 = s.SHA1.b64_hmac_sha1, n.b64_sha1 = s.SHA1.b64_sha1, n.str_hmac_sha1 = s.SHA1.str_hmac_sha1, n.str_sha1 = s.SHA1.str_sha1
                    }
                }(this, (function(e, t, n) {
                    var r;

                    function i(e, t) {
                        return new r.Builder(e, t)
                    }

                    function o(e) {
                        return new r.Builder("iq", e)
                    }

                    function s(e) {
                        return new r.Builder("presence", e)
                    }
                    return (r = {
                        VERSION: "1.2.16",
                        NS: {
                            HTTPBIND: "http://jabber.org/protocol/httpbind",
                            BOSH: "urn:xmpp:xbosh",
                            CLIENT: "jabber:client",
                            AUTH: "jabber:iq:auth",
                            ROSTER: "jabber:iq:roster",
                            PROFILE: "jabber:iq:profile",
                            DISCO_INFO: "http://jabber.org/protocol/disco#info",
                            DISCO_ITEMS: "http://jabber.org/protocol/disco#items",
                            MUC: "http://jabber.org/protocol/muc",
                            SASL: "urn:ietf:params:xml:ns:xmpp-sasl",
                            STREAM: "http://etherx.jabber.org/streams",
                            FRAMING: "urn:ietf:params:xml:ns:xmpp-framing",
                            BIND: "urn:ietf:params:xml:ns:xmpp-bind",
                            SESSION: "urn:ietf:params:xml:ns:xmpp-session",
                            VERSION: "jabber:iq:version",
                            STANZAS: "urn:ietf:params:xml:ns:xmpp-stanzas",
                            XHTML_IM: "http://jabber.org/protocol/xhtml-im",
                            XHTML: "http://www.w3.org/1999/xhtml"
                        },
                        XHTML: {
                            tags: ["a", "blockquote", "br", "cite", "em", "img", "li", "ol", "p", "span", "strong", "ul", "body"],
                            attributes: {
                                a: ["href"],
                                blockquote: ["style"],
                                br: [],
                                cite: ["style"],
                                em: [],
                                img: ["src", "alt", "style", "height", "width"],
                                li: ["style"],
                                ol: ["style"],
                                p: ["style"],
                                span: ["style"],
                                strong: [],
                                ul: ["style"],
                                body: []
                            },
                            css: ["background-color", "color", "font-family", "font-size", "font-style", "font-weight", "margin-left", "margin-right", "text-align", "text-decoration"],
                            validTag: function(e) {
                                for (var t = 0; t < r.XHTML.tags.length; t++)
                                    if (e === r.XHTML.tags[t]) return !0;
                                return !1
                            },
                            validAttribute: function(e, t) {
                                if (void 0 !== r.XHTML.attributes[e] && r.XHTML.attributes[e].length > 0)
                                    for (var n = 0; n < r.XHTML.attributes[e].length; n++)
                                        if (t === r.XHTML.attributes[e][n]) return !0;
                                return !1
                            },
                            validCSS: function(e) {
                                for (var t = 0; t < r.XHTML.css.length; t++)
                                    if (e === r.XHTML.css[t]) return !0;
                                return !1
                            }
                        },
                        Status: {
                            ERROR: 0,
                            CONNECTING: 1,
                            CONNFAIL: 2,
                            AUTHENTICATING: 3,
                            AUTHFAIL: 4,
                            CONNECTED: 5,
                            DISCONNECTED: 6,
                            DISCONNECTING: 7,
                            ATTACHED: 8,
                            REDIRECT: 9,
                            CONNTIMEOUT: 10
                        },
                        ErrorCondition: {
                            BAD_FORMAT: "bad-format",
                            CONFLICT: "conflict",
                            MISSING_JID_NODE: "x-strophe-bad-non-anon-jid",
                            NO_AUTH_MECH: "no-auth-mech",
                            UNKNOWN_REASON: "unknown"
                        },
                        LogLevel: {
                            DEBUG: 0,
                            INFO: 1,
                            WARN: 2,
                            ERROR: 3,
                            FATAL: 4
                        },
                        ElementType: {
                            NORMAL: 1,
                            TEXT: 3,
                            CDATA: 4,
                            FRAGMENT: 11
                        },
                        TIMEOUT: 1.1,
                        SECONDARY_TIMEOUT: .1,
                        addNamespace: function(e, t) {
                            r.NS[e] = t
                        },
                        forEachChild: function(e, t, n) {
                            var i, o;
                            for (i = 0; i < e.childNodes.length; i++)(o = e.childNodes[i]).nodeType !== r.ElementType.NORMAL || t && !this.isTagEqual(o, t) || n(o)
                        },
                        isTagEqual: function(e, t) {
                            return e.tagName === t
                        },
                        _xmlGenerator: null,
                        _makeGenerator: function() {
                            var e;
                            return void 0 === document.implementation.createDocument || document.implementation.createDocument && document.documentMode && document.documentMode < 10 ? (e = this._getIEXmlDom()).appendChild(e.createElement("strophe")) : e = document.implementation.createDocument("jabber:client", "strophe", null), e
                        },
                        xmlGenerator: function() {
                            return r._xmlGenerator || (r._xmlGenerator = r._makeGenerator()), r._xmlGenerator
                        },
                        _getIEXmlDom: function() {
                            for (var e = null, t = ["Msxml2.DOMDocument.6.0", "Msxml2.DOMDocument.5.0", "Msxml2.DOMDocument.4.0", "MSXML2.DOMDocument.3.0", "MSXML2.DOMDocument", "MSXML.DOMDocument", "Microsoft.XMLDOM"], n = 0; n < t.length && null === e; n++) try {
                                e = new ActiveXObject(t[n])
                            } catch (t) {
                                e = null
                            }
                            return e
                        },
                        xmlElement: function(e) {
                            if (!e) return null;
                            var t, n, i, o = r.xmlGenerator().createElement(e);
                            for (t = 1; t < arguments.length; t++) {
                                var s = arguments[t];
                                if (s)
                                    if ("string" == typeof s || "number" == typeof s) o.appendChild(r.xmlTextNode(s));
                                    else if ("object" === a(s) && "function" == typeof s.sort)
                                    for (n = 0; n < s.length; n++) {
                                        var c = s[n];
                                        "object" === a(c) && "function" == typeof c.sort && void 0 !== c[1] && null !== c[1] && o.setAttribute(c[0], c[1])
                                    } else if ("object" === a(s))
                                        for (i in s) s.hasOwnProperty(i) && void 0 !== s[i] && null !== s[i] && o.setAttribute(i, s[i])
                            }
                            return o
                        },
                        xmlescape: function(e) {
                            return e = (e = (e = (e = (e = e.replace(/\&/g, "&amp;")).replace(/</g, "&lt;")).replace(/>/g, "&gt;")).replace(/'/g, "&apos;")).replace(/"/g, "&quot;")
                        },
                        xmlunescape: function(e) {
                            return e = (e = (e = (e = (e = e.replace(/\&amp;/g, "&")).replace(/&lt;/g, "<")).replace(/&gt;/g, ">")).replace(/&apos;/g, "'")).replace(/&quot;/g, '"')
                        },
                        xmlTextNode: function(e) {
                            return r.xmlGenerator().createTextNode(e)
                        },
                        xmlHtmlNode: function(e) {
                            var t;
                            return DOMParser ? t = (new DOMParser).parseFromString(e, "text/xml") : ((t = new ActiveXObject("Microsoft.XMLDOM")).async = "false", t.loadXML(e)), t
                        },
                        getText: function(e) {
                            if (!e) return null;
                            var t = "";
                            0 === e.childNodes.length && e.nodeType === r.ElementType.TEXT && (t += e.nodeValue);
                            for (var n = 0; n < e.childNodes.length; n++) e.childNodes[n].nodeType === r.ElementType.TEXT && (t += e.childNodes[n].nodeValue);
                            return r.xmlescape(t)
                        },
                        copyElement: function(e) {
                            var t, n;
                            if (e.nodeType === r.ElementType.NORMAL) {
                                for (n = r.xmlElement(e.tagName), t = 0; t < e.attributes.length; t++) n.setAttribute(e.attributes[t].nodeName, e.attributes[t].value);
                                for (t = 0; t < e.childNodes.length; t++) n.appendChild(r.copyElement(e.childNodes[t]))
                            } else e.nodeType === r.ElementType.TEXT && (n = r.xmlGenerator().createTextNode(e.nodeValue));
                            return n
                        },
                        createHtml: function(e) {
                            var t, n, i, o, s, c, u, l, d, p, h;
                            if (e.nodeType === r.ElementType.NORMAL)
                                if (o = e.nodeName.toLowerCase(), r.XHTML.validTag(o)) try {
                                    for (n = r.xmlElement(o), t = 0; t < r.XHTML.attributes[o].length; t++)
                                        if (s = r.XHTML.attributes[o][t], null != (c = e.getAttribute(s)) && "" !== c && !1 !== c && 0 !== c)
                                            if ("style" === s && "object" === a(c) && void 0 !== c.cssText && (c = c.cssText), "style" === s) {
                                                for (u = [], l = c.split(";"), i = 0; i < l.length; i++) p = (d = l[i].split(":"))[0].replace(/^\s*/, "").replace(/\s*$/, "").toLowerCase(), r.XHTML.validCSS(p) && (h = d[1].replace(/^\s*/, "").replace(/\s*$/, ""), u.push(p + ": " + h));
                                                u.length > 0 && (c = u.join("; "), n.setAttribute(s, c))
                                            } else n.setAttribute(s, c);
                                    for (t = 0; t < e.childNodes.length; t++) n.appendChild(r.createHtml(e.childNodes[t]))
                                } catch (e) {
                                    n = r.xmlTextNode("")
                                } else
                                    for (n = r.xmlGenerator().createDocumentFragment(), t = 0; t < e.childNodes.length; t++) n.appendChild(r.createHtml(e.childNodes[t]));
                                else if (e.nodeType === r.ElementType.FRAGMENT)
                                for (n = r.xmlGenerator().createDocumentFragment(), t = 0; t < e.childNodes.length; t++) n.appendChild(r.createHtml(e.childNodes[t]));
                            else e.nodeType === r.ElementType.TEXT && (n = r.xmlTextNode(e.nodeValue));
                            return n
                        },
                        escapeNode: function(e) {
                            return "string" != typeof e ? e : e.replace(/^\s+|\s+$/g, "").replace(/\\/g, "\\5c").replace(/ /g, "\\20").replace(/\"/g, "\\22").replace(/\&/g, "\\26").replace(/\'/g, "\\27").replace(/\//g, "\\2f").replace(/:/g, "\\3a").replace(/</g, "\\3c").replace(/>/g, "\\3e").replace(/@/g, "\\40")
                        },
                        unescapeNode: function(e) {
                            return "string" != typeof e ? e : e.replace(/\\20/g, " ").replace(/\\22/g, '"').replace(/\\26/g, "&").replace(/\\27/g, "'").replace(/\\2f/g, "/").replace(/\\3a/g, ":").replace(/\\3c/g, "<").replace(/\\3e/g, ">").replace(/\\40/g, "@").replace(/\\5c/g, "\\")
                        },
                        getNodeFromJid: function(e) {
                            return e.indexOf("@") < 0 ? null : e.split("@")[0]
                        },
                        getDomainFromJid: function(e) {
                            var t = r.getBareJidFromJid(e);
                            if (t.indexOf("@") < 0) return t;
                            var n = t.split("@");
                            return n.splice(0, 1), n.join("@")
                        },
                        getResourceFromJid: function(e) {
                            var t = e.split("/");
                            return t.length < 2 ? null : (t.splice(0, 1), t.join("/"))
                        },
                        getBareJidFromJid: function(e) {
                            return e ? e.split("/")[0] : null
                        },
                        _handleError: function(e) {
                            void 0 !== e.stack && r.fatal(e.stack), e.sourceURL ? r.fatal("error: " + this.handler + " " + e.sourceURL + ":" + e.line + " - " + e.name + ": " + e.message) : e.fileName ? r.fatal("error: " + this.handler + " " + e.fileName + ":" + e.lineNumber + " - " + e.name + ": " + e.message) : r.fatal("error: " + e.message)
                        },
                        log: function(e, t) {
                            e === this.LogLevel.FATAL && "object" === a(window.console) && "function" == typeof window.console.error && window.console.error(t)
                        },
                        debug: function(e) {
                            this.log(this.LogLevel.DEBUG, e)
                        },
                        info: function(e) {
                            this.log(this.LogLevel.INFO, e)
                        },
                        warn: function(e) {
                            this.log(this.LogLevel.WARN, e)
                        },
                        error: function(e) {
                            this.log(this.LogLevel.ERROR, e)
                        },
                        fatal: function(e) {
                            this.log(this.LogLevel.FATAL, e)
                        },
                        serialize: function(e) {
                            var t;
                            if (!e) return null;
                            "function" == typeof e.tree && (e = e.tree());
                            var n, i, o = e.nodeName;
                            for (e.getAttribute("_realname") && (o = e.getAttribute("_realname")), t = "<" + o, n = 0; n < e.attributes.length; n++) "_realname" !== e.attributes[n].nodeName && (t += " " + e.attributes[n].nodeName + "='" + r.xmlescape(e.attributes[n].value) + "'");
                            if (e.childNodes.length > 0) {
                                for (t += ">", n = 0; n < e.childNodes.length; n++) switch ((i = e.childNodes[n]).nodeType) {
                                    case r.ElementType.NORMAL:
                                        t += r.serialize(i);
                                        break;
                                    case r.ElementType.TEXT:
                                        t += r.xmlescape(i.nodeValue);
                                        break;
                                    case r.ElementType.CDATA:
                                        t += "<![CDATA[" + i.nodeValue + "]]>"
                                }
                                t += "</" + o + ">"
                            } else t += "/>";
                            return t
                        },
                        _requestId: 0,
                        _connectionPlugins: {},
                        addConnectionPlugin: function(e, t) {
                            r._connectionPlugins[e] = t
                        }
                    }).Builder = function(e, t) {
                        "presence" !== e && "message" !== e && "iq" !== e || (t && !t.xmlns ? t.xmlns = r.NS.CLIENT : t || (t = {
                            xmlns: r.NS.CLIENT
                        })), this.nodeTree = r.xmlElement(e, t), this.node = this.nodeTree
                    }, r.Builder.prototype = {
                        tree: function() {
                            return this.nodeTree
                        },
                        toString: function() {
                            return r.serialize(this.nodeTree)
                        },
                        up: function() {
                            return this.node = this.node.parentNode, this
                        },
                        root: function() {
                            return this.node = this.nodeTree, this
                        },
                        attrs: function(e) {
                            for (var t in e) e.hasOwnProperty(t) && (void 0 === e[t] ? this.node.removeAttribute(t) : this.node.setAttribute(t, e[t]));
                            return this
                        },
                        c: function(e, t, n) {
                            var i = r.xmlElement(e, t, n);
                            return this.node.appendChild(i), "string" != typeof n && "number" != typeof n && (this.node = i), this
                        },
                        cnode: function(e) {
                            var t, n = r.xmlGenerator();
                            try {
                                t = void 0 !== n.importNode
                            } catch (e) {
                                t = !1
                            }
                            var i = t ? n.importNode(e, !0) : r.copyElement(e);
                            return this.node.appendChild(i), this.node = i, this
                        },
                        t: function(e) {
                            var t = r.xmlTextNode(e);
                            return this.node.appendChild(t), this
                        },
                        h: function(e) {
                            var t = document.createElement("body");
                            t.innerHTML = e;
                            for (var n = r.createHtml(t); n.childNodes.length > 0;) this.node.appendChild(n.childNodes[0]);
                            return this
                        }
                    }, r.Handler = function(e, t, n, i, o, a, s) {
                        this.handler = e, this.ns = t, this.name = n, this.type = i, this.id = o, this.options = s || {
                            matchBareFromJid: !1,
                            ignoreNamespaceFragment: !1
                        }, this.options.matchBare && (r.warn('The "matchBare" option is deprecated, use "matchBareFromJid" instead.'), this.options.matchBareFromJid = this.options.matchBare, delete this.options.matchBare), this.options.matchBareFromJid ? this.from = a ? r.getBareJidFromJid(a) : null : this.from = a, this.user = !0
                    }, r.Handler.prototype = {
                        getNamespace: function(e) {
                            var t = e.getAttribute("xmlns");
                            return t && this.options.ignoreNamespaceFragment && (t = t.split("#")[0]), t
                        },
                        namespaceMatch: function(e) {
                            var t = !1;
                            if (!this.ns) return !0;
                            var n = this;
                            return r.forEachChild(e, null, (function(e) {
                                n.getNamespace(e) === n.ns && (t = !0)
                            })), t = t || this.getNamespace(e) === this.ns
                        },
                        isMatch: function(e) {
                            var t = e.getAttribute("from");
                            this.options.matchBareFromJid && (t = r.getBareJidFromJid(t));
                            var n = e.getAttribute("type");
                            return !(!this.namespaceMatch(e) || this.name && !r.isTagEqual(e, this.name) || this.type && (Array.isArray(this.type) ? -1 === this.type.indexOf(n) : n !== this.type) || this.id && e.getAttribute("id") !== this.id || this.from && t !== this.from)
                        },
                        run: function(e) {
                            var t = null;
                            try {
                                t = this.handler(e)
                            } catch (e) {
                                throw r._handleError(e), e
                            }
                            return t
                        },
                        toString: function() {
                            return "{Handler: " + this.handler + "(" + this.name + "," + this.id + "," + this.ns + ")}"
                        }
                    }, r.TimedHandler = function(e, t) {
                        this.period = e, this.handler = t, this.lastCalled = (new Date).getTime(), this.user = !0
                    }, r.TimedHandler.prototype = {
                        run: function() {
                            return this.lastCalled = (new Date).getTime(), this.handler()
                        },
                        reset: function() {
                            this.lastCalled = (new Date).getTime()
                        },
                        toString: function() {
                            return "{TimedHandler: " + this.handler + "(" + this.period + ")}"
                        }
                    }, r.Connection = function(e, t) {
                        this.service = e, this.options = t || {};
                        var i = this.options.protocol || "";
                        for (var o in 0 === e.indexOf("ws:") || 0 === e.indexOf("wss:") || 0 === i.indexOf("ws") ? this._proto = new r.Websocket(this) : this._proto = new r.Bosh(this), this.jid = "", this.domain = null, this.features = null, this._sasl_data = {}, this.do_session = !1, this.do_bind = !1, this.timedHandlers = [], this.handlers = [], this.removeTimeds = [], this.removeHandlers = [], this.addTimeds = [], this.addHandlers = [], this.protocolErrorHandlers = {
                                HTTP: {},
                                websocket: {}
                            }, this._idleTimeout = null, this._disconnectTimeout = null, this.authenticated = !1, this.connected = !1, this.disconnecting = !1, this.do_authentication = !0, this.paused = !1, this.restored = !1, this._data = [], this._uniqueId = 0, this._sasl_success_handler = null, this._sasl_failure_handler = null, this._sasl_challenge_handler = null, this.maxRetries = 5, this._idleTimeout = setTimeout(function() {
                                this._onIdle()
                            }.bind(this), 100), n.addCookies(this.options.cookies), this.registerSASLMechanisms(this.options.mechanisms), r._connectionPlugins)
                            if (r._connectionPlugins.hasOwnProperty(o)) {
                                var a = r._connectionPlugins[o],
                                    s = function() {};
                                s.prototype = a, this[o] = new s, this[o].init(this)
                            }
                    }, r.Connection.prototype = {
                        reset: function() {
                            this._proto._reset(), this.do_session = !1, this.do_bind = !1, this.timedHandlers = [], this.handlers = [], this.removeTimeds = [], this.removeHandlers = [], this.addTimeds = [], this.addHandlers = [], this.authenticated = !1, this.connected = !1, this.disconnecting = !1, this.restored = !1, this._data = [], this._requests = [], this._uniqueId = 0
                        },
                        pause: function() {
                            this.paused = !0
                        },
                        resume: function() {
                            this.paused = !1
                        },
                        getUniqueId: function(e) {
                            var t = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (function(e) {
                                var t = 16 * Math.random() | 0;
                                return ("x" === e ? t : 3 & t | 8).toString(16)
                            }));
                            return "string" == typeof e || "number" == typeof e ? t + ":" + e : t + ""
                        },
                        addProtocolErrorHandler: function(e, t, n) {
                            this.protocolErrorHandlers[e][t] = n
                        },
                        connect: function(e, t, n, i, o, a, s) {
                            this.jid = e, this.authzid = r.getBareJidFromJid(this.jid), this.authcid = s || r.getNodeFromJid(this.jid), this.pass = t, this.servtype = "xmpp", this.connect_callback = n, this.disconnecting = !1, this.connected = !1, this.authenticated = !1, this.restored = !1, this.domain = r.getDomainFromJid(this.jid), this._changeConnectStatus(r.Status.CONNECTING, null), this._proto._connect(i, o, a)
                        },
                        attach: function(e, t, n, i, o, a, s) {
                            if (!(this._proto instanceof r.Bosh)) throw {
                                name: "StropheSessionError",
                                message: 'The "attach" method can only be used with a BOSH connection.'
                            };
                            this._proto._attach(e, t, n, i, o, a, s)
                        },
                        restore: function(e, t, n, r, i) {
                            if (!this._sessionCachingSupported()) throw {
                                name: "StropheSessionError",
                                message: 'The "restore" method can only be used with a BOSH connection.'
                            };
                            this._proto._restore(e, t, n, r, i)
                        },
                        _sessionCachingSupported: function() {
                            if (this._proto instanceof r.Bosh) {
                                if (!JSON) return !1;
                                try {
                                    sessionStorage.setItem("_strophe_", "_strophe_"), sessionStorage.removeItem("_strophe_")
                                } catch (e) {
                                    return !1
                                }
                                return !0
                            }
                            return !1
                        },
                        xmlInput: function(e) {},
                        xmlOutput: function(e) {},
                        rawInput: function(e) {},
                        rawOutput: function(e) {},
                        nextValidRid: function(e) {},
                        send: function(e) {
                            if (null !== e) {
                                if ("function" == typeof e.sort)
                                    for (var t = 0; t < e.length; t++) this._queueData(e[t]);
                                else "function" == typeof e.tree ? this._queueData(e.tree()) : this._queueData(e);
                                this._proto._send()
                            }
                        },
                        flush: function() {
                            clearTimeout(this._idleTimeout), this._onIdle()
                        },
                        sendPresence: function(e, t, n, r) {
                            var i = null,
                                o = this;
                            "function" == typeof e.tree && (e = e.tree());
                            var a = e.getAttribute("id");
                            if (a || (a = this.getUniqueId("sendPresence"), e.setAttribute("id", a)), "function" == typeof t || "function" == typeof n) {
                                var s = this.addHandler((function(e) {
                                    i && o.deleteTimedHandler(i), "error" === e.getAttribute("type") ? n && n(e) : t && t(e)
                                }), null, "presence", null, a);
                                r && (i = this.addTimedHandler(r, (function() {
                                    return o.deleteHandler(s), n && n(null), !1
                                })))
                            }
                            return this.send(e), a
                        },
                        sendIQ: function(e, t, n, r) {
                            var i = null,
                                o = this;
                            "function" == typeof e.tree && (e = e.tree());
                            var a = e.getAttribute("id");
                            if (a || (a = this.getUniqueId("sendIQ"), e.setAttribute("id", a)), "function" == typeof t || "function" == typeof n) {
                                var s = this.addHandler((function(e) {
                                    i && o.deleteTimedHandler(i);
                                    var r = e.getAttribute("type");
                                    if ("result" === r) t && t(e);
                                    else {
                                        if ("error" !== r) throw {
                                            name: "StropheError",
                                            message: "Got bad IQ type of " + r
                                        };
                                        n && n(e)
                                    }
                                }), null, "iq", ["error", "result"], a);
                                r && (i = this.addTimedHandler(r, (function() {
                                    return o.deleteHandler(s), n && n(null), !1
                                })))
                            }
                            return this.send(e), a
                        },
                        _queueData: function(e) {
                            if (null === e || !e.tagName || !e.childNodes) throw {
                                name: "StropheError",
                                message: "Cannot queue non-DOMElement."
                            };
                            this._data.push(e)
                        },
                        _sendRestart: function() {
                            this._data.push("restart"), this._proto._sendRestart(), this._idleTimeout = setTimeout(function() {
                                this._onIdle()
                            }.bind(this), 100)
                        },
                        addTimedHandler: function(e, t) {
                            var n = new r.TimedHandler(e, t);
                            return this.addTimeds.push(n), n
                        },
                        deleteTimedHandler: function(e) {
                            this.removeTimeds.push(e)
                        },
                        addHandler: function(e, t, n, i, o, a, s) {
                            var c = new r.Handler(e, t, n, i, o, a, s);
                            return this.addHandlers.push(c), c
                        },
                        deleteHandler: function(e) {
                            this.removeHandlers.push(e);
                            var t = this.addHandlers.indexOf(e);
                            t >= 0 && this.addHandlers.splice(t, 1)
                        },
                        registerSASLMechanisms: function(e) {
                            this.mechanisms = {}, (e = e || [r.SASLAnonymous, r.SASLExternal, r.SASLMD5, r.SASLOAuthBearer, r.SASLXOAuth2, r.SASLPlain, r.SASLSHA1]).forEach(this.registerSASLMechanism.bind(this))
                        },
                        registerSASLMechanism: function(e) {
                            this.mechanisms[e.prototype.name] = e
                        },
                        disconnect: function(e) {
                            if (this._changeConnectStatus(r.Status.DISCONNECTING, e), r.info("Disconnect was called because: " + e), this.connected) {
                                var t = !1;
                                this.disconnecting = !0, this.authenticated && (t = s({
                                    xmlns: r.NS.CLIENT,
                                    type: "unavailable"
                                })), this._disconnectTimeout = this._addSysTimedHandler(3e3, this._onDisconnectTimeout.bind(this)), this._proto._disconnect(t)
                            } else r.info("Disconnect was called before Strophe connected to the server"), this._proto._abortAllRequests(), this._doDisconnect()
                        },
                        _changeConnectStatus: function(e, t, n) {
                            for (var i in r._connectionPlugins)
                                if (r._connectionPlugins.hasOwnProperty(i)) {
                                    var o = this[i];
                                    if (o.statusChanged) try {
                                        o.statusChanged(e, t)
                                    } catch (e) {
                                        r.error(i + " plugin caused an exception changing status: " + e)
                                    }
                                } if (this.connect_callback) try {
                                this.connect_callback(e, t, n)
                            } catch (e) {
                                r._handleError(e), r.error("User connection callback caused an exception: " + e)
                            }
                        },
                        _doDisconnect: function(e) {
                            "number" == typeof this._idleTimeout && clearTimeout(this._idleTimeout), null !== this._disconnectTimeout && (this.deleteTimedHandler(this._disconnectTimeout), this._disconnectTimeout = null), r.info("_doDisconnect was called"), this._proto._doDisconnect(), this.authenticated = !1, this.disconnecting = !1, this.restored = !1, this.handlers = [], this.timedHandlers = [], this.removeTimeds = [], this.removeHandlers = [], this.addTimeds = [], this.addHandlers = [], this._changeConnectStatus(r.Status.DISCONNECTED, e), this.connected = !1
                        },
                        _dataRecv: function(e, t) {
                            r.info("_dataRecv called");
                            var n = this._proto._reqToData(e);
                            if (null !== n) {
                                var i, o;
                                for (this.xmlInput !== r.Connection.prototype.xmlInput && (n.nodeName === this._proto.strip && n.childNodes.length ? this.xmlInput(n.childNodes[0]) : this.xmlInput(n)), this.rawInput !== r.Connection.prototype.rawInput && (t ? this.rawInput(t) : this.rawInput(r.serialize(n))); this.removeHandlers.length > 0;) o = this.removeHandlers.pop(), (i = this.handlers.indexOf(o)) >= 0 && this.handlers.splice(i, 1);
                                for (; this.addHandlers.length > 0;) this.handlers.push(this.addHandlers.pop());
                                if (this.disconnecting && this._proto._emptyQueue()) this._doDisconnect();
                                else {
                                    var a, s, c = n.getAttribute("type");
                                    if (null !== c && "terminate" === c) {
                                        if (this.disconnecting) return;
                                        return a = n.getAttribute("condition"), s = n.getElementsByTagName("conflict"), null !== a ? ("remote-stream-error" === a && s.length > 0 && (a = "conflict"), this._changeConnectStatus(r.Status.CONNFAIL, a)) : this._changeConnectStatus(r.Status.CONNFAIL, r.ErrorCondition.UNKOWN_REASON), void this._doDisconnect(a)
                                    }
                                    var u = this;
                                    r.forEachChild(n, null, (function(e) {
                                        var t, n;
                                        for (n = u.handlers, u.handlers = [], t = 0; t < n.length; t++) {
                                            var i = n[t];
                                            try {
                                                !i.isMatch(e) || !u.authenticated && i.user ? u.handlers.push(i) : i.run(e) && u.handlers.push(i)
                                            } catch (e) {
                                                r.warn("Removing Strophe handlers due to uncaught exception: " + e.message)
                                            }
                                        }
                                    }))
                                }
                            }
                        },
                        mechanisms: {},
                        _connect_cb: function(e, t, n) {
                            var i;
                            r.info("_connect_cb was called"), this.connected = !0;
                            try {
                                i = this._proto._reqToData(e)
                            } catch (e) {
                                if ("badformat" !== e) throw e;
                                this._changeConnectStatus(r.Status.CONNFAIL, r.ErrorCondition.BAD_FORMAT), this._doDisconnect(r.ErrorCondition.BAD_FORMAT)
                            }
                            if (i && (this.xmlInput !== r.Connection.prototype.xmlInput && (i.nodeName === this._proto.strip && i.childNodes.length ? this.xmlInput(i.childNodes[0]) : this.xmlInput(i)), this.rawInput !== r.Connection.prototype.rawInput && (n ? this.rawInput(n) : this.rawInput(r.serialize(i))), this._proto._connect_cb(i) !== r.Status.CONNFAIL))
                                if (i.getElementsByTagNameNS ? i.getElementsByTagNameNS(r.NS.STREAM, "features").length > 0 : i.getElementsByTagName("stream:features").length > 0 || i.getElementsByTagName("features").length > 0) {
                                    var o, a, s = [],
                                        c = i.getElementsByTagName("mechanism");
                                    if (c.length > 0)
                                        for (o = 0; o < c.length; o++) a = r.getText(c[o]), this.mechanisms[a] && s.push(this.mechanisms[a]);
                                    0 !== s.length || 0 !== i.getElementsByTagName("auth").length ? !1 !== this.do_authentication && this.authenticate(s) : this._proto._no_auth_received(t)
                                } else this._proto._no_auth_received(t)
                        },
                        sortMechanismsByPriority: function(e) {
                            var t, n, r, i;
                            for (t = 0; t < e.length - 1; ++t) {
                                for (r = t, n = t + 1; n < e.length; ++n) e[n].prototype.priority > e[r].prototype.priority && (r = n);
                                r !== t && (i = e[t], e[t] = e[r], e[r] = i)
                            }
                            return e
                        },
                        _attemptSASLAuth: function(e) {
                            e = this.sortMechanismsByPriority(e || []);
                            var t = 0,
                                n = !1;
                            for (t = 0; t < e.length; ++t)
                                if (e[t].prototype.test(this)) {
                                    this._sasl_success_handler = this._addSysHandler(this._sasl_success_cb.bind(this), null, "success", null, null), this._sasl_failure_handler = this._addSysHandler(this._sasl_failure_cb.bind(this), null, "failure", null, null), this._sasl_challenge_handler = this._addSysHandler(this._sasl_challenge_cb.bind(this), null, "challenge", null, null), this._sasl_mechanism = new e[t], this._sasl_mechanism.onStart(this);
                                    var o = i("auth", {
                                        xmlns: r.NS.SASL,
                                        mechanism: this._sasl_mechanism.name
                                    });
                                    if (this._sasl_mechanism.isClientFirst) {
                                        var a = this._sasl_mechanism.onChallenge(this, null);
                                        o.t(btoa(a))
                                    }
                                    this.send(o.tree()), n = !0;
                                    break
                                } return n
                        },
                        _attemptLegacyAuth: function() {
                            null === r.getNodeFromJid(this.jid) ? (this._changeConnectStatus(r.Status.CONNFAIL, r.ErrorCondition.MISSING_JID_NODE), this.disconnect(r.ErrorCondition.MISSING_JID_NODE)) : (this._changeConnectStatus(r.Status.AUTHENTICATING, null), this._addSysHandler(this._auth1_cb.bind(this), null, null, null, "_auth_1"), this.send(o({
                                type: "get",
                                to: this.domain,
                                id: "_auth_1"
                            }).c("query", {
                                xmlns: r.NS.AUTH
                            }).c("username", {}).t(r.getNodeFromJid(this.jid)).tree()))
                        },
                        authenticate: function(e) {
                            this._attemptSASLAuth(e) || this._attemptLegacyAuth()
                        },
                        _sasl_challenge_cb: function(e) {
                            var t = atob(r.getText(e)),
                                n = this._sasl_mechanism.onChallenge(this, t),
                                o = i("response", {
                                    xmlns: r.NS.SASL
                                });
                            return "" !== n && o.t(btoa(n)), this.send(o.tree()), !0
                        },
                        _auth1_cb: function(e) {
                            var t = o({
                                type: "set",
                                id: "_auth_2"
                            }).c("query", {
                                xmlns: r.NS.AUTH
                            }).c("username", {}).t(r.getNodeFromJid(this.jid)).up().c("password").t(this.pass);
                            return r.getResourceFromJid(this.jid) || (this.jid = r.getBareJidFromJid(this.jid) + "/strophe"), t.up().c("resource", {}).t(r.getResourceFromJid(this.jid)), this._addSysHandler(this._auth2_cb.bind(this), null, null, null, "_auth_2"), this.send(t.tree()), !1
                        },
                        _sasl_success_cb: function(e) {
                            if (this._sasl_data["server-signature"]) {
                                var t, n = atob(r.getText(e)).match(/([a-z]+)=([^,]+)(,|$)/);
                                if ("v" === n[1] && (t = n[2]), t !== this._sasl_data["server-signature"]) return this.deleteHandler(this._sasl_failure_handler), this._sasl_failure_handler = null, this._sasl_challenge_handler && (this.deleteHandler(this._sasl_challenge_handler), this._sasl_challenge_handler = null), this._sasl_data = {}, this._sasl_failure_cb(null)
                            }
                            r.info("SASL authentication succeeded."), this._sasl_mechanism && this._sasl_mechanism.onSuccess(), this.deleteHandler(this._sasl_failure_handler), this._sasl_failure_handler = null, this._sasl_challenge_handler && (this.deleteHandler(this._sasl_challenge_handler), this._sasl_challenge_handler = null);
                            var i = [],
                                o = function(e, t) {
                                    for (; e.length;) this.deleteHandler(e.pop());
                                    return this._sasl_auth1_cb.bind(this)(t), !1
                                };
                            return i.push(this._addSysHandler(function(e) {
                                o.bind(this)(i, e)
                            }.bind(this), null, "stream:features", null, null)), i.push(this._addSysHandler(function(e) {
                                o.bind(this)(i, e)
                            }.bind(this), r.NS.STREAM, "features", null, null)), this._sendRestart(), !1
                        },
                        _sasl_auth1_cb: function(e) {
                            var t, n;
                            for (this.features = e, t = 0; t < e.childNodes.length; t++) "bind" === (n = e.childNodes[t]).nodeName && (this.do_bind = !0), "session" === n.nodeName && (this.do_session = !0);
                            if (!this.do_bind) return this._changeConnectStatus(r.Status.AUTHFAIL, null), !1;
                            this._addSysHandler(this._sasl_bind_cb.bind(this), null, null, null, "_bind_auth_2");
                            var i = r.getResourceFromJid(this.jid);
                            return i ? this.send(o({
                                type: "set",
                                id: "_bind_auth_2"
                            }).c("bind", {
                                xmlns: r.NS.BIND
                            }).c("resource", {}).t(i).tree()) : this.send(o({
                                type: "set",
                                id: "_bind_auth_2"
                            }).c("bind", {
                                xmlns: r.NS.BIND
                            }).tree()), !1
                        },
                        _sasl_bind_cb: function(e) {
                            var t;
                            if ("error" === e.getAttribute("type")) return r.info("SASL binding failed."), e.getElementsByTagName("conflict").length > 0 && (t = r.ErrorCondition.CONFLICT), this._changeConnectStatus(r.Status.AUTHFAIL, t, e), !1;
                            var n, i = e.getElementsByTagName("bind");
                            if (!(i.length > 0)) return r.info("SASL binding failed."), this._changeConnectStatus(r.Status.AUTHFAIL, null, e), !1;
                            (n = i[0].getElementsByTagName("jid")).length > 0 && (this.jid = r.getText(n[0]), this.do_session ? (this._addSysHandler(this._sasl_session_cb.bind(this), null, null, null, "_session_auth_2"), this.send(o({
                                type: "set",
                                id: "_session_auth_2"
                            }).c("session", {
                                xmlns: r.NS.SESSION
                            }).tree())) : (this.authenticated = !0, this._changeConnectStatus(r.Status.CONNECTED, null)))
                        },
                        _sasl_session_cb: function(e) {
                            if ("result" === e.getAttribute("type")) this.authenticated = !0, this._changeConnectStatus(r.Status.CONNECTED, null);
                            else if ("error" === e.getAttribute("type")) return r.info("Session creation failed."), this._changeConnectStatus(r.Status.AUTHFAIL, null, e), !1;
                            return !1
                        },
                        _sasl_failure_cb: function(e) {
                            return this._sasl_success_handler && (this.deleteHandler(this._sasl_success_handler), this._sasl_success_handler = null), this._sasl_challenge_handler && (this.deleteHandler(this._sasl_challenge_handler), this._sasl_challenge_handler = null), this._sasl_mechanism && this._sasl_mechanism.onFailure(), this._changeConnectStatus(r.Status.AUTHFAIL, null, e), !1
                        },
                        _auth2_cb: function(e) {
                            return "result" === e.getAttribute("type") ? (this.authenticated = !0, this._changeConnectStatus(r.Status.CONNECTED, null)) : "error" === e.getAttribute("type") && (this._changeConnectStatus(r.Status.AUTHFAIL, null, e), this.disconnect("authentication failed")), !1
                        },
                        _addSysTimedHandler: function(e, t) {
                            var n = new r.TimedHandler(e, t);
                            return n.user = !1, this.addTimeds.push(n), n
                        },
                        _addSysHandler: function(e, t, n, i, o) {
                            var a = new r.Handler(e, t, n, i, o);
                            return a.user = !1, this.addHandlers.push(a), a
                        },
                        _onDisconnectTimeout: function() {
                            return r.info("_onDisconnectTimeout was called"), this._changeConnectStatus(r.Status.CONNTIMEOUT, null), this._proto._onDisconnectTimeout(), this._doDisconnect(), !1
                        },
                        _onIdle: function() {
                            for (var e, t, n; this.addTimeds.length > 0;) this.timedHandlers.push(this.addTimeds.pop());
                            for (; this.removeTimeds.length > 0;) t = this.removeTimeds.pop(), (e = this.timedHandlers.indexOf(t)) >= 0 && this.timedHandlers.splice(e, 1);
                            var r = (new Date).getTime();
                            for (n = [], e = 0; e < this.timedHandlers.length; e++) t = this.timedHandlers[e], !this.authenticated && t.user || (t.lastCalled + t.period - r <= 0 ? t.run() && n.push(t) : n.push(t));
                            this.timedHandlers = n, clearTimeout(this._idleTimeout), this._proto._onIdle(), this.connected && (this._idleTimeout = setTimeout(function() {
                                this._onIdle()
                            }.bind(this), 100))
                        }
                    }, r.SASLMechanism = function(e, t, n) {
                        this.name = e, this.isClientFirst = t, this.priority = n
                    }, r.SASLMechanism.prototype = {
                        test: function(e) {
                            return !0
                        },
                        onStart: function(e) {
                            this._connection = e
                        },
                        onChallenge: function(e, t) {
                            throw new Error("You should implement challenge handling!")
                        },
                        onFailure: function() {
                            this._connection = null
                        },
                        onSuccess: function() {
                            this._connection = null
                        }
                    }, r.SASLAnonymous = function() {}, r.SASLAnonymous.prototype = new r.SASLMechanism("ANONYMOUS", !1, 20), r.SASLAnonymous.prototype.test = function(e) {
                        return null === e.authcid
                    }, r.SASLPlain = function() {}, r.SASLPlain.prototype = new r.SASLMechanism("PLAIN", !0, 50), r.SASLPlain.prototype.test = function(e) {
                        return null !== e.authcid
                    }, r.SASLPlain.prototype.onChallenge = function(e) {
                        var t = e.authzid;
                        return t += "\0", t += e.authcid, t += "\0", t += e.pass, n.utf16to8(t)
                    }, r.SASLSHA1 = function() {}, r.SASLSHA1.prototype = new r.SASLMechanism("SCRAM-SHA-1", !0, 70), r.SASLSHA1.prototype.test = function(e) {
                        return null !== e.authcid
                    }, r.SASLSHA1.prototype.onChallenge = function(r, i, o) {
                        var a = o || t.hexdigest(1234567890 * Math.random()),
                            s = "n=" + n.utf16to8(r.authcid);
                        return s += ",r=", s += a, r._sasl_data.cnonce = a, r._sasl_data["client-first-message-bare"] = s, s = "n,," + s, this.onChallenge = function(t, r) {
                            for (var i, o, a, s, c, u, l, d, p, h, f, m, v = "c=biws,", y = t._sasl_data["client-first-message-bare"] + "," + r + ",", g = t._sasl_data.cnonce, _ = /([a-z]+)=([^,]+)(,|$)/; r.match(_);) {
                                var S = r.match(_);
                                switch (r = r.replace(S[0], ""), S[1]) {
                                    case "r":
                                        i = S[2];
                                        break;
                                    case "s":
                                        o = S[2];
                                        break;
                                    case "i":
                                        a = S[2]
                                }
                            }
                            if (i.substr(0, g.length) !== g) return t._sasl_data = {}, t._sasl_failure_cb();
                            for (y += v += "r=" + i, o = atob(o), o += "\0\0\0", p = n.utf16to8(t.pass), s = u = e.core_hmac_sha1(p, o), l = 1; l < a; l++) {
                                for (c = e.core_hmac_sha1(p, e.binb2str(u)), d = 0; d < 5; d++) s[d] ^= c[d];
                                u = c
                            }
                            for (s = e.binb2str(s), h = e.core_hmac_sha1(s, "Client Key"), f = e.str_hmac_sha1(s, "Server Key"), m = e.core_hmac_sha1(e.str_sha1(e.binb2str(h)), y), t._sasl_data["server-signature"] = e.b64_hmac_sha1(f, y), d = 0; d < 5; d++) h[d] ^= m[d];
                            return v += ",p=" + btoa(e.binb2str(h))
                        }.bind(this), s
                    }, r.SASLMD5 = function() {}, r.SASLMD5.prototype = new r.SASLMechanism("DIGEST-MD5", !1, 60), r.SASLMD5.prototype.test = function(e) {
                        return null !== e.authcid
                    }, r.SASLMD5.prototype._quote = function(e) {
                        return '"' + e.replace(/\\/g, "\\\\").replace(/"/g, '\\"') + '"'
                    }, r.SASLMD5.prototype.onChallenge = function(e, r, i) {
                        for (var o, a = /([a-z]+)=("[^"]+"|[^,"]+)(?:,|$)/, s = i || t.hexdigest("" + 1234567890 * Math.random()), c = "", u = null, l = ""; r.match(a);) switch (o = r.match(a), r = r.replace(o[0], ""), o[2] = o[2].replace(/^"(.+)"$/, "$1"), o[1]) {
                            case "realm":
                                c = o[2];
                                break;
                            case "nonce":
                                l = o[2];
                                break;
                            case "qop":
                                o[2];
                                break;
                            case "host":
                                u = o[2]
                        }
                        var d = e.servtype + "/" + e.domain;
                        null !== u && (d = d + "/" + u);
                        var p = n.utf16to8(e.authcid + ":" + c + ":" + this._connection.pass),
                            h = t.hash(p) + ":" + l + ":" + s,
                            f = "AUTHENTICATE:" + d,
                            m = "";
                        return m += "charset=utf-8,", m += "username=" + this._quote(n.utf16to8(e.authcid)) + ",", m += "realm=" + this._quote(c) + ",", m += "nonce=" + this._quote(l) + ",", m += "nc=00000001,", m += "cnonce=" + this._quote(s) + ",", m += "digest-uri=" + this._quote(d) + ",", m += "response=" + t.hexdigest(t.hexdigest(h) + ":" + l + ":00000001:" + s + ":auth:" + t.hexdigest(f)) + ",", m += "qop=auth", this.onChallenge = function() {
                            return ""
                        }, m
                    }, r.SASLOAuthBearer = function() {}, r.SASLOAuthBearer.prototype = new r.SASLMechanism("OAUTHBEARER", !0, 40), r.SASLOAuthBearer.prototype.test = function(e) {
                        return null !== e.pass
                    }, r.SASLOAuthBearer.prototype.onChallenge = function(e) {
                        var t = "n,";
                        return null !== e.authcid && (t = t + "a=" + e.authzid), t += ",", t += "", t += "auth=Bearer ", t += e.pass, t += "", t += "", n.utf16to8(t)
                    }, r.SASLExternal = function() {}, r.SASLExternal.prototype = new r.SASLMechanism("EXTERNAL", !0, 10), r.SASLExternal.prototype.onChallenge = function(e) {
                        return e.authcid === e.authzid ? "" : e.authzid
                    }, r.SASLXOAuth2 = function() {}, r.SASLXOAuth2.prototype = new r.SASLMechanism("X-OAUTH2", !0, 30), r.SASLXOAuth2.prototype.test = function(e) {
                        return null !== e.pass
                    }, r.SASLXOAuth2.prototype.onChallenge = function(e) {
                        var t = "\0";
                        return null !== e.authcid && (t += e.authzid), t += "\0", t += e.pass, n.utf16to8(t)
                    }, {
                        Strophe: r,
                        $build: i,
                        $iq: o,
                        $msg: function(e) {
                            return new r.Builder("message", e)
                        },
                        $pres: s,
                        SHA1: e,
                        MD5: t,
                        b64_hmac_sha1: e.b64_hmac_sha1,
                        b64_sha1: e.b64_sha1,
                        str_hmac_sha1: e.str_hmac_sha1,
                        str_sha1: e.str_sha1
                    }
                })),
                function(n, o) {
                    if ("function" == typeof i && i.amd) i("strophe-bosh", ["strophe-core"], (function(e) {
                        return o(e.Strophe, e.$build)
                    }));
                    else if ("object" === a(t)) {
                        var s = r("./core");
                        e.exports = o(s.Strophe, s.$build)
                    } else o(Strophe, $build)
                }(0, (function(e, t) {
                    return e.Request = function(t, n, r, i) {
                        this.id = ++e._requestId, this.xmlData = t, this.data = e.serialize(t), this.origFunc = n, this.func = n, this.rid = r, this.date = NaN, this.sends = i || 0, this.abort = !1, this.dead = null, this.age = function() {
                            return this.date ? (new Date - this.date) / 1e3 : 0
                        }, this.timeDead = function() {
                            return this.dead ? (new Date - this.dead) / 1e3 : 0
                        }, this.xhr = this._newXHR()
                    }, e.Request.prototype = {
                        getResponse: function() {
                            var t = null;
                            if (this.xhr.responseXML && this.xhr.responseXML.documentElement) {
                                if ("parsererror" === (t = this.xhr.responseXML.documentElement).tagName) throw e.error("invalid response received"), e.error("responseText: " + this.xhr.responseText), e.error("responseXML: " + e.serialize(this.xhr.responseXML)), "parsererror"
                            } else if (this.xhr.responseText) {
                                if (e.debug("Got responseText but no responseXML; attempting to parse it with DOMParser..."), !(t = (new DOMParser).parseFromString(this.xhr.responseText, "application/xml").documentElement)) throw new Error("Parsing produced null node");
                                if (t.querySelector("parsererror")) throw e.error("invalid response received: " + t.querySelector("parsererror").textContent), e.error("responseText: " + this.xhr.responseText), "badformat"
                            }
                            return t
                        },
                        _newXHR: function() {
                            var e = null;
                            return window.XMLHttpRequest ? (e = new XMLHttpRequest).overrideMimeType && e.overrideMimeType("text/xml; charset=utf-8") : window.ActiveXObject && (e = new ActiveXObject("Microsoft.XMLHTTP")), e.onreadystatechange = this.func.bind(null, this), e
                        }
                    }, e.Bosh = function(e) {
                        this._conn = e, this.rid = Math.floor(4294967295 * Math.random()), this.sid = null, this.hold = 1, this.wait = 60, this.window = 5, this.errors = 0, this.inactivity = null, this.lastResponseHeaders = null, this._requests = []
                    }, e.Bosh.prototype = {
                        strip: null,
                        _buildBody: function() {
                            var n = t("body", {
                                rid: this.rid++,
                                xmlns: e.NS.HTTPBIND
                            });
                            return null !== this.sid && n.attrs({
                                sid: this.sid
                            }), this._conn.options.keepalive && this._conn._sessionCachingSupported() && this._cacheSession(), n
                        },
                        _reset: function() {
                            this.rid = Math.floor(4294967295 * Math.random()), this.sid = null, this.errors = 0, this._conn._sessionCachingSupported() && window.sessionStorage.removeItem("strophe-bosh-session"), this._conn.nextValidRid(this.rid)
                        },
                        _connect: function(t, n, r) {
                            this.wait = t || this.wait, this.hold = n || this.hold, this.errors = 0;
                            var i = this._buildBody().attrs({
                                to: this._conn.domain,
                                "xml:lang": "en",
                                wait: this.wait,
                                hold: this.hold,
                                content: "text/xml; charset=utf-8",
                                ver: "1.6",
                                "xmpp:version": "1.0",
                                "xmlns:xmpp": e.NS.BOSH
                            });
                            r && i.attrs({
                                route: r
                            });
                            var o = this._conn._connect_cb;
                            this._requests.push(new e.Request(i.tree(), this._onRequestStateChange.bind(this, o.bind(this._conn)), i.tree().getAttribute("rid"))), this._throttledRequestHandler()
                        },
                        _attach: function(t, n, r, i, o, a, s) {
                            this._conn.jid = t, this.sid = n, this.rid = r, this._conn.connect_callback = i, this._conn.domain = e.getDomainFromJid(this._conn.jid), this._conn.authenticated = !0, this._conn.connected = !0, this.wait = o || this.wait, this.hold = a || this.hold, this.window = s || this.window, this._conn._changeConnectStatus(e.Status.ATTACHED, null)
                        },
                        _restore: function(t, n, r, i, o) {
                            var a = JSON.parse(window.sessionStorage.getItem("strophe-bosh-session"));
                            if (!(null != a && a.rid && a.sid && a.jid && (null == t || e.getBareJidFromJid(a.jid) === e.getBareJidFromJid(t) || null === e.getNodeFromJid(t) && e.getDomainFromJid(a.jid) === t))) throw {
                                name: "StropheSessionError",
                                message: "_restore: no restoreable session."
                            };
                            this._conn.restored = !0, this._attach(a.jid, a.sid, a.rid, n, r, i, o)
                        },
                        _cacheSession: function() {
                            this._conn.authenticated ? this._conn.jid && this.rid && this.sid && window.sessionStorage.setItem("strophe-bosh-session", JSON.stringify({
                                jid: this._conn.jid,
                                rid: this.rid,
                                sid: this.sid
                            })) : window.sessionStorage.removeItem("strophe-bosh-session")
                        },
                        _connect_cb: function(t) {
                            var n, r, i = t.getAttribute("type");
                            if (null !== i && "terminate" === i) return n = t.getAttribute("condition"), e.error("BOSH-Connection failed: " + n), r = t.getElementsByTagName("conflict"), null !== n ? ("remote-stream-error" === n && r.length > 0 && (n = "conflict"), this._conn._changeConnectStatus(e.Status.CONNFAIL, n)) : this._conn._changeConnectStatus(e.Status.CONNFAIL, "unknown"), this._conn._doDisconnect(n), e.Status.CONNFAIL;
                            this.sid || (this.sid = t.getAttribute("sid"));
                            var o = t.getAttribute("requests");
                            o && (this.window = parseInt(o, 10));
                            var a = t.getAttribute("hold");
                            a && (this.hold = parseInt(a, 10));
                            var s = t.getAttribute("wait");
                            s && (this.wait = parseInt(s, 10));
                            var c = t.getAttribute("inactivity");
                            c && (this.inactivity = parseInt(c, 10))
                        },
                        _disconnect: function(e) {
                            this._sendTerminate(e)
                        },
                        _doDisconnect: function() {
                            this.sid = null, this.rid = Math.floor(4294967295 * Math.random()), this._conn._sessionCachingSupported() && window.sessionStorage.removeItem("strophe-bosh-session"), this._conn.nextValidRid(this.rid)
                        },
                        _emptyQueue: function() {
                            return 0 === this._requests.length
                        },
                        _callProtocolErrorHandlers: function(e) {
                            var t, n = this._getRequestStatus(e);
                            (t = this._conn.protocolErrorHandlers.HTTP[n]) && t.call(this, n)
                        },
                        _hitError: function(t) {
                            this.errors++, e.warn("request errored, status: " + t + ", number of errors: " + this.errors), this.errors > 4 && this._conn._onDisconnectTimeout()
                        },
                        _no_auth_received: function(t) {
                            e.warn("Server did not yet offer a supported authentication mechanism. Sending a blank poll request."), t = t ? t.bind(this._conn) : this._conn._connect_cb.bind(this._conn);
                            var n = this._buildBody();
                            this._requests.push(new e.Request(n.tree(), this._onRequestStateChange.bind(this, t), n.tree().getAttribute("rid"))), this._throttledRequestHandler()
                        },
                        _onDisconnectTimeout: function() {
                            this._abortAllRequests()
                        },
                        _abortAllRequests: function() {
                            for (var e; this._requests.length > 0;)(e = this._requests.pop()).abort = !0, e.xhr.abort(), e.xhr.onreadystatechange = function() {}
                        },
                        _onIdle: function() {
                            var t = this._conn._data;
                            if (this._conn.authenticated && 0 === this._requests.length && 0 === t.length && !this._conn.disconnecting && (e.info("no requests during idle cycle, sending blank request"), t.push(null)), !this._conn.paused) {
                                if (this._requests.length < 2 && t.length > 0) {
                                    for (var n = this._buildBody(), r = 0; r < t.length; r++) null !== t[r] && ("restart" === t[r] ? n.attrs({
                                        to: this._conn.domain,
                                        "xml:lang": "en",
                                        "xmpp:restart": "true",
                                        "xmlns:xmpp": e.NS.BOSH
                                    }) : n.cnode(t[r]).up());
                                    delete this._conn._data, this._conn._data = [], this._requests.push(new e.Request(n.tree(), this._onRequestStateChange.bind(this, this._conn._dataRecv.bind(this._conn)), n.tree().getAttribute("rid"))), this._throttledRequestHandler()
                                }
                                if (this._requests.length > 0) {
                                    var i = this._requests[0].age();
                                    null !== this._requests[0].dead && this._requests[0].timeDead() > Math.floor(e.SECONDARY_TIMEOUT * this.wait) && this._throttledRequestHandler(), i > Math.floor(e.TIMEOUT * this.wait) && (e.warn("Request " + this._requests[0].id + " timed out, over " + Math.floor(e.TIMEOUT * this.wait) + " seconds since last activity"), this._throttledRequestHandler())
                                }
                            }
                        },
                        _getRequestStatus: function(t, n) {
                            var r;
                            if (4 === t.xhr.readyState) try {
                                r = t.xhr.status
                            } catch (t) {
                                e.error("Caught an error while retrieving a request's status, reqStatus: " + r)
                            }
                            return void 0 === r && (r = "number" == typeof n ? n : 0), r
                        },
                        _onRequestStateChange: function(t, n) {
                            if (e.debug("request id " + n.id + "." + n.sends + " state changed to " + n.xhr.readyState), n.abort) n.abort = !1;
                            else if (4 === n.xhr.readyState) {
                                var r = this._getRequestStatus(n);
                                if (this.lastResponseHeaders = n.xhr.getAllResponseHeaders(), this.disconnecting && r >= 400) return this._hitError(r), void this._callProtocolErrorHandlers(n);
                                var i = r > 0 && r < 500,
                                    o = n.sends > this._conn.maxRetries;
                                if ((i || o) && (this._removeRequest(n), e.debug("request id " + n.id + " should now be removed")), 200 === r) {
                                    var a = this._requests[0] === n;
                                    (this._requests[1] === n || a && this._requests.length > 0 && this._requests[0].age() > Math.floor(e.SECONDARY_TIMEOUT * this.wait)) && this._restartRequest(0), this._conn.nextValidRid(Number(n.rid) + 1), e.debug("request id " + n.id + "." + n.sends + " got 200"), t(n), this.errors = 0
                                } else 0 === r || r >= 400 && r < 600 || r >= 12e3 ? (e.error("request id " + n.id + "." + n.sends + " error " + r + " happened"), this._hitError(r), this._callProtocolErrorHandlers(n), r >= 400 && r < 500 && (this._conn._changeConnectStatus(e.Status.DISCONNECTING, null), this._conn._doDisconnect())) : e.error("request id " + n.id + "." + n.sends + " error " + r + " happened");
                                i || o ? o && !this._conn.connected && this._conn._changeConnectStatus(e.Status.CONNFAIL, "giving-up") : this._throttledRequestHandler()
                            }
                        },
                        _processRequest: function(t) {
                            var n = this,
                                r = this._requests[t],
                                i = this._getRequestStatus(r, -1);
                            if (r.sends > this._conn.maxRetries) this._conn._onDisconnectTimeout();
                            else {
                                var o = r.age(),
                                    a = !isNaN(o) && o > Math.floor(e.TIMEOUT * this.wait),
                                    s = null !== r.dead && r.timeDead() > Math.floor(e.SECONDARY_TIMEOUT * this.wait),
                                    c = 4 === r.xhr.readyState && (i < 1 || i >= 500);
                                if ((a || s || c) && (s && e.error("Request " + this._requests[t].id + " timed out (secondary), restarting"), r.abort = !0, r.xhr.abort(), r.xhr.onreadystatechange = function() {}, this._requests[t] = new e.Request(r.xmlData, r.origFunc, r.rid, r.sends), r = this._requests[t]), 0 === r.xhr.readyState) {
                                    e.debug("request id " + r.id + "." + r.sends + " posting");
                                    try {
                                        var u = this._conn.options.contentType || "text/xml; charset=utf-8";
                                        r.xhr.open("POST", this._conn.service, !this._conn.options.sync), void 0 !== r.xhr.setRequestHeader && r.xhr.setRequestHeader("Content-Type", u), this._conn.options.withCredentials && (r.xhr.withCredentials = !0)
                                    } catch (t) {
                                        return e.error("XHR open failed: " + t.toString()), this._conn.connected || this._conn._changeConnectStatus(e.Status.CONNFAIL, "bad-service"), void this._conn.disconnect()
                                    }
                                    var l = function() {
                                        if (r.date = new Date, n._conn.options.customHeaders) {
                                            var e = n._conn.options.customHeaders;
                                            for (var t in e) e.hasOwnProperty(t) && r.xhr.setRequestHeader(t, e[t])
                                        }
                                        r.xhr.send(r.data)
                                    };
                                    if (r.sends > 1) {
                                        var d = 1e3 * Math.min(Math.floor(e.TIMEOUT * this.wait), Math.pow(r.sends, 3));
                                        setTimeout((function() {
                                            l()
                                        }), d)
                                    } else l();
                                    r.sends++, this._conn.xmlOutput !== e.Connection.prototype.xmlOutput && (r.xmlData.nodeName === this.strip && r.xmlData.childNodes.length ? this._conn.xmlOutput(r.xmlData.childNodes[0]) : this._conn.xmlOutput(r.xmlData)), this._conn.rawOutput !== e.Connection.prototype.rawOutput && this._conn.rawOutput(r.data)
                                } else e.debug("_processRequest: " + (0 === t ? "first" : "second") + " request has readyState of " + r.xhr.readyState)
                            }
                        },
                        _removeRequest: function(t) {
                            var n;
                            for (e.debug("removing request"), n = this._requests.length - 1; n >= 0; n--) t === this._requests[n] && this._requests.splice(n, 1);
                            t.xhr.onreadystatechange = function() {}, this._throttledRequestHandler()
                        },
                        _restartRequest: function(e) {
                            var t = this._requests[e];
                            null === t.dead && (t.dead = new Date), this._processRequest(e)
                        },
                        _reqToData: function(e) {
                            try {
                                return e.getResponse()
                            } catch (e) {
                                if ("parsererror" !== e) throw e;
                                this._conn.disconnect("strophe-parsererror")
                            }
                        },
                        _sendTerminate: function(t) {
                            e.info("_sendTerminate was called");
                            var n = this._buildBody().attrs({
                                type: "terminate"
                            });
                            t && n.cnode(t.tree());
                            var r = new e.Request(n.tree(), this._onRequestStateChange.bind(this, this._conn._dataRecv.bind(this._conn)), n.tree().getAttribute("rid"));
                            this._requests.push(r), this._throttledRequestHandler()
                        },
                        _send: function() {
                            clearTimeout(this._conn._idleTimeout), this._throttledRequestHandler(), this._conn._idleTimeout = setTimeout(function() {
                                this._onIdle()
                            }.bind(this._conn), 100)
                        },
                        _sendRestart: function() {
                            this._throttledRequestHandler(), clearTimeout(this._conn._idleTimeout)
                        },
                        _throttledRequestHandler: function() {
                            this._requests ? e.debug("_throttledRequestHandler called with " + this._requests.length + " requests") : e.debug("_throttledRequestHandler called with undefined requests"), this._requests && 0 !== this._requests.length && (this._requests.length > 0 && this._processRequest(0), this._requests.length > 1 && Math.abs(this._requests[0].rid - this._requests[1].rid) < this.window && this._processRequest(1))
                        }
                    }, e
                })),
                function(n, o) {
                    if ("function" == typeof i && i.amd) i("strophe-websocket", ["strophe-core"], (function(e) {
                        return o(e.Strophe, e.$build)
                    }));
                    else if ("object" === a(t)) {
                        var s = r("./core");
                        e.exports = o(s.Strophe, s.$build)
                    } else o(Strophe, $build)
                }(0, (function(e, t) {
                    return e.Websocket = function(e) {
                        this._conn = e, this.strip = "wrapper";
                        var t = e.service;
                        if (0 !== t.indexOf("ws:") && 0 !== t.indexOf("wss:")) {
                            var n = "";
                            "ws" === e.options.protocol && "https:" !== window.location.protocol ? n += "ws" : n += "wss", n += "://" + window.location.host, 0 !== t.indexOf("/") ? n += window.location.pathname + t : n += t, e.service = n
                        }
                    }, e.Websocket.prototype = {
                        _buildStream: function() {
                            return t("open", {
                                xmlns: e.NS.FRAMING,
                                to: this._conn.domain,
                                version: "1.0"
                            })
                        },
                        _check_streamerror: function(t, n) {
                            var r;
                            if (0 === (r = t.getElementsByTagNameNS ? t.getElementsByTagNameNS(e.NS.STREAM, "error") : t.getElementsByTagName("stream:error")).length) return !1;
                            for (var i = r[0], o = "", a = "", s = 0; s < i.childNodes.length; s++) {
                                var c = i.childNodes[s];
                                if ("urn:ietf:params:xml:ns:xmpp-streams" !== c.getAttribute("xmlns")) break;
                                "text" === c.nodeName ? a = c.textContent : o = c.nodeName
                            }
                            var u = "WebSocket stream error: ";
                            return u += o || "unknown", a && (u += " - " + a), e.error(u), this._conn._changeConnectStatus(n, o), this._conn._doDisconnect(), !0
                        },
                        _reset: function() {},
                        _connect: function() {
                            this._closeSocket(), this.socket = new WebSocket(this._conn.service, "xmpp"), this.socket.onopen = this._onOpen.bind(this), this.socket.onerror = this._onError.bind(this), this.socket.onclose = this._onClose.bind(this), this.socket.onmessage = this._connect_cb_wrapper.bind(this)
                        },
                        _connect_cb: function(t) {
                            if (this._check_streamerror(t, e.Status.CONNFAIL)) return e.Status.CONNFAIL
                        },
                        _handleStreamStart: function(t) {
                            var n = !1,
                                r = t.getAttribute("xmlns");
                            "string" != typeof r ? n = "Missing xmlns in <open />" : r !== e.NS.FRAMING && (n = "Wrong xmlns in <open />: " + r);
                            var i = t.getAttribute("version");
                            return "string" != typeof i ? n = "Missing version in <open />" : "1.0" !== i && (n = "Wrong version in <open />: " + i), !n || (this._conn._changeConnectStatus(e.Status.CONNFAIL, n), this._conn._doDisconnect(), !1)
                        },
                        _connect_cb_wrapper: function(t) {
                            if (0 === t.data.indexOf("<open ") || 0 === t.data.indexOf("<?xml")) {
                                var n = t.data.replace(/^(<\?.*?\?>\s*)*/, "");
                                if ("" === n) return;
                                var r = (new DOMParser).parseFromString(n, "text/xml").documentElement;
                                this._conn.xmlInput(r), this._conn.rawInput(t.data), this._handleStreamStart(r) && this._connect_cb(r)
                            } else if (0 === t.data.indexOf("<close ")) {
                                var i = (new DOMParser).parseFromString(t.data, "text/xml").documentElement;
                                this._conn.xmlInput(i), this._conn.rawInput(t.data);
                                var o = i.getAttribute("see-other-uri");
                                if (o) {
                                    var a = this._conn.service;
                                    (a.indexOf("wss:") >= 0 && o.indexOf("wss:") >= 0 || a.indexOf("ws:") >= 0) && (this._conn._changeConnectStatus(e.Status.REDIRECT, "Received see-other-uri, resetting connection"), this._conn.reset(), this._conn.service = o, this._connect())
                                } else this._conn._changeConnectStatus(e.Status.CONNFAIL, "Received closing stream"), this._conn._doDisconnect()
                            } else {
                                var s = this._streamWrap(t.data),
                                    c = (new DOMParser).parseFromString(s, "text/xml").documentElement;
                                this.socket.onmessage = this._onMessage.bind(this), this._conn._connect_cb(c, null, t.data)
                            }
                        },
                        _disconnect: function(n) {
                            if (this.socket && this.socket.readyState !== WebSocket.CLOSED) {
                                n && this._conn.send(n);
                                var r = t("close", {
                                    xmlns: e.NS.FRAMING
                                });
                                this._conn.xmlOutput(r.tree());
                                var i = e.serialize(r);
                                this._conn.rawOutput(i);
                                try {
                                    this.socket.send(i)
                                } catch (t) {
                                    e.info("Couldn't send <close /> tag.")
                                }
                            }
                            this._conn._doDisconnect()
                        },
                        _doDisconnect: function() {
                            e.info("WebSockets _doDisconnect was called"), this._closeSocket()
                        },
                        _streamWrap: function(e) {
                            return "<wrapper>" + e + "</wrapper>"
                        },
                        _closeSocket: function() {
                            if (this.socket) try {
                                this.socket.onerror = null, this.socket.close()
                            } catch (e) {}
                            this.socket = null
                        },
                        _emptyQueue: function() {
                            return !0
                        },
                        _onClose: function(t) {
                            this._conn.connected && !this._conn.disconnecting ? (e.error("Websocket closed unexpectedly"), this._conn._doDisconnect()) : t && 1006 === t.code && !this._conn.connected && this.socket ? (e.error("Websocket closed unexcectedly"), this._conn._changeConnectStatus(e.Status.CONNFAIL, "The WebSocket connection could not be established or was disconnected."), this._conn._doDisconnect()) : e.info("Websocket closed")
                        },
                        _no_auth_received: function(t) {
                            e.error("Server did not offer a supported authentication mechanism"), this._changeConnectStatus(e.Status.CONNFAIL, e.ErrorCondition.NO_AUTH_MECH), t && t.call(this._conn), this._conn._doDisconnect()
                        },
                        _onDisconnectTimeout: function() {},
                        _abortAllRequests: function() {},
                        _onError: function(t) {
                            e.error("Websocket error " + t), this._conn._changeConnectStatus(e.Status.CONNFAIL, "The WebSocket connection could not be established or was disconnected."), this._disconnect()
                        },
                        _onIdle: function() {
                            var t = this._conn._data;
                            if (t.length > 0 && !this._conn.paused) {
                                for (var n = 0; n < t.length; n++) {
                                    var r, i;
                                    null !== t[n] && (r = "restart" === t[n] ? this._buildStream().tree() : t[n], i = e.serialize(r), this._conn.xmlOutput(r), this._conn.rawOutput(i), this.socket.send(i))
                                }
                                this._conn._data = []
                            }
                        },
                        _onMessage: function(t) {
                            var n, r, i = '<close xmlns="urn:ietf:params:xml:ns:xmpp-framing" />';
                            if (t.data === i) return this._conn.rawInput(i), this._conn.xmlInput(t), void(this._conn.disconnecting || this._conn._doDisconnect());
                            if (0 === t.data.search("<open ")) {
                                if (n = (new DOMParser).parseFromString(t.data, "text/xml").documentElement, !this._handleStreamStart(n)) return
                            } else r = this._streamWrap(t.data), n = (new DOMParser).parseFromString(r, "text/xml").documentElement;
                            return this._check_streamerror(n, e.Status.ERROR) ? void 0 : this._conn.disconnecting && "presence" === n.firstChild.nodeName && "unavailable" === n.firstChild.getAttribute("type") ? (this._conn.xmlInput(n), void this._conn.rawInput(e.serialize(n))) : void this._conn._dataRecv(n, t.data)
                        },
                        _onOpen: function() {
                            e.info("Websocket open");
                            var t = this._buildStream();
                            this._conn.xmlOutput(t.tree());
                            var n = e.serialize(t);
                            this._conn.rawOutput(n), this.socket.send(n)
                        },
                        _reqToData: function(e) {
                            return e
                        },
                        _send: function() {
                            this._conn.flush()
                        },
                        _sendRestart: function() {
                            clearTimeout(this._conn._idleTimeout), this._conn._onIdle.bind(this._conn)()
                        }
                    }, e
                })),
                function(n) {
                    if ("function" == typeof i && i.amd) i("strophe", ["strophe-core", "strophe-bosh", "strophe-websocket"], (function(e) {
                        return e
                    }));
                    else if ("object" === a(t)) {
                        var o = r("./core");
                        r("./bosh"), r("./websocket"), e.exports = o
                    }
                }(), r(["strophe-polyfill"]), r("strophe")
        }) ? r.apply(t, i) : r) || (e.exports = o)
    }, function(e, t, n) {
        "use strict";
        n.r(t), n.d(t, "AUTH_STATUS_CHANGED", (function() {
            return r
        })), n.d(t, "AVATAR_CHANGED", (function() {
            return i
        })), n.d(t, "BEFORE_STATISTICS_DISPOSED", (function() {
            return o
        })), n.d(t, "CONFERENCE_ERROR", (function() {
            return a
        })), n.d(t, "CONFERENCE_FAILED", (function() {
            return s
        })), n.d(t, "CONFERENCE_JOINED", (function() {
            return c
        })), n.d(t, "CONFERENCE_LEFT", (function() {
            return u
        })), n.d(t, "CONNECTION_ESTABLISHED", (function() {
            return l
        })), n.d(t, "CONNECTION_INTERRUPTED", (function() {
            return d
        })), n.d(t, "CONNECTION_RESTORED", (function() {
            return p
        })), n.d(t, "DATA_CHANNEL_OPENED", (function() {
            return h
        })), n.d(t, "DISPLAY_NAME_CHANGED", (function() {
            return f
        })), n.d(t, "DOMINANT_SPEAKER_CHANGED", (function() {
            return m
        })), n.d(t, "DTMF_SUPPORT_CHANGED", (function() {
            return v
        })), n.d(t, "ENDPOINT_MESSAGE_RECEIVED", (function() {
            return y
        })), n.d(t, "JVB121_STATUS", (function() {
            return g
        })), n.d(t, "KICKED", (function() {
            return _
        })), n.d(t, "PARTICIPANT_KICKED", (function() {
            return S
        })), n.d(t, "LAST_N_ENDPOINTS_CHANGED", (function() {
            return b
        })), n.d(t, "LOCK_STATE_CHANGED", (function() {
            return E
        })), n.d(t, "SERVER_REGION_CHANGED", (function() {
            return T
        })), n.d(t, "MESSAGE_RECEIVED", (function() {
            return C
        })), n.d(t, "PRIVATE_MESSAGE_RECEIVED", (function() {
            return R
        })), n.d(t, "PARTICIPANT_CONN_STATUS_CHANGED", (function() {
            return A
        })), n.d(t, "PARTCIPANT_FEATURES_CHANGED", (function() {
            return w
        })), n.d(t, "PARTICIPANT_PROPERTY_CHANGED", (function() {
            return k
        })), n.d(t, "P2P_STATUS", (function() {
            return O
        })), n.d(t, "PHONE_NUMBER_CHANGED", (function() {
            return I
        })), n.d(t, "PROPERTIES_CHANGED", (function() {
            return P
        })), n.d(t, "RECORDER_STATE_CHANGED", (function() {
            return D
        })), n.d(t, "VIDEO_SIP_GW_AVAILABILITY_CHANGED", (function() {
            return N
        })), n.d(t, "VIDEO_SIP_GW_SESSION_STATE_CHANGED", (function() {
            return L
        })), n.d(t, "START_MUTED_POLICY_CHANGED", (function() {
            return M
        })), n.d(t, "STARTED_MUTED", (function() {
            return x
        })), n.d(t, "SUBJECT_CHANGED", (function() {
            return j
        })), n.d(t, "SUSPEND_DETECTED", (function() {
            return F
        })), n.d(t, "TALK_WHILE_MUTED", (function() {
            return U
        })), n.d(t, "TRACK_ADDED", (function() {
            return H
        })), n.d(t, "TRACK_AUDIO_LEVEL_CHANGED", (function() {
            return J
        })), n.d(t, "TRACK_MUTE_CHANGED", (function() {
            return G
        })), n.d(t, "TRACK_REMOVED", (function() {
            return B
        })), n.d(t, "TRANSCRIPTION_STATUS_CHANGED", (function() {
            return V
        })), n.d(t, "USER_JOINED", (function() {
            return q
        })), n.d(t, "USER_LEFT", (function() {
            return K
        })), n.d(t, "USER_ROLE_CHANGED", (function() {
            return W
        })), n.d(t, "USER_STATUS_CHANGED", (function() {
            return z
        })), n.d(t, "BOT_TYPE_CHANGED", (function() {
            return $
        }));
        var r = "conference.auth_status_changed",
            i = "conference.avatarChanged",
            o = "conference.beforeStatisticsDisposed",
            a = "conference.error",
            s = "conference.failed",
            c = "conference.joined",
            u = "conference.left",
            l = "conference.connectionEstablished",
            d = "conference.connectionInterrupted",
            p = "conference.connectionRestored",
            h = "conference.dataChannelOpened",
            f = "conference.displayNameChanged",
            m = "conference.dominantSpeaker",
            v = "conference.dtmfSupportChanged",
            y = "conference.endpoint_message_received",
            g = "conference.jvb121Status",
            _ = "conference.kicked",
            S = "conference.participant_kicked",
            b = "conference.lastNEndpointsChanged",
            E = "conference.lock_state_changed",
            T = "conference.server_region_changed",
            C = "conference.messageReceived",
            R = "conference.privateMessageReceived",
            A = "conference.participant_conn_status_changed",
            w = "conference.partcipant_features_changed",
            k = "conference.participant_property_changed",
            O = "conference.p2pStatus",
            I = "conference.phoneNumberChanged",
            P = "conference.propertiesChanged",
            D = "conference.recorderStateChanged",
            N = "conference.videoSIPGWAvailabilityChanged",
            L = "conference.videoSIPGWSessionStateChanged",
            M = "conference.start_muted_policy_changed",
            x = "conference.started_muted",
            j = "conference.subjectChanged",
            F = "conference.suspendDetected",
            U = "conference.talk_while_muted",
            H = "conference.trackAdded",
            J = "conference.audioLevelsChanged",
            G = "conference.trackMuteChanged",
            B = "conference.trackRemoved",
            V = "conference.transcriptionStatusChanged",
            q = "conference.userJoined",
            K = "conference.userLeft",
            W = "conference.roleChanged",
            z = "conference.statusChanged",
            $ = "conference.bot_type_changed"
    }, function(e, t, n) {
        "use strict";
        var r = n(72);
        t.a = new r.a
    }, function(e, t, n) {
        var r = n(60),
            i = n(120),
            o = {},
            a = [],
            s = r.levels.TRACE;
        e.exports = {
            addGlobalTransport: function(e) {
                r.addGlobalTransport(e)
            },
            removeGlobalTransport: function(e) {
                r.removeGlobalTransport(e)
            },
            setGlobalOptions: function(e) {
                r.setGlobalOptions(e)
            },
            getLogger: function(e, t, n) {
                var i = new r(s, e, t, n);
                return e ? (o[e] = o[e] || [], o[e].push(i)) : a.push(i), i
            },
            setLogLevelById: function(e, t) {
                for (var n = t ? o[t] || [] : a, r = 0; r < n.length; r++) n[r].setLevel(e)
            },
            setLogLevel: function(e) {
                s = e;
                for (var t = 0; t < a.length; t++) a[t].setLevel(e);
                for (var n in o) {
                    var r = o[n] || [];
                    for (t = 0; t < r.length; t++) r[t].setLevel(e)
                }
            },
            levels: r.levels,
            LogCollector: i
        }
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return S
            }));
            var r = n(28),
                i = n.n(r),
                o = n(7),
                a = n(71),
                s = n(31),
                c = n(50),
                u = n(74),
                l = n(3),
                d = n(51),
                p = n.n(d),
                h = n(15),
                f = n(23);

            function m(e) {
                return (m = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                    return typeof e
                } : function(e) {
                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                })(e)
            }
            var v, y = n(4).getLogger(e),
                g = !1;

            function _(e) {
                s.a.isBackendInitialized() || s.a.initBackend({
                    callStatsID: e.callStatsID,
                    callStatsSecret: e.callStatsSecret,
                    userName: e.userName,
                    aliasName: e.aliasName,
                    applicationName: e.applicationName,
                    getWiFiStatsMethod: e.getWiFiStatsMethod,
                    confID: e.confID
                }) || y.error("CallStats Backend initialization failed bad")
            }

            function S(e, t) {
                this.rtpStatsMap = new Map, this.eventEmitter = new i.a, this.xmpp = e, this.options = t || {}, this.callStatsIntegrationEnabled = this.options.callStatsID && this.options.callStatsSecret && !0 !== S.disableThirdPartyRequests, this.callStatsIntegrationEnabled && (l.a.isReactNative() ? _(this.options) : function(e) {
                    g || (p.a.loadScript(e.customScriptUrl || "https://api.callstats.io/static/callstats-ws.min.js", !0, !0, void 0, (function() {
                        return _(e)
                    })), g = !0)
                }(this.options), this.options.confID || y.warn('"confID" is not defined'), this.options.callStatsConfIDNamespace || y.warn('"callStatsConfIDNamespace" is not defined')), this.callsStatsInstances = new Map, S.instances.add(this)
            }
            S.init = function(e) {
                S.audioLevelsEnabled = !e.disableAudioLevels, "number" == typeof e.audioLevelsInterval && (S.audioLevelsInterval = e.audioLevelsInterval), S.disableThirdPartyRequests = e.disableThirdPartyRequests
            }, S.audioLevelsEnabled = !1, S.audioLevelsInterval = 200, S.disableThirdPartyRequests = !1, S.analytics = a.a, Object.defineProperty(S, "instances", {
                get: function() {
                    return v || (v = new Set), v
                }
            }), S.prototype.startRemoteStats = function(e) {
                this.stopRemoteStats(e);
                try {
                    var t = new u.a(e, S.audioLevelsInterval, 2e3, this.eventEmitter);
                    t.start(S.audioLevelsEnabled), this.rtpStatsMap.set(e.id, t)
                } catch (e) {
                    y.error("Failed to start collecting remote statistics: ".concat(e))
                }
            }, S.localStats = [], S.startLocalStats = function(e, t) {
                if (S.audioLevelsEnabled) {
                    var n = new c.a(e, S.audioLevelsInterval, t);
                    this.localStats.push(n), n.start()
                }
            }, S.prototype.addAudioLevelListener = function(e) {
                S.audioLevelsEnabled && this.eventEmitter.on(f.a, e)
            }, S.prototype.removeAudioLevelListener = function(e) {
                S.audioLevelsEnabled && this.eventEmitter.removeListener(f.a, e)
            }, S.prototype.addBeforeDisposedListener = function(e) {
                this.eventEmitter.on(f.b, e)
            }, S.prototype.removeBeforeDisposedListener = function(e) {
                this.eventEmitter.removeListener(f.b, e)
            }, S.prototype.addConnectionStatsListener = function(e) {
                this.eventEmitter.on(f.d, e)
            }, S.prototype.removeConnectionStatsListener = function(e) {
                this.eventEmitter.removeListener(f.d, e)
            }, S.prototype.addByteSentStatsListener = function(e) {
                this.eventEmitter.on(f.c, e)
            }, S.prototype.removeByteSentStatsListener = function(e) {
                this.eventEmitter.removeListener(f.c, e)
            }, S.prototype.dispose = function() {
                try {
                    this.callsStatsInstances.size || this.eventEmitter.emit(f.b);
                    var e = !0,
                        t = !1,
                        n = void 0;
                    try {
                        for (var r, i = this.callsStatsInstances.values()[Symbol.iterator](); !(e = (r = i.next()).done); e = !0) {
                            var o = r.value;
                            this.stopCallStats(o.tpc)
                        }
                    } catch (e) {
                        t = !0, n = e
                    } finally {
                        try {
                            e || null == i.return || i.return()
                        } finally {
                            if (t) throw n
                        }
                    }
                    var a = !0,
                        s = !1,
                        c = void 0;
                    try {
                        for (var u, l = this.rtpStatsMap.keys()[Symbol.iterator](); !(a = (u = l.next()).done); a = !0) {
                            var d = u.value;
                            this._stopRemoteStats(d)
                        }
                    } catch (e) {
                        s = !0, c = e
                    } finally {
                        try {
                            a || null == l.return || l.return()
                        } finally {
                            if (s) throw c
                        }
                    }
                    this.eventEmitter && this.eventEmitter.removeAllListeners()
                } finally {
                    S.instances.delete(this)
                }
            }, S.stopLocalStats = function(e) {
                if (S.audioLevelsEnabled)
                    for (var t = 0; t < S.localStats.length; t++)
                        if (S.localStats[t].stream === e) {
                            S.localStats.splice(t, 1)[0].stop();
                            break
                        }
            }, S.prototype._stopRemoteStats = function(e) {
                var t = this.rtpStatsMap.get(e);
                t && (t.stop(), this.rtpStatsMap.delete(e))
            }, S.prototype.stopRemoteStats = function(e) {
                this._stopRemoteStats(e.id)
            }, S.prototype.startCallStats = function(e, t) {
                if (this.callStatsIntegrationEnabled)
                    if (this.callsStatsInstances.has(e.id)) y.error("CallStats instance for ${tpc} exists already");
                    else {
                        y.info("Starting CallStats for ".concat(e, "..."));
                        var n = new s.a(e, {
                            confID: this._getCallStatsConfID(),
                            remoteUserID: t
                        });
                        this.callsStatsInstances.set(e.id, n)
                    }
            }, S._getAllCallStatsInstances = function() {
                var e = new Set,
                    t = !0,
                    n = !1,
                    r = void 0;
                try {
                    for (var i, o = S.instances[Symbol.iterator](); !(t = (i = o.next()).done); t = !0) {
                        var a = i.value,
                            s = !0,
                            c = !1,
                            u = void 0;
                        try {
                            for (var l, d = a.callsStatsInstances.values()[Symbol.iterator](); !(s = (l = d.next()).done); s = !0) {
                                var p = l.value;
                                e.add(p)
                            }
                        } catch (e) {
                            c = !0, u = e
                        } finally {
                            try {
                                s || null == d.return || d.return()
                            } finally {
                                if (c) throw u
                            }
                        }
                    }
                } catch (e) {
                    n = !0, r = e
                } finally {
                    try {
                        t || null == o.return || o.return()
                    } finally {
                        if (n) throw r
                    }
                }
                return e
            }, S.prototype._getCallStatsConfID = function() {
                return this.options.callStatsConfIDNamespace ? "".concat(this.options.callStatsConfIDNamespace, "/").concat(this.options.roomName) : this.options.roomName
            }, S.prototype.stopCallStats = function(e) {
                var t = this.callsStatsInstances.get(e.id);
                t && (1 === this.callsStatsInstances.size && this.eventEmitter.emit(f.b), this.callsStatsInstances.delete(e.id), t.sendTerminateEvent())
            }, S.prototype.isCallstatsEnabled = function() {
                return this.callStatsIntegrationEnabled
            }, S.prototype.sendConnectionResumeOrHoldEvent = function(e, t) {
                var n = this.callsStatsInstances.get(e.id);
                n && n.sendResumeOrHoldEvent(t)
            }, S.prototype.sendIceConnectionFailedEvent = function(e) {
                var t = this.callsStatsInstances.get(e.id);
                t && t.sendIceConnectionFailedEvent()
            }, S.prototype.sendMuteEvent = function(e, t, n) {
                var r = e && this.callsStatsInstances.get(e.id);
                s.a.sendMuteEvent(t, n, r)
            }, S.prototype.sendScreenSharingEvent = function(e, t) {
                var n = !0,
                    r = !1,
                    i = void 0;
                try {
                    for (var o, a = this.callsStatsInstances.values()[Symbol.iterator](); !(n = (o = a.next()).done); n = !0) {
                        o.value.sendScreenSharingEvent(e, t)
                    }
                } catch (e) {
                    r = !0, i = e
                } finally {
                    try {
                        n || null == a.return || a.return()
                    } finally {
                        if (r) throw i
                    }
                }
            }, S.prototype.sendDominantSpeakerEvent = function(e) {
                var t = !0,
                    n = !1,
                    r = void 0;
                try {
                    for (var i, o = this.callsStatsInstances.values()[Symbol.iterator](); !(t = (i = o.next()).done); t = !0) {
                        i.value.sendDominantSpeakerEvent()
                    }
                } catch (e) {
                    n = !0, r = e
                } finally {
                    try {
                        t || null == o.return || o.return()
                    } finally {
                        if (n) throw r
                    }
                }
                this.xmpp.sendDominantSpeakerEvent(e)
            }, S.sendActiveDeviceListEvent = function(e) {
                var t = S._getAllCallStatsInstances();
                if (t.size) {
                    var n = !0,
                        r = !1,
                        i = void 0;
                    try {
                        for (var o, a = t[Symbol.iterator](); !(n = (o = a.next()).done); n = !0) {
                            var c = o.value;
                            s.a.sendActiveDeviceListEvent(e, c)
                        }
                    } catch (e) {
                        r = !0, i = e
                    } finally {
                        try {
                            n || null == a.return || a.return()
                        } finally {
                            if (r) throw i
                        }
                    }
                } else s.a.sendActiveDeviceListEvent(e, null)
            }, S.prototype.associateStreamWithVideoTag = function(e, t, n, r, i, o) {
                var a = this.callsStatsInstances.get(e.id);
                a && a.associateStreamWithVideoTag(t, n, r, i, o)
            }, S.sendGetUserMediaFailed = function(e) {
                var t = e instanceof h.a ? function(e) {
                        var t = new Error;
                        return t.stack = e.stack, t.name = (e.name || "Unknown error") + (e.gum && e.gum.error && e.gum.error.name ? " - ".concat(e.gum.error.name) : ""), t.constraintName = e.gum && e.gum.constraints ? JSON.stringify(e.gum.constraints) : "", t.message = e.message, t
                    }(e) : e,
                    n = S._getAllCallStatsInstances();
                if (n.size) {
                    var r = !0,
                        i = !1,
                        o = void 0;
                    try {
                        for (var a, c = n[Symbol.iterator](); !(r = (a = c.next()).done); r = !0) {
                            var u = a.value;
                            s.a.sendGetUserMediaFailed(t, u)
                        }
                    } catch (e) {
                        i = !0, o = e
                    } finally {
                        try {
                            r || null == c.return || c.return()
                        } finally {
                            if (i) throw o
                        }
                    }
                } else s.a.sendGetUserMediaFailed(t, null)
            }, S.prototype.sendCreateOfferFailed = function(e, t) {
                var n = this.callsStatsInstances.get(t.id);
                n && n.sendCreateOfferFailed(e)
            }, S.prototype.sendCreateAnswerFailed = function(e, t) {
                var n = this.callsStatsInstances.get(t.id);
                n && n.sendCreateAnswerFailed(e)
            }, S.prototype.sendSetLocalDescFailed = function(e, t) {
                var n = this.callsStatsInstances.get(t.id);
                n && n.sendSetLocalDescFailed(e)
            }, S.prototype.sendSetRemoteDescFailed = function(e, t) {
                var n = this.callsStatsInstances.get(t.id);
                n && n.sendSetRemoteDescFailed(e)
            }, S.prototype.sendAddIceCandidateFailed = function(e, t) {
                var n = this.callsStatsInstances.get(t.id);
                n && n.sendAddIceCandidateFailed(e)
            }, S.sendLog = function(e) {
                var t = new Set,
                    n = !0,
                    r = !1,
                    i = void 0;
                try {
                    for (var o, a = S.instances[Symbol.iterator](); !(n = (o = a.next()).done); n = !0) {
                        var c = o.value;
                        c.callsStatsInstances.size && t.add(c.callsStatsInstances.values().next().value)
                    }
                } catch (e) {
                    r = !0, i = e
                } finally {
                    try {
                        n || null == a.return || a.return()
                    } finally {
                        if (r) throw i
                    }
                }
                if (t.size) {
                    var u = !0,
                        l = !1,
                        d = void 0;
                    try {
                        for (var p, h = t[Symbol.iterator](); !(u = (p = h.next()).done); u = !0) {
                            var f = p.value;
                            s.a.sendApplicationLog(e, f)
                        }
                    } catch (e) {
                        l = !0, d = e
                    } finally {
                        try {
                            u || null == h.return || h.return()
                        } finally {
                            if (l) throw d
                        }
                    }
                } else s.a.sendApplicationLog(e, null)
            }, S.prototype.sendFeedback = function(e, t) {
                return S.analytics.sendEvent(o.n, {
                    rating: e,
                    comment: t
                }), s.a.sendFeedback(this._getCallStatsConfID(), e, t)
            }, S.LOCAL_JID = n(124).LOCAL_JID, S.reportGlobalError = function(e) {
                e instanceof h.a && e.gum ? S.sendGetUserMediaFailed(e) : S.sendLog(e)
            }, S.sendAnalyticsAndLog = function(e) {
                var t, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                e ? (t = "object" === m(e) ? e : {
                    name: e,
                    properties: n
                }, y.log(JSON.stringify(t)), this.analytics.sendEvent(e, n)) : y.warn("No event or event name given.")
            }, S.sendAnalytics = function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                this.analytics.sendEvent(e, t)
            }
        }).call(this, "modules/statistics/statistics.js")
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            var r = n(4),
                i = n(33),
                o = n.n(i),
                a = n(3);

            function s(e) {
                return function(e) {
                    if (Array.isArray(e)) {
                        for (var t = 0, n = new Array(e.length); t < e.length; t++) n[t] = e[t];
                        return n
                    }
                }(e) || function(e) {
                    if (Symbol.iterator in Object(e) || "[object Arguments]" === Object.prototype.toString.call(e)) return Array.from(e)
                }(e) || function() {
                    throw new TypeError("Invalid attempt to spread non-iterable instance")
                }()
            }
            var c = Object(r.getLogger)(e),
                u = {
                    filterSpecialChars: function(e) {
                        return e ? e.replace(/[\\\/\{,\}\+]/g, "") : e
                    },
                    iceparams: function(e, t) {
                        var n, r, i = null;
                        return (r = u.findLine(e, "a=ice-ufrag:", t)) && (n = u.findLine(e, "a=ice-pwd:", t)) && (i = {
                            ufrag: u.parseICEUfrag(r),
                            pwd: u.parseICEPwd(n)
                        }), i
                    },
                    parseICEUfrag: function(e) {
                        return e.substring(12)
                    },
                    buildICEUfrag: function(e) {
                        return "a=ice-ufrag:".concat(e)
                    },
                    parseICEPwd: function(e) {
                        return e.substring(10)
                    },
                    buildICEPwd: function(e) {
                        return "a=ice-pwd:".concat(e)
                    },
                    parseMID: function(e) {
                        return e.substring(6)
                    },
                    parseMLine: function(e) {
                        var t = {},
                            n = e.substring(2).split(" ");
                        return t.media = n.shift(), t.port = n.shift(), t.proto = n.shift(), "" === n[n.length - 1] && n.pop(), t.fmt = n, t
                    },
                    buildMLine: function(e) {
                        return "m=".concat(e.media, " ").concat(e.port, " ").concat(e.proto, " ").concat(e.fmt.join(" "))
                    },
                    parseRTPMap: function(e) {
                        var t = {},
                            n = e.substring(9).split(" ");
                        return t.id = n.shift(), n = n[0].split("/"), t.name = n.shift(), t.clockrate = n.shift(), t.channels = n.length ? n.shift() : "1", t
                    },
                    parseSCTPMap: function(e) {
                        var t = e.substring(10).split(" ");
                        return [t[0], t[1], t.length > 2 ? t[2] : null]
                    },
                    buildRTPMap: function(e) {
                        var t = "a=rtpmap:".concat(e.getAttribute("id"), " ").concat(e.getAttribute("name"), "/").concat(e.getAttribute("clockrate"));
                        return e.getAttribute("channels") && "1" !== e.getAttribute("channels") && (t += "/".concat(e.getAttribute("channels"))), t
                    },
                    parseCrypto: function(e) {
                        var t = {},
                            n = e.substring(9).split(" ");
                        return t.tag = n.shift(), t["crypto-suite"] = n.shift(), t["key-params"] = n.shift(), n.length && (t["session-params"] = n.join(" ")), t
                    },
                    parseFingerprint: function(e) {
                        var t = {},
                            n = e.substring(14).split(" ");
                        return t.hash = n.shift(), t.fingerprint = n.shift(), t
                    },
                    parseFmtp: function(e) {
                        var t = [],
                            n = e.split(" ");
                        n.shift(), n = n.join(" ").split(";");
                        for (var r = 0; r < n.length; r++) {
                            for (var i = n[r].split("=")[0]; i.length && " " === i[0];) i = i.substring(1);
                            var o = n[r].split("=")[1];
                            i && o ? t.push({
                                name: i,
                                value: o
                            }) : i && t.push({
                                name: "",
                                value: i
                            })
                        }
                        return t
                    },
                    parseICECandidate: function(e) {
                        var t = {},
                            n = e.split(" ");
                        t.foundation = n[0].substring(12), t.component = n[1], t.protocol = n[2].toLowerCase(), t.priority = n[3], t.ip = n[4], t.port = n[5], t.type = n[7], t.generation = 0;
                        for (var r = 8; r < n.length; r += 2) switch (n[r]) {
                            case "raddr":
                                t["rel-addr"] = n[r + 1];
                                break;
                            case "rport":
                                t["rel-port"] = n[r + 1];
                                break;
                            case "generation":
                                t.generation = n[r + 1];
                                break;
                            case "tcptype":
                                t.tcptype = n[r + 1];
                                break;
                            default:
                                c.log('parseICECandidate not translating "'.concat(n[r], '" = "').concat(n[r + 1], '"'))
                        }
                        return t.network = "1", t.id = Math.random().toString(36).substr(2, 10), t
                    },
                    buildICECandidate: function(e) {
                        var t = ["a=candidate:".concat(e.foundation), e.component, e.protocol, e.priority, e.ip, e.port, "typ", e.type].join(" ");
                        switch (t += " ", e.type) {
                            case "srflx":
                            case "prflx":
                            case "relay":
                                e.hasOwnAttribute("rel-addr") && e.hasOwnAttribute("rel-port") && (t += "raddr", t += " ", t += e["rel-addr"], t += " ", t += "rport", t += " ", t += e["rel-port"], t += " ")
                        }
                        return e.hasOwnAttribute("tcptype") && (t += "tcptype", t += " ", t += e.tcptype, t += " "), t += "generation", t += " ", t += e.hasOwnAttribute("generation") ? e.generation : "0"
                    },
                    parseSSRC: function(e) {
                        for (var t = new Map, n = e.split("\r\n"), r = 0; r < n.length; r++)
                            if ("a=ssrc:" === n[r].substring(0, 7)) {
                                var i = n[r].split("a=ssrc:")[1].split(" ")[0];
                                t.get(i) || t.set(i, []), t.get(i).push(n[r])
                            } return t
                    },
                    parseRTCPFB: function(e) {
                        var t = e.substr(10).split(" "),
                            n = {};
                        return n.pt = t.shift(), n.type = t.shift(), n.params = t, n
                    },
                    parseExtmap: function(e) {
                        var t = e.substr(9).split(" "),
                            n = {};
                        return n.value = t.shift(), -1 === n.value.indexOf("/") ? n.direction = "both" : (n.direction = n.value.substr(n.value.indexOf("/") + 1), n.value = n.value.substr(0, n.value.indexOf("/"))), n.uri = t.shift(), n.params = t, n
                    },
                    findLine: function(e, t, n) {
                        for (var r = e.split("\r\n"), i = 0; i < r.length; i++)
                            if (r[i].substring(0, t.length) === t) return r[i];
                        if (!n) return !1;
                        r = n.split("\r\n");
                        for (var o = 0; o < r.length; o++)
                            if (r[o].substring(0, t.length) === t) return r[o];
                        return !1
                    },
                    findLines: function(e, t, n) {
                        for (var r = e.split("\r\n"), i = [], o = 0; o < r.length; o++) r[o].substring(0, t.length) === t && i.push(r[o]);
                        if (i.length || !n) return i;
                        r = n.split("\r\n");
                        for (var a = 0; a < r.length; a++) r[a].substring(0, t.length) === t && i.push(r[a]);
                        return i
                    },
                    candidateToJingle: function(e) {
                        if (0 === e.indexOf("candidate:")) e = "a=".concat(e);
                        else if ("a=candidate:" !== e.substring(0, 12)) return c.log("parseCandidate called with a line that is not a candidate line"), c.log(e), null;
                        "\r\n" === e.substring(e.length - 2) && (e = e.substring(0, e.length - 2));
                        var t = {},
                            n = e.split(" ");
                        if ("typ" !== n[6]) return c.log("did not find typ in the right place"), c.log(e), null;
                        t.foundation = n[0].substring(12), t.component = n[1], t.protocol = n[2].toLowerCase(), t.priority = n[3], t.ip = n[4], t.port = n[5], t.type = n[7], t.generation = "0";
                        for (var r = 8; r < n.length; r += 2) switch (n[r]) {
                            case "raddr":
                                t["rel-addr"] = n[r + 1];
                                break;
                            case "rport":
                                t["rel-port"] = n[r + 1];
                                break;
                            case "generation":
                                t.generation = n[r + 1];
                                break;
                            case "tcptype":
                                t.tcptype = n[r + 1];
                                break;
                            default:
                                c.log('not translating "'.concat(n[r], '" = "').concat(n[r + 1], '"'))
                        }
                        return t.network = "1", t.id = Math.random().toString(36).substr(2, 10), t
                    },
                    candidateFromJingle: function(e) {
                        var t = "a=candidate:";
                        t += e.getAttribute("foundation"), t += " ", t += e.getAttribute("component"), t += " ";
                        var n = e.getAttribute("protocol");
                        switch (a.a.isFirefox() && "ssltcp" === n.toLowerCase() && (n = "tcp"), t += n, t += " ", t += e.getAttribute("priority"), t += " ", t += e.getAttribute("ip"), t += " ", t += e.getAttribute("port"), t += " ", t += "typ", t += " ".concat(e.getAttribute("type")), t += " ", e.getAttribute("type")) {
                            case "srflx":
                            case "prflx":
                            case "relay":
                                e.getAttribute("rel-addr") && e.getAttribute("rel-port") && (t += "raddr", t += " ", t += e.getAttribute("rel-addr"), t += " ", t += "rport", t += " ", t += e.getAttribute("rel-port"), t += " ")
                        }
                        return "tcp" === n.toLowerCase() && (t += "tcptype", t += " ", t += e.getAttribute("tcptype"), t += " "), t += "generation", t += " ", t += e.getAttribute("generation") || "0", "".concat(t, "\r\n")
                    },
                    parsePrimaryVideoSsrc: function(e) {
                        var t = e.ssrcs.map((function(e) {
                                return e.id
                            })).filter((function(e, t, n) {
                                return n.indexOf(e) === t
                            })).length,
                            n = e.ssrcGroups && e.ssrcGroups.length || 0;
                        if (!(t > 1 && 0 === n)) {
                            var r = null;
                            if (1 === t) r = e.ssrcs[0].id;
                            else if (2 === t) {
                                var i = e.ssrcGroups.find((function(e) {
                                    return "FID" === e.semantics
                                }));
                                i && (r = i.ssrcs.split(" ")[0])
                            } else if (t >= 3) {
                                var o = e.ssrcGroups.find((function(e) {
                                    return "SIM" === e.semantics
                                }));
                                o && (r = o.ssrcs.split(" ")[0])
                            }
                            return r
                        }
                    },
                    generateSsrc: function() {
                        return o.a.randomInt(1, 4294967295)
                    },
                    getSsrcAttribute: function(e, t, n) {
                        for (var r = 0; r < e.ssrcs.length; ++r) {
                            var i = e.ssrcs[r];
                            if (i.id === t && i.attribute === n) return i.value
                        }
                    },
                    parseGroupSsrcs: function(e) {
                        return e.ssrcs.split(" ").map((function(e) {
                            return parseInt(e, 10)
                        }))
                    },
                    getMedia: function(e, t) {
                        return e.media.find((function(e) {
                            return e.type === t
                        }))
                    },
                    getUfrag: function(e) {
                        var t = e.split("\n").filter((function(e) {
                            return e.startsWith("a=ice-ufrag:")
                        }));
                        if (t.length > 0) return t[0].substr("a=ice-ufrag:".length)
                    },
                    preferVideoCodec: function(e, t) {
                        var n = null;
                        if (e && t) {
                            for (var r = 0; r < e.rtp.length; ++r) {
                                var i = e.rtp[r];
                                if (i.codec && i.codec.toLowerCase() === t.toLowerCase()) {
                                    n = i.payload;
                                    break
                                }
                            }
                            if (n) {
                                var o = e.payloads.toString().split(" ").map((function(e) {
                                        return parseInt(e, 10)
                                    })),
                                    a = o.indexOf(n);
                                o.splice(a, 1), o.unshift(n), e.payloads = o.join(" ")
                            }
                        }
                    },
                    stripVideoCodec: function(e, t) {
                        if (e && t) {
                            var n = [],
                                r = !0,
                                i = !1,
                                o = void 0;
                            try {
                                for (var a, c = e.rtp[Symbol.iterator](); !(r = (a = c.next()).done); r = !0) {
                                    var u = a.value;
                                    u.codec && u.codec.toLowerCase() === t.toLowerCase() && n.push(u.payload)
                                }
                            } catch (e) {
                                i = !0, o = e
                            } finally {
                                try {
                                    r || null == c.return || c.return()
                                } finally {
                                    if (i) throw o
                                }
                            }
                            if (n.length > 0) {
                                var l = n.map((function(e) {
                                        return "apt=".concat(e)
                                    })),
                                    d = e.fmtp.filter((function(e) {
                                        return -1 !== l.indexOf(e.config)
                                    }));
                                n.push.apply(n, s(d.map((function(e) {
                                    return e.payload
                                }))));
                                var p = e.payloads.toString().split(" ").map(Number).filter((function(e) {
                                    return -1 === n.indexOf(e)
                                }));
                                0 === p.length ? (e.port = 0, e.direction = "inactive", e.payloads = "*") : e.payloads = p.join(" "), e.rtp = e.rtp.filter((function(e) {
                                    return -1 !== p.indexOf(e.payload)
                                })), e.fmtp = e.fmtp.filter((function(e) {
                                    return -1 !== p.indexOf(e.payload)
                                })), e.rtcpFb && (e.rtcpFb = e.rtcpFb.filter((function(e) {
                                    return -1 !== p.indexOf(e.payload)
                                })))
                            }
                        }
                    }
                };
            t.a = u
        }).call(this, "modules/xmpp/SDPUtil.js")
    }, function(e, t, n) {
        "use strict";

        function r(e) {
            for (var t = 1; t < arguments.length; t++) {
                var n = null != arguments[t] ? arguments[t] : {},
                    r = Object.keys(n);
                "function" == typeof Object.getOwnPropertySymbols && (r = r.concat(Object.getOwnPropertySymbols(n).filter((function(e) {
                    return Object.getOwnPropertyDescriptor(n, e).enumerable
                })))), r.forEach((function(t) {
                    i(e, t, n[t])
                }))
            }
            return e
        }

        function i(e, t, n) {
            return t in e ? Object.defineProperty(e, t, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : e[t] = n, e
        }
        n.d(t, "t", (function() {
            return o
        })), n.d(t, "u", (function() {
            return a
        })), n.d(t, "v", (function() {
            return s
        })), n.d(t, "w", (function() {
            return c
        })), n.d(t, "a", (function() {
            return u
        })), n.d(t, "b", (function() {
            return l
        })), n.d(t, "c", (function() {
            return d
        })), n.d(t, "d", (function() {
            return p
        })), n.d(t, "e", (function() {
            return h
        })), n.d(t, "f", (function() {
            return f
        })), n.d(t, "g", (function() {
            return m
        })), n.d(t, "h", (function() {
            return v
        })), n.d(t, "i", (function() {
            return y
        })), n.d(t, "j", (function() {
            return g
        })), n.d(t, "k", (function() {
            return _
        })), n.d(t, "l", (function() {
            return S
        })), n.d(t, "m", (function() {
            return b
        })), n.d(t, "n", (function() {
            return E
        })), n.d(t, "o", (function() {
            return T
        })), n.d(t, "p", (function() {
            return C
        })), n.d(t, "q", (function() {
            return R
        })), n.d(t, "r", (function() {
            return A
        })), n.d(t, "s", (function() {
            return w
        })), n.d(t, "z", (function() {
            return k
        })), n.d(t, "A", (function() {
            return O
        })), n.d(t, "B", (function() {
            return I
        })), n.d(t, "C", (function() {
            return P
        })), n.d(t, "D", (function() {
            return D
        })), n.d(t, "E", (function() {
            return N
        })), n.d(t, "I", (function() {
            return L
        })), n.d(t, "F", (function() {
            return M
        })), n.d(t, "G", (function() {
            return x
        })), n.d(t, "H", (function() {
            return j
        })), n.d(t, "J", (function() {
            return F
        })), n.d(t, "K", (function() {
            return U
        })), n.d(t, "L", (function() {
            return H
        })), n.d(t, "x", (function() {
            return J
        })), n.d(t, "y", (function() {
            return G
        })), n.d(t, "M", (function() {
            return B
        }));
        var o = "operational",
            a = "page",
            s = "track",
            c = "ui",
            u = "restart",
            l = "session-accept.timeout",
            d = "session-initiate.received",
            p = "session-initiate.timeout",
            h = "terminate",
            f = "transport-replace.received",
            m = "transport-replace.success",
            v = "decline",
            y = "established",
            g = "failed",
            _ = "switch.to.jvb",
            S = "available.device",
            b = "connection.disconnected",
            E = "feedback",
            T = "ice.duration",
            C = "ice.establishment.duration.diff",
            R = "ice.state.changed",
            A = "track.no-bytes-sent",
            w = "track.unmuted",
            k = function() {
                return {
                    action: "bridge.down",
                    actionSubject: "bridge.down",
                    type: o
                }
            },
            O = function(e, t, n) {
                return {
                    type: o,
                    action: "connection.failed",
                    attributes: r({
                        error_type: e,
                        error_message: t
                    }, n)
                }
            },
            I = function(e, t) {
                var n = "connection.stage.reached";
                return {
                    action: n,
                    actionSubject: e,
                    attributes: t,
                    source: n,
                    type: o
                }
            },
            P = function(e, t, n) {
                return {
                    attributes: {
                        participant_id: e,
                        region: t,
                        rtt: n
                    },
                    name: "e2e_rtt",
                    type: o
                }
            },
            D = function() {
                return {
                    action: "focus.left",
                    actionSubject: "focus.left",
                    type: o
                }
            },
            N = function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                return {
                    type: o,
                    source: "get.user.media",
                    action: e,
                    attributes: t
                }
            },
            L = function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                    t = "duration";
                return {
                    type: o,
                    source: "peer.conn.status",
                    action: t,
                    attributes: e
                }
            },
            M = function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                return {
                    type: o,
                    action: e,
                    source: "jingle",
                    attributes: t
                }
            },
            x = function(e, t) {
                return {
                    attributes: {
                        media_type: e,
                        value: t
                    },
                    action: "track.no.data.from.source",
                    type: o
                }
            },
            j = function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                return {
                    type: o,
                    action: e,
                    source: "p2p",
                    attributes: t
                }
            },
            F = function() {
                return {
                    type: o,
                    action: "remotely.muted"
                }
            },
            U = function(e) {
                return {
                    type: o,
                    action: "rtp.stats",
                    attributes: e
                }
            },
            H = function(e) {
                return {
                    type: o,
                    action: "rtt.by.region",
                    attributes: e
                }
            };

        function J(e, t, n) {
            return {
                type: o,
                action: "audio.output.problem",
                attributes: {
                    userID: e,
                    localAudioLevels: t,
                    remoteAudioLevels: n
                }
            }
        }
        var G = function(e, t) {
                return {
                    type: o,
                    action: "bridge-channel.error",
                    attributes: {
                        code: e,
                        reason: t
                    }
                }
            },
            B = function(e) {
                return I("ttfm", e)
            }
    }, function(e, t) {
        e.exports = {
            CREATE_ANSWER_FAILED: "rtc.create_answer_failed",
            CREATE_OFFER_FAILED: "rtc.create_offer_failed",
            DATA_CHANNEL_OPEN: "rtc.data_channel_open",
            ENDPOINT_CONN_STATUS_CHANGED: "rtc.endpoint_conn_status_changed",
            DOMINANT_SPEAKER_CHANGED: "rtc.dominant_speaker_changed",
            LASTN_ENDPOINT_CHANGED: "rtc.lastn_endpoint_changed",
            GRANTED_PERMISSIONS: "rtc.granted_permissions",
            IS_SELECTED_CHANGED: "rtc.is_selected_change",
            LASTN_VALUE_CHANGED: "rtc.lastn_value_changed",
            LOCAL_TRACK_SSRC_UPDATED: "rtc.local_track_ssrc_updated",
            TRACK_ATTACHED: "rtc.track_attached",
            REMOTE_TRACK_ADDED: "rtc.remote_track_added",
            REMOTE_TRACK_MUTE: "rtc.remote_track_mute",
            REMOTE_TRACK_REMOVED: "rtc.remote_track_removed",
            REMOTE_TRACK_UNMUTE: "rtc.remote_track_unmute",
            SET_LOCAL_DESCRIPTION_FAILED: "rtc.set_local_description_failed",
            SET_REMOTE_DESCRIPTION_FAILED: "rtc.set_remote_description_failed",
            AUDIO_OUTPUT_DEVICE_CHANGED: "rtc.audio_output_device_changed",
            DEVICE_LIST_CHANGED: "rtc.device_list_changed",
            DEVICE_LIST_WILL_CHANGE: "rtc.device_list_will_change",
            DEVICE_LIST_AVAILABLE: "rtc.device_list_available",
            ENDPOINT_MESSAGE_RECEIVED: "rtc.endpoint_message_received",
            LOCAL_UFRAG_CHANGED: "rtc.local_ufrag_changed",
            REMOTE_UFRAG_CHANGED: "rtc.remote_ufrag_changed"
        }
    }, function(e, t, n) {
        "use strict";
        n.d(t, "a", (function() {
            return r
        })), n.d(t, "b", (function() {
            return i
        }));
        var r = "audio",
            i = "video"
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            var r = n(7),
                i = n(39),
                o = n.n(i),
                a = n(28),
                s = n.n(a),
                c = n(4),
                u = n(11),
                l = n.n(u),
                d = n(15),
                p = n(24),
                h = n(9),
                f = n(29),
                m = n.n(f),
                v = n(3),
                y = n(8),
                g = n.n(y),
                _ = n(40),
                S = n(6),
                b = n(5),
                E = n(14),
                T = n.n(E);

            function C(e) {
                return (C = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                    return typeof e
                } : function(e) {
                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                })(e)
            }

            function R(e, t) {
                for (var n = 0; n < t.length; n++) {
                    var r = t[n];
                    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                }
            }

            function A(e, t) {
                return !t || "object" !== C(t) && "function" != typeof t ? function(e) {
                    if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return e
                }(e) : t
            }

            function w(e) {
                return (w = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
                    return e.__proto__ || Object.getPrototypeOf(e)
                })(e)
            }

            function k(e, t) {
                return (k = Object.setPrototypeOf || function(e, t) {
                    return e.__proto__ = t, e
                })(e, t)
            }

            function O(e) {
                for (var t = 1; t < arguments.length; t++) {
                    var n = null != arguments[t] ? arguments[t] : {},
                        r = Object.keys(n);
                    "function" == typeof Object.getOwnPropertySymbols && (r = r.concat(Object.getOwnPropertySymbols(n).filter((function(e) {
                        return Object.getOwnPropertyDescriptor(n, e).enumerable
                    })))), r.forEach((function(t) {
                        I(e, t, n[t])
                    }))
                }
                return e
            }

            function I(e, t, n) {
                return t in e ? Object.defineProperty(e, t, {
                    value: n,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : e[t] = n, e
            }
            var P = Object(c.getLogger)(e);
            v.a.usesAdapter() && n(128);
            var D, N, L = new s.a,
                M = ["audio", "video"],
                x = {
                    video: {
                        aspectRatio: 16 / 9,
                        height: {
                            ideal: 720,
                            max: 720,
                            min: 240
                        }
                    }
                },
                j = 5,
                F = "default",
                U = !1,
                H = !1,
                J = !1,
                G = !1,
                B = !1,
                V = !1,
                q = document.createElement("audio"),
                K = void 0 !== q.setSinkId;

            function W() {
                if (navigator.mediaDevices && navigator.mediaDevices.enumerateDevices) return function(e) {
                    navigator.mediaDevices.enumerateDevices().then(e, (function() {
                        return e([])
                    }))
                }
            }

            function z(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                    n = {
                        audio: !1,
                        video: !1
                    },
                    r = v.a.isFirefox() || v.a.isSafariWithVP8() || v.a.isEdge() || v.a.isReactNative();
                if (e.indexOf("video") >= 0) {
                    if (n.video = {
                            mandatory: {},
                            optional: []
                        }, t.cameraDeviceId) r && (n.video.deviceId = t.cameraDeviceId), n.video.mandatory.sourceId = t.cameraDeviceId;
                    else {
                        var i = t.facingMode || o.a.USER;
                        r && (n.video.facingMode = i), n.video.optional.push({
                            facingMode: i
                        })
                    }(t.minFps || t.maxFps || t.fps) && ((t.minFps || t.fps) && (t.minFps = t.minFps || t.fps, n.video.mandatory.minFrameRate = t.minFps), t.maxFps && (n.video.mandatory.maxFrameRate = t.maxFps)),
                    function(e, t, n) {
                        m.a[n] && (t && (e.video.width = {
                            ideal: m.a[n].width
                        }, e.video.height = {
                            ideal: m.a[n].height
                        }), e.video.mandatory.minWidth = m.a[n].width, e.video.mandatory.minHeight = m.a[n].height), e.video.mandatory.minWidth && (e.video.mandatory.maxWidth = e.video.mandatory.minWidth), e.video.mandatory.minHeight && (e.video.mandatory.maxHeight = e.video.mandatory.minHeight)
                    }(n, r, t.resolution)
                }
                if (e.indexOf("audio") >= 0 && (v.a.isReactNative() ? n.audio = !0 : v.a.isFirefox() ? t.micDeviceId ? n.audio = {
                        mandatory: {},
                        deviceId: t.micDeviceId,
                        optional: [{
                            sourceId: t.micDeviceId
                        }]
                    } : n.audio = !0 : (n.audio = {
                        mandatory: {},
                        optional: []
                    }, t.micDeviceId && (r && (n.audio.deviceId = t.micDeviceId), n.audio.optional.push({
                        sourceId: t.micDeviceId
                    })), n.audio.optional.push({
                        echoCancellation: !J && !H
                    }, {
                        googEchoCancellation: !J && !H
                    }, {
                        googAutoGainControl: !B && !H
                    }, {
                        googNoiseSuppression: !G && !H
                    }, {
                        googHighpassFilter: !V && !H
                    }, {
                        googNoiseSuppression2: !G && !H
                    }, {
                        googEchoCancellation2: !J && !H
                    }, {
                        googAutoGainControl2: !B && !H
                    }))), e.indexOf("screen") >= 0)
                    if (v.a.isChrome()) n.video = {
                        mandatory: $(O({}, t, {
                            source: "screen"
                        })),
                        optional: []
                    };
                    else if (v.a.isFirefox()) n.video = {
                    mozMediaSource: "window",
                    mediaSource: "window",
                    frameRate: t.frameRate || {
                        min: j,
                        max: j
                    }
                };
                else {
                    var a = "'screen' WebRTC media source is supported only in Chrome and Firefox";
                    l.a.callErrorHandler(new Error(a)), P.error(a)
                }
                return e.indexOf("desktop") >= 0 && (n.video = {
                    mandatory: $(O({}, t, {
                        source: "desktop"
                    })),
                    optional: []
                }), t.bandwidth && (n.video || (n.video = {
                    mandatory: {},
                    optional: []
                }), n.video.optional.push({
                    bandwidth: t.bandwidth
                })), v.a.isFirefox() && t.firefox_fake_device && (n.fake = !0), n
            }

            function $() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                    t = e.desktopStream,
                    n = e.frameRate,
                    r = void 0 === n ? {
                        min: j,
                        max: j
                    } : n,
                    i = r.max,
                    o = r.min,
                    a = {
                        chromeMediaSource: e.source,
                        maxWidth: window.screen.width,
                        maxHeight: window.screen.height
                    };
                return "number" == typeof o && (a.minFrameRate = o), "number" == typeof i && (a.maxFrameRate = i), void 0 !== t && (a.chromeMediaSourceId = t), a
            }

            function X() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                    t = {
                        frameRate: j
                    },
                    n = e.desktopSharingFrameRate;
                return n && n.max && (t.frameRate = n.max), t
            }

            function Q(e, t) {
                var n = Boolean(t) && t.getAudioTracks().length > 0,
                    r = Boolean(t) && t.getVideoTracks().length > 0,
                    i = {}; - 1 !== e.indexOf("video") && (i.video = r), -1 !== e.indexOf("audio") && (i.audio = n), L.emit(g.a.GRANTED_PERMISSIONS, i)
            }

            function Y(e) {
                return e.length !== D.length || e.map(t).sort().join("") !== D.map(t).sort().join("");

                function t(e) {
                    return JSON.stringify({
                        kind: e.kind,
                        deviceId: e.deviceId,
                        groupId: e.groupId,
                        label: e.label,
                        facing: e.facing
                    })
                }
            }

            function Z(e) {
                var t = e.filter((function(e) {
                        return "audioinput" === e.kind
                    })).length,
                    n = e.filter((function(e) {
                        return "audiooutput" === e.kind
                    })).length,
                    i = e.filter((function(e) {
                        return "videoinput" === e.kind
                    })).length,
                    o = e.filter((function(e) {
                        return "videooutput" === e.kind
                    })).length;
                e.forEach((function(e) {
                    var a = {
                        audio_input_device_count: t,
                        audio_output_device_count: n,
                        video_input_device_count: i,
                        video_output_device_count: o,
                        device_id: e.deviceId,
                        device_group_id: e.groupId,
                        device_kind: e.kind,
                        device_label: e.label
                    };
                    b.a.sendAnalytics(r.l, a)
                }))
            }

            function ee(e) {
                D = e.slice(0), P.info("list of media devices has changed:", D), Z(D), L.emit(g.a.DEVICE_LIST_WILL_CHANGE, e), L.emit(g.a.DEVICE_LIST_CHANGED, e)
            }

            function te(e, t) {
                var n, r, i, o = [];
                if (e) {
                    var a = e.audioVideo;
                    if (a) {
                        var s = a.getAudioTracks();
                        if (s.length) {
                            n = new MediaStream;
                            for (var c = 0; c < s.length; c++) n.addTrack(s[c])
                        }
                        var u = a.getVideoTracks();
                        if (u.length) {
                            i = new MediaStream;
                            for (var l = 0; l < u.length; l++) i.addTrack(u[l])
                        }
                    } else n = e.audio, i = e.video;
                    r = e.desktop
                }
                if (r) {
                    var d = r,
                        p = d.stream,
                        f = d.sourceId,
                        m = d.sourceType;
                    o.push({
                        stream: p,
                        sourceId: f,
                        sourceType: m,
                        track: p.getVideoTracks()[0],
                        mediaType: h.b,
                        videoType: T.a.DESKTOP
                    })
                }
                return n && o.push({
                    stream: n,
                    track: n.getAudioTracks()[0],
                    mediaType: h.a,
                    videoType: null
                }), i && o.push({
                    stream: i,
                    track: i.getVideoTracks()[0],
                    mediaType: h.b,
                    videoType: T.a.CAMERA,
                    resolution: t
                }), o
            }

            function ne(e, t) {
                var n, r = "srcObject";
                (r in e || (r = "mozSrcObject") in e || (r = null), r) ? e[r] = t: (t && ((n = t.jitsiObjectURL) || (t.jitsiObjectURL = n = URL.createObjectURL(t))), e.src = n || "")
            }
            var re = new(function(e) {
                function t() {
                    return function(e, t) {
                        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                    }(this, t), A(this, w(t).call(this, L))
                }
                var n, r, i;
                return function(e, t) {
                    if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
                    e.prototype = Object.create(t && t.prototype, {
                        constructor: {
                            value: e,
                            writable: !0,
                            configurable: !0
                        }
                    }), t && k(e, t)
                }(t, e), n = t, (r = [{
                    key: "init",
                    value: function() {
                        var e = this,
                            t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                        if ("boolean" == typeof t.disableAEC && (J = t.disableAEC, P.info("Disable AEC: ".concat(J))), "boolean" == typeof t.disableNS && (G = t.disableNS, P.info("Disable NS: ".concat(G))), "boolean" == typeof t.disableAP && (H = t.disableAP, P.info("Disable AP: ".concat(H))), "boolean" == typeof t.disableAGC && (B = t.disableAGC, P.info("Disable AGC: ".concat(B))), "boolean" == typeof t.disableHPF && (V = t.disableHPF, P.info("Disable HPF: ".concat(V))), D = void 0, window.clearInterval(N), N = void 0, this.enumerateDevices = W(), v.a.usesNewGumFlow()) this.RTCPeerConnectionType = RTCPeerConnection, this.attachMediaStream = ie((function(e, t) {
                            e && (e.srcObject = t)
                        })), this.getStreamID = function(e) {
                            return e.id
                        }, this.getTrackID = function(e) {
                            return e.id
                        };
                        else {
                            if (!v.a.isChromiumBased() && !v.a.isReactNative()) {
                                var n = "Endpoint does not appear to be WebRTC-capable";
                                throw P.error(n), new Error(n)
                            }
                            this.RTCPeerConnectionType = RTCPeerConnection, this.attachMediaStream = ie((function(e, t) {
                                return ne(e, t), e
                            })), this.getStreamID = function(e) {
                                var t = e.id;
                                return "number" == typeof t ? t : S.a.filterSpecialChars(t)
                            }, this.getTrackID = function(e) {
                                return e.id
                            }, MediaStream.prototype.getVideoTracks || (MediaStream.prototype.getVideoTracks = function() {
                                return this.videoTracks
                            }), MediaStream.prototype.getAudioTracks || (MediaStream.prototype.getAudioTracks = function() {
                                return this.audioTracks
                            })
                        }
                        this._initPCConstraints(t), _.a.init(t, this.getUserMediaWithConstraints.bind(this)), this.isDeviceListAvailable() && this.enumerateDevices((function(t) {
                            D = t.splice(0), P.debug("Available devices: ", D), Z(D), L.emit(g.a.DEVICE_LIST_AVAILABLE, D);
                            var n = function() {
                                return e.enumerateDevices((function(e) {
                                    Y(e) && ee(e)
                                }))
                            };
                            v.a.supportsDeviceChangeEvent() ? navigator.mediaDevices.addEventListener("devicechange", n) : N = window.setInterval(n, 3e3)
                        }))
                    }
                }, {
                    key: "_initPCConstraints",
                    value: function(e) {
                        v.a.isFirefox() ? this.pcConstraints = {} : (v.a.isChromiumBased() || v.a.isReactNative()) && (this.pcConstraints = {
                            optional: [{
                                googHighStartBitrate: 0
                            }, {
                                googPayloadPadding: !0
                            }, {
                                googScreencastMinBitrate: 100
                            }, {
                                googCpuOveruseDetection: !0
                            }, {
                                googCpuOveruseEncodeUsage: !0
                            }, {
                                googCpuUnderuseThreshold: 55
                            }, {
                                googCpuOveruseThreshold: 85
                            }]
                        }, e.useIPv6 && this.pcConstraints.optional.push({
                            googIPv6: !0
                        }), this.p2pPcConstraints = JSON.parse(JSON.stringify(this.pcConstraints))), this.p2pPcConstraints = this.p2pPcConstraints || this.pcConstraints
                    }
                }, {
                    key: "getUserMediaWithConstraints",
                    value: function(e) {
                        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                            n = z(e, t);
                        return P.info("Get media constraints", n), new Promise((function(t, r) {
                            navigator.mediaDevices.getUserMedia(n).then((function(n) {
                                P.log("onUserMediaSuccess"), Q(e, n), t(n)
                            })).catch((function(t) {
                                P.warn("Failed to get access to local media. " + " ".concat(t, " ").concat(n, " ")), Q(e, void 0), r(new d.a(t, n, e))
                            }))
                        }))
                    }
                }, {
                    key: "_newGetUserMediaWithConstraints",
                    value: function(e) {
                        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                        return new Promise((function(n, r) {
                            navigator.mediaDevices.getUserMedia(t).then((function(t) {
                                P.log("onUserMediaSuccess"), Q(e, t), n(t)
                            })).catch((function(n) {
                                P.warn("Failed to get access to local media. " + " ".concat(n, " ").concat(t, " ")), Q(e, void 0), r(new d.a(n, t, e))
                            }))
                        }))
                    }
                }, {
                    key: "_newGetDesktopMedia",
                    value: function(e) {
                        var t = this;
                        return _.a.isSupported() && v.a.supportsVideo() ? new Promise((function(n, r) {
                            _.a.obtainStream(t._parseDesktopSharingOptions(e), (function(e) {
                                n(e)
                            }), (function(e) {
                                r(e)
                            }))
                        })) : Promise.reject(new Error("Desktop sharing is not supported!"))
                    }
                }, {
                    key: "obtainAudioAndVideoPermissions",
                    value: function() {
                        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                        e.devices = e.devices || M.concat(), e.resolution = e.resolution || 720;
                        var t = e.devices.includes("desktop");
                        return t && !_.a.isSupported() ? Promise.reject(new Error("Desktop sharing is not supported!")) : this._getAudioAndVideoStreams(e).then((function(t) {
                            return te(t, e.resolution)
                        }))
                    }
                }, {
                    key: "_getAudioAndVideoStreams",
                    value: function(e) {
                        var t = this,
                            n = e.devices.includes("desktop");
                        return e.devices = e.devices.filter((function(e) {
                            return "desktop" !== e
                        })), (e.devices.length ? this.getUserMediaWithConstraints(e.devices, e) : Promise.resolve(null)).then((function(n) {
                            var r = t._getMissingTracks(e.devices, n);
                            return r.length ? (t.stopMediaStream(n), t.getUserMediaWithConstraints(r, e).then((function() {
                                return Promise.reject(new d.a({
                                    name: "UnknownError"
                                }, z(e.devices, e), r))
                            }))) : n
                        })).then((function(r) {
                            if (!n) return {
                                audioVideo: r
                            };
                            if (e.desktopSharingSourceDevice) throw t.stopMediaStream(r), new Error("Using a camera as screenshare source isnot supported on this browser.");
                            return new Promise((function(n, i) {
                                _.a.obtainStream(t._parseDesktopSharingOptions(e), (function(e) {
                                    return n({
                                        audioVideo: r,
                                        desktop: e
                                    })
                                }), (function(e) {
                                    r && t.stopMediaStream(r), i(e)
                                }))
                            }))
                        }))
                    }
                }, {
                    key: "_getMissingTracks",
                    value: function() {
                        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
                            t = arguments.length > 1 ? arguments[1] : void 0,
                            n = [],
                            r = e.includes("audio"),
                            i = t && t.getAudioTracks().length > 0;
                        r && !i && n.push("audio");
                        var o = e.includes("video"),
                            a = t && t.getVideoTracks().length > 0;
                        return o && !a && n.push("video"), n
                    }
                }, {
                    key: "_parseDesktopSharingOptions",
                    value: function(e) {
                        return O({}, e.desktopSharingExtensionExternalInstallation, {
                            desktopSharingSources: e.desktopSharingSources,
                            gumOptions: {
                                frameRate: e.desktopSharingFrameRate
                            },
                            trackOptions: X(e)
                        })
                    }
                }, {
                    key: "newObtainAudioAndVideoPermissions",
                    value: function(e) {
                        var t = this;
                        P.info("Using the new gUM flow");
                        var n = [],
                            r = function() {
                                if (-1 === (e.devices || []).indexOf("desktop")) return Promise.resolve();
                                var t = e.desktopSharingExtensionExternalInstallation,
                                    n = e.desktopSharingSourceDevice,
                                    r = e.desktopSharingSources,
                                    i = e.desktopSharingFrameRate;
                                if (n) {
                                    var o = D && D.find((function(e) {
                                            return "videoinput" === e.kind && (e.deviceId === n || e.label === n)
                                        })),
                                        a = this._parseDesktopSharingOptions(e),
                                        s = a.gumOptions,
                                        c = a.trackOptions,
                                        u = {
                                            video: O({}, s, {
                                                deviceId: {
                                                    exact: o && o.deviceId || n
                                                }
                                            })
                                        };
                                    return this._newGetUserMediaWithConstraints(["video"], u).then((function(e) {
                                        var t = e && e.getTracks()[0];
                                        return (t && t.applyConstraints ? t.applyConstraints(c) : Promise.resolve()).then((function() {
                                            return {
                                                sourceType: "device",
                                                stream: e
                                            }
                                        }))
                                    }))
                                }
                                return this._newGetDesktopMedia({
                                    desktopSharingExtensionExternalInstallation: t,
                                    desktopSharingSources: r,
                                    desktopSharingFrameRate: i
                                })
                            }.bind(this),
                            i = function() {
                                var t = (e.devices || ["audio", "video"]).filter((function(e) {
                                    return "audio" === e || "video" === e && v.a.supportsVideo()
                                }));
                                if (!t.length) return Promise.resolve();
                                var n = function() {
                                    var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
                                        t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                                        n = JSON.parse(JSON.stringify(t.constraints || x));
                                    if (e.indexOf("video") >= 0)
                                        if (n.video || (n.video = {}), t.cameraDeviceId) n.video.deviceId = t.cameraDeviceId;
                                        else {
                                            var r = t.facingMode || o.a.USER;
                                            n.video.facingMode = r
                                        }
                                    else n.video = !1;
                                    return e.indexOf("audio") >= 0 ? (n.audio && "boolean" != typeof n.audio || (n.audio = {}), n.audio.optional || (n.audio.optional = []), n.audio.optional.push({
                                        sourceId: t.micDeviceId
                                    }, {
                                        echoCancellation: !J && !H
                                    }, {
                                        googEchoCancellation: !J && !H
                                    }, {
                                        googAutoGainControl: !B && !H
                                    }, {
                                        googNoiseSuppression: !G && !H
                                    }, {
                                        googHighpassFilter: !V && !H
                                    }, {
                                        googNoiseSuppression2: !G && !H
                                    }, {
                                        googEchoCancellation2: !J && !H
                                    }, {
                                        googAutoGainControl2: !B && !H
                                    })) : n.audio = !1, e.indexOf("desktop") >= 0 && (n.video && "boolean" != typeof n.video || (n.video = {}), n.video = {
                                        mandatory: $(O({}, t, {
                                            source: "desktop"
                                        }))
                                    }), n
                                }(t, e);
                                return P.info("Got media constraints: ", n), this._newGetUserMediaWithConstraints(t, n)
                            }.bind(this);
                        return r().then((function(e) {
                            if (e) {
                                var t = e.stream,
                                    r = e.sourceId,
                                    i = e.sourceType;
                                n.push({
                                    stream: t,
                                    sourceId: r,
                                    sourceType: i,
                                    track: t.getVideoTracks()[0],
                                    videoType: T.a.DESKTOP
                                })
                            }
                        })).then(i).then((function(t) {
                            if (t) {
                                var r = t.getAudioTracks();
                                if (r.length) {
                                    var i = new MediaStream(r);
                                    n.push({
                                        stream: i,
                                        track: i.getAudioTracks()[0],
                                        effects: e.effects
                                    })
                                }
                                var o = t.getVideoTracks();
                                if (o.length) {
                                    var a = new MediaStream(o);
                                    n.push({
                                        stream: a,
                                        track: a.getVideoTracks()[0],
                                        videoType: T.a.CAMERA,
                                        effects: e.effects
                                    })
                                }
                            }
                        })).then((function() {
                            return n
                        })).catch((function(e) {
                            return n.forEach((function(e) {
                                var n = e.stream;
                                t.stopMediaStream(n)
                            })), Promise.reject(e)
                        }))
                    }
                }, {
                    key: "isDeviceListAvailable",
                    value: function() {
                        return Boolean(navigator.mediaDevices && navigator.mediaDevices.enumerateDevices)
                    }
                }, {
                    key: "isDeviceChangeAvailable",
                    value: function(e) {
                        return "output" === e || "audiooutput" === e ? K : v.a.isChromiumBased() || v.a.isFirefox() || v.a.isEdge()
                    }
                }, {
                    key: "stopMediaStream",
                    value: function(e) {
                        if (e) {
                            e.getTracks().forEach((function(e) {
                                e.stop && e.stop()
                            })), e.stop && e.stop(), e.release && e.release();
                            var t = e.jitsiObjectURL;
                            t && (delete e.jitsiObjectURL, URL.revokeObjectURL(t))
                        }
                    }
                }, {
                    key: "isDesktopSharingEnabled",
                    value: function() {
                        return _.a.isSupported()
                    }
                }, {
                    key: "setAudioOutputDevice",
                    value: function(e) {
                        return this.isDeviceChangeAvailable("output") ? q.setSinkId(e).then((function() {
                            F = e, U = !0, P.log("Audio output device set to ".concat(e)), L.emit(g.a.AUDIO_OUTPUT_DEVICE_CHANGED, e)
                        })) : Promise.reject(new Error("Audio output device change is not supported"))
                    }
                }, {
                    key: "getAudioOutputDevice",
                    value: function() {
                        return F
                    }
                }, {
                    key: "getCurrentlyAvailableMediaDevices",
                    value: function() {
                        return D
                    }
                }, {
                    key: "getEventDataForActiveDevice",
                    value: function(e) {
                        var t = [],
                            n = {
                                deviceId: e.deviceId,
                                kind: e.kind,
                                label: e.label,
                                groupId: e.groupId
                            };
                        return t.push(n), {
                            deviceList: t
                        }
                    }
                }, {
                    key: "setSuspendVideo",
                    value: function(e, t) {
                        e.optional || (e.optional = []), e.optional = e.optional.filter((function(e) {
                            return !e.hasOwnProperty("googSuspendBelowMinBitrate")
                        })), t && e.optional.push({
                            googSuspendBelowMinBitrate: "true"
                        })
                    }
                }]) && R(n.prototype, r), i && R(n, i), t
            }(p.a));

            function ie(e) {
                return function(t, n) {
                    var r = e.apply(re, arguments);
                    return n && re.isDeviceChangeAvailable("output") && n.getAudioTracks && n.getAudioTracks().length && U && t.setSinkId(re.getAudioOutputDevice()).catch((function(e) {
                        var n = new d.a(e, null, ["audiooutput"]);
                        l.a.callUnhandledRejectionHandler({
                            promise: this,
                            reason: n
                        }), P.warn("Failed to set audio output device for the element. Default audio output device will be used instead", t, n)
                    })), r
                }
            }
            t.a = re
        }).call(this, "modules/RTC/RTCUtils.js")
    }, function(e, t) {
        var n = [],
            r = window.onerror;
        var i = window.onunhandledrejection;
        window.onerror = function() {
            for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];
            n.forEach((function(e) {
                return e.apply(void 0, t)
            })), r && r.apply(void 0, t)
        }, window.onunhandledrejection = function(e) {
            n.forEach((function(t) {
                return t(null, null, null, null, e.reason)
            })), i && i(e)
        };
        var o = {
            addHandler: function(e) {
                n.push(e)
            },
            callErrorHandler: function(e) {
                var t = window.onerror;
                t && t(null, null, null, null, e)
            },
            callUnhandledRejectionHandler: function(e) {
                var t = window.onunhandledrejection;
                t && t(e)
            }
        };
        e.exports = o
    }, function(e, t, n) {
        "use strict";
        n.r(t), n.d(t, "CHROME_EXTENSION_GENERIC_ERROR", (function() {
            return r
        })), n.d(t, "CHROME_EXTENSION_INSTALLATION_ERROR", (function() {
            return i
        })), n.d(t, "CHROME_EXTENSION_USER_GESTURE_REQUIRED", (function() {
            return o
        })), n.d(t, "CHROME_EXTENSION_USER_CANCELED", (function() {
            return a
        })), n.d(t, "CONSTRAINT_FAILED", (function() {
            return s
        })), n.d(t, "ELECTRON_DESKTOP_PICKER_ERROR", (function() {
            return c
        })), n.d(t, "ELECTRON_DESKTOP_PICKER_NOT_FOUND", (function() {
            return u
        })), n.d(t, "FIREFOX_EXTENSION_NEEDED", (function() {
            return l
        })), n.d(t, "GENERAL", (function() {
            return d
        })), n.d(t, "NOT_FOUND", (function() {
            return p
        })), n.d(t, "PERMISSION_DENIED", (function() {
            return h
        })), n.d(t, "TRACK_IS_DISPOSED", (function() {
            return f
        })), n.d(t, "TRACK_NO_STREAM_FOUND", (function() {
            return m
        })), n.d(t, "UNSUPPORTED_RESOLUTION", (function() {
            return v
        }));
        var r = "gum.chrome_extension_generic_error",
            i = "gum.chrome_extension_installation_error",
            o = "gum.chrome_extension_user_gesture_required",
            a = "gum.chrome_extension_user_canceled",
            s = "gum.constraint_failed",
            c = "gum.electron_desktop_picker_error",
            u = "gum.electron_desktop_picker_not_found",
            l = "gum.firefox_extension_needed",
            d = "gum.general",
            p = "gum.not_found",
            h = "gum.permission_denied",
            f = "track.track_is_disposed",
            m = "track.no_stream_found",
            v = "gum.unsupported_resolution"
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return P
            }));
            var r = n(4),
                i = n(95),
                o = n(11),
                a = n.n(o),
                s = n(2),
                c = n(57),
                u = n(24),
                l = n(54),
                d = n(9),
                p = n(3),
                h = n(8),
                f = n.n(h),
                m = n(10),
                v = n(5),
                y = n(96),
                g = n(14),
                _ = n.n(g);

            function S(e) {
                return (S = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                    return typeof e
                } : function(e) {
                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                })(e)
            }

            function b(e, t) {
                for (var n = 0; n < t.length; n++) {
                    var r = t[n];
                    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                }
            }

            function E(e) {
                return (E = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
                    return e.__proto__ || Object.getPrototypeOf(e)
                })(e)
            }

            function T(e, t) {
                return (T = Object.setPrototypeOf || function(e, t) {
                    return e.__proto__ = t, e
                })(e, t)
            }

            function C(e) {
                if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return e
            }

            function R(e, t, n) {
                return t in e ? Object.defineProperty(e, t, {
                    value: n,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : e[t] = n, e
            }
            var A = Object(r.getLogger)(e),
                w = 0,
                k = 0;

            function O(e, t) {
                var n = [],
                    r = null;
                return e.forEach((function(e) {
                    e.mediaType === d.a ? r = t.micDeviceId : e.videoType === _.a.CAMERA && (r = t.cameraDeviceId), k = Object(l.a)(k);
                    var i = new c.a(function(e) {
                        for (var t = 1; t < arguments.length; t++) {
                            var n = null != arguments[t] ? arguments[t] : {},
                                r = Object.keys(n);
                            "function" == typeof Object.getOwnPropertySymbols && (r = r.concat(Object.getOwnPropertySymbols(n).filter((function(e) {
                                return Object.getOwnPropertyDescriptor(n, e).enumerable
                            })))), r.forEach((function(t) {
                                R(e, t, n[t])
                            }))
                        }
                        return e
                    }({}, e, {
                        deviceId: r,
                        facingMode: t.facingMode,
                        rtcId: k,
                        effects: t.effects
                    }));
                    n.push(i)
                })), n
            }

            function I() {
                return (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []).map((function(e) {
                    var t = e.sourceId,
                        n = e.sourceType,
                        r = e.stream,
                        i = e.track,
                        o = e.videoType,
                        a = e.effects,
                        s = i.getSettings(),
                        u = s.deviceId,
                        d = s.facingMode;
                    return k = Object(l.a)(k), new c.a({
                        deviceId: u,
                        facingMode: d,
                        mediaType: i.kind,
                        rtcId: k,
                        sourceId: t,
                        sourceType: n,
                        stream: r,
                        track: i,
                        videoType: o || null,
                        effects: a
                    })
                }))
            }
            var P = function(e) {
                function t(e) {
                    var n, r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                    return function(e, t) {
                        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                    }(this, t), (n = function(e, t) {
                        return !t || "object" !== S(t) && "function" != typeof t ? C(e) : t
                    }(this, E(t).call(this))).conference = e, n.peerConnections = new Map, n.localTracks = [], n.options = r, n._channel = null, n._channelOpen = !1, n._lastN = -1, n._lastNEndpoints = null, n._maxFrameHeight = void 0, n._pinnedEndpoint = null, n._selectedEndpoints = [], n._lastNChangeListener = n._onLastNChanged.bind(C(C(n))), n._onDeviceListChanged = n._onDeviceListChanged.bind(C(C(n))), n._updateAudioOutputForAudioTracks = n._updateAudioOutputForAudioTracks.bind(C(C(n))), m.a.isDeviceChangeAvailable("output") && (m.a.addListener(f.a.AUDIO_OUTPUT_DEVICE_CHANGED, n._updateAudioOutputForAudioTracks), m.a.addListener(f.a.DEVICE_LIST_CHANGED, n._onDeviceListChanged)), n
                }
                var n, r, o;
                return function(e, t) {
                    if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
                    e.prototype = Object.create(t && t.prototype, {
                        constructor: {
                            value: e,
                            writable: !0,
                            configurable: !0
                        }
                    }), t && T(e, t)
                }(t, e), n = t, o = [{
                    key: "newCreateLocalTracks",
                    value: function(e) {
                        return I(e)
                    }
                }, {
                    key: "obtainAudioAndVideoPermissions",
                    value: function(e) {
                        var t = p.a.usesNewGumFlow();
                        return (t ? m.a.newObtainAudioAndVideoPermissions(e) : m.a.obtainAudioAndVideoPermissions(e)).then((function(n) {
                            return t ? I(n) : O(n, e)
                        }))
                    }
                }, {
                    key: "addListener",
                    value: function(e, t) {
                        m.a.addListener(e, t)
                    }
                }, {
                    key: "removeListener",
                    value: function(e, t) {
                        m.a.removeListener(e, t)
                    }
                }, {
                    key: "init",
                    value: function() {
                        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                        return this.options = e, m.a.init(this.options)
                    }
                }, {
                    key: "getPCConstraints",
                    value: function(e) {
                        var t = e ? m.a.p2pPcConstraints : m.a.pcConstraints;
                        return t ? JSON.parse(JSON.stringify(t)) : {}
                    }
                }, {
                    key: "attachMediaStream",
                    value: function(e, t) {
                        return m.a.attachMediaStream(e, t)
                    }
                }, {
                    key: "getStreamID",
                    value: function(e) {
                        return m.a.getStreamID(e)
                    }
                }, {
                    key: "getTrackID",
                    value: function(e) {
                        return m.a.getTrackID(e)
                    }
                }, {
                    key: "isDeviceListAvailable",
                    value: function() {
                        return m.a.isDeviceListAvailable()
                    }
                }, {
                    key: "isDeviceChangeAvailable",
                    value: function(e) {
                        return m.a.isDeviceChangeAvailable(e)
                    }
                }, {
                    key: "isWebRtcSupported",
                    value: function() {
                        return p.a.isSupported()
                    }
                }, {
                    key: "getAudioOutputDevice",
                    value: function() {
                        return m.a.getAudioOutputDevice()
                    }
                }, {
                    key: "getCurrentlyAvailableMediaDevices",
                    value: function() {
                        return m.a.getCurrentlyAvailableMediaDevices()
                    }
                }, {
                    key: "getEventDataForActiveDevice",
                    value: function(e) {
                        return m.a.getEventDataForActiveDevice(e)
                    }
                }, {
                    key: "setAudioOutputDevice",
                    value: function(e) {
                        return m.a.setAudioOutputDevice(e)
                    }
                }, {
                    key: "isUserStream",
                    value: function(e) {
                        return t.isUserStreamById(m.a.getStreamID(e))
                    }
                }, {
                    key: "isUserStreamById",
                    value: function(e) {
                        return e && "mixedmslabel" !== e && "default" !== e
                    }
                }, {
                    key: "enumerateDevices",
                    value: function(e) {
                        m.a.enumerateDevices(e)
                    }
                }, {
                    key: "stopMediaStream",
                    value: function(e) {
                        m.a.stopMediaStream(e)
                    }
                }, {
                    key: "isDesktopSharingEnabled",
                    value: function() {
                        return m.a.isDesktopSharingEnabled()
                    }
                }], (r = [{
                    key: "destroy",
                    value: function() {
                        m.a.removeListener(f.a.AUDIO_OUTPUT_DEVICE_CHANGED, this._updateAudioOutputForAudioTracks), m.a.removeListener(f.a.DEVICE_LIST_CHANGED, this._onDeviceListChanged), this.removeListener(f.a.LASTN_ENDPOINT_CHANGED, this._lastNChangeListener), this._channelOpenListener && this.removeListener(f.a.DATA_CHANNEL_OPEN, this._channelOpenListener)
                    }
                }, {
                    key: "initializeBridgeChannel",
                    value: function(e, t) {
                        var n = this;
                        this._channel = new i.a(e, t, this.eventEmitter), this._channelOpenListener = function() {
                            n._channelOpen = !0;
                            try {
                                n._channel.sendPinnedEndpointMessage(n._pinnedEndpoint), n._channel.sendSelectedEndpointsMessage(n._selectedEndpoints), void 0 !== n._maxFrameHeight && n._channel.sendReceiverVideoConstraintMessage(n._maxFrameHeight)
                            } catch (e) {
                                a.a.callErrorHandler(e), A.error("Cannot send selected(".concat(n._selectedEndpoint, ")") + "pinned(".concat(n._pinnedEndpoint, ")") + "frameHeight(".concat(n._maxFrameHeight, ") endpoint message"), e)
                            }
                            n.removeListener(f.a.DATA_CHANNEL_OPEN, n._channelOpenListener), n._channelOpenListener = null, -1 !== n._lastN && n._channel.sendSetLastNMessage(n._lastN)
                        }, this.addListener(f.a.DATA_CHANNEL_OPEN, this._channelOpenListener), this.addListener(f.a.LASTN_ENDPOINT_CHANGED, this._lastNChangeListener)
                    }
                }, {
                    key: "_onDeviceListChanged",
                    value: function() {
                        this._updateAudioOutputForAudioTracks(m.a.getAudioOutputDevice())
                    }
                }, {
                    key: "_onLastNChanged",
                    value: function() {
                        var e = this,
                            t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
                            n = this._lastNEndpoints || [],
                            r = [],
                            i = [];
                        this._lastNEndpoints = t, r = n.filter((function(t) {
                            return !e.isInLastN(t)
                        })), i = t.filter((function(e) {
                            return -1 === n.indexOf(e)
                        })), this.conference.eventEmitter.emit(s.LAST_N_ENDPOINTS_CHANGED, r, i)
                    }
                }, {
                    key: "onCallEnded",
                    value: function() {
                        this._channel && (this._channel && "websocket" === this._channel.mode && this._channel.close(), this._channel = null, this._channelOpen = !1)
                    }
                }, {
                    key: "setReceiverVideoConstraint",
                    value: function(e) {
                        this._maxFrameHeight = e, this._channel && this._channelOpen && this._channel.sendReceiverVideoConstraintMessage(e)
                    }
                }, {
                    key: "selectEndpoints",
                    value: function(e) {
                        this._selectedEndpoints = e, this._channel && this._channelOpen && this._channel.sendSelectedEndpointsMessage(e)
                    }
                }, {
                    key: "pinEndpoint",
                    value: function(e) {
                        this._pinnedEndpoint = e, this._channel && this._channelOpen && this._channel.sendPinnedEndpointMessage(e)
                    }
                }, {
                    key: "createPeerConnection",
                    value: function(e, n, r, i) {
                        var o = t.getPCConstraints(r);
                        void 0 !== i.abtestSuspendVideo && (m.a.setSuspendVideo(o, i.abtestSuspendVideo), v.a.analytics.addPermanentProperties({
                            abtestSuspendVideo: i.abtestSuspendVideo
                        })), p.a.supportsSdpSemantics() && (n.sdpSemantics = "plan-b"), w = Object(l.a)(w);
                        var a = new y.a(this, w, e, n, o, r, i);
                        return this.peerConnections.set(a.id, a), a
                    }
                }, {
                    key: "_removePeerConnection",
                    value: function(e) {
                        var t = e.id;
                        return !!this.peerConnections.has(t) && (this.peerConnections.delete(t), !0)
                    }
                }, {
                    key: "addLocalTrack",
                    value: function(e) {
                        if (!e) throw new Error("track must not be null nor undefined");
                        this.localTracks.push(e), e.conference = this.conference
                    }
                }, {
                    key: "getLastN",
                    value: function() {
                        return this._lastN
                    }
                }, {
                    key: "getLocalVideoTrack",
                    value: function() {
                        var e = this.getLocalTracks(d.b);
                        return e.length ? e[0] : void 0
                    }
                }, {
                    key: "getLocalAudioTrack",
                    value: function() {
                        var e = this.getLocalTracks(d.a);
                        return e.length ? e[0] : void 0
                    }
                }, {
                    key: "getLocalTracks",
                    value: function(e) {
                        var t = this.localTracks.slice();
                        return void 0 !== e && (t = t.filter((function(t) {
                            return t.getType() === e
                        }))), t
                    }
                }, {
                    key: "getRemoteTracks",
                    value: function(e) {
                        var t = [],
                            n = !0,
                            r = !1,
                            i = void 0;
                        try {
                            for (var o, a = this.peerConnections.values()[Symbol.iterator](); !(n = (o = a.next()).done); n = !0) {
                                var s = o.value.getRemoteTracks(void 0, e);
                                s && (t = t.concat(s))
                            }
                        } catch (e) {
                            r = !0, i = e
                        } finally {
                            try {
                                n || null == a.return || a.return()
                            } finally {
                                if (r) throw i
                            }
                        }
                        return t
                    }
                }, {
                    key: "setAudioMute",
                    value: function(e) {
                        var t = [];
                        return this.getLocalTracks(d.a).forEach((function(n) {
                            t.push(e ? n.mute() : n.unmute())
                        })), Promise.all(t)
                    }
                }, {
                    key: "removeLocalTrack",
                    value: function(e) {
                        var t = this.localTracks.indexOf(e); - 1 !== t && this.localTracks.splice(t, 1)
                    }
                }, {
                    key: "removeRemoteTracks",
                    value: function(e) {
                        var t = [],
                            n = !0,
                            r = !1,
                            i = void 0;
                        try {
                            for (var o, a = this.peerConnections.values()[Symbol.iterator](); !(n = (o = a.next()).done); n = !0) {
                                var s = o.value.removeRemoteTracks(e);
                                t = t.concat(s)
                            }
                        } catch (e) {
                            r = !0, i = e
                        } finally {
                            try {
                                n || null == a.return || a.return()
                            } finally {
                                if (r) throw i
                            }
                        }
                        return A.debug("Removed remote tracks for ".concat(e) + " count: ".concat(t.length)), t
                    }
                }, {
                    key: "closeBridgeChannel",
                    value: function() {
                        this._channel && (this._channel.close(), this._channelOpen = !1, this.removeListener(f.a.LASTN_ENDPOINT_CHANGED, this._lastNChangeListener))
                    }
                }, {
                    key: "setAudioLevel",
                    value: function(e, t, n, r) {
                        var i = e.getTrackBySSRC(t);
                        i && (i.isAudioTrack() ? (i.isLocal() !== r && A.error("".concat(i, " was expected to ").concat(r ? "be" : "not be", " local")), i.setAudioLevel(n, e)) : A.warn("Received audio level for non-audio track: ".concat(t)))
                    }
                }, {
                    key: "sendChannelMessage",
                    value: function(e, t) {
                        if (!this._channel) throw new Error("Channel support is disabled!");
                        this._channel.sendMessage(e, t)
                    }
                }, {
                    key: "setLastN",
                    value: function(e) {
                        this._lastN !== e && (this._lastN = e, this._channel && this._channelOpen && this._channel.sendSetLastNMessage(e), this.eventEmitter.emit(f.a.LASTN_VALUE_CHANGED, e))
                    }
                }, {
                    key: "isInLastN",
                    value: function(e) {
                        return !this._lastNEndpoints || this._lastNEndpoints.indexOf(e) > -1
                    }
                }, {
                    key: "_updateAudioOutputForAudioTracks",
                    value: function(e) {
                        var t = this.getRemoteTracks(d.a),
                            n = !0,
                            r = !1,
                            i = void 0;
                        try {
                            for (var o, a = t[Symbol.iterator](); !(n = (o = a.next()).done); n = !0) o.value.setAudioOutput(e)
                        } catch (e) {
                            r = !0, i = e
                        } finally {
                            try {
                                n || null == a.return || a.return()
                            } finally {
                                if (r) throw i
                            }
                        }
                    }
                }]) && b(n.prototype, r), o && b(n, o), t
            }(u.a)
        }).call(this, "modules/RTC/RTC.js")
    }, function(e, t) {
        e.exports = {
            CAMERA: "camera",
            DESKTOP: "desktop"
        }
    }, function(e, t, n) {
        "use strict";
        var r = n(12);

        function i(e) {
            return (i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                return typeof e
            } : function(e) {
                return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
            })(e)
        }
        var o = {};

        function a(e, t, n) {
            if ("object" === i(e) && void 0 !== e.name) switch (this.gum = {
                error: e,
                constraints: t,
                devices: n && Array.isArray(n) ? n.slice(0) : void 0
            }, e.name) {
                case "NotAllowedError":
                case "PermissionDeniedError":
                case "SecurityError":
                    this.name = r.PERMISSION_DENIED, this.message = o[this.name] + (this.gum.devices || []).join(", ");
                    break;
                case "DevicesNotFoundError":
                case "NotFoundError":
                    this.name = r.NOT_FOUND, this.message = o[this.name] + (this.gum.devices || []).join(", ");
                    break;
                case "ConstraintNotSatisfiedError":
                case "OverconstrainedError":
                    var a = e.constraintName || e.constraint;
                    t && t.video && (!n || n.indexOf("video") > -1) && ("minWidth" === a || "maxWidth" === a || "minHeight" === a || "maxHeight" === a || "width" === a || "height" === a || "deviceId" === a) ? (this.name = r.UNSUPPORTED_RESOLUTION, this.message = o[this.name] + function(e, t) {
                        if (t && t.video && t.video.mandatory) switch (e) {
                            case "width":
                                return t.video.mandatory.minWidth;
                            case "height":
                                return t.video.mandatory.minHeight;
                            default:
                                return t.video.mandatory[e] || ""
                        }
                        return ""
                    }(a, t)) : (this.name = r.CONSTRAINT_FAILED, this.message = o[this.name] + e.constraintName);
                    break;
                default:
                    this.name = r.GENERAL, this.message = e.message || o[this.name]
            } else {
                if ("string" != typeof e) throw new Error("Invalid arguments");
                o[e] ? (this.name = e, this.message = t || o[e]) : this.message = e
            }
            this.stack = e.stack || (new Error).stack
        }
        o[r.UNSUPPORTED_RESOLUTION] = "Video resolution is not supported: ", o[r.CHROME_EXTENSION_INSTALLATION_ERROR] = "Failed to install Chrome extension", o[r.CHROME_EXTENSION_USER_GESTURE_REQUIRED] = "Failed to install Chrome extension - installations can only be initiated by a user gesture.", o[r.CHROME_EXTENSION_USER_CANCELED] = "User canceled Chrome's screen sharing prompt", o[r.CHROME_EXTENSION_GENERIC_ERROR] = "Unknown error from Chrome extension", o[r.ELECTRON_DESKTOP_PICKER_ERROR] = "Unkown error from desktop picker", o[r.ELECTRON_DESKTOP_PICKER_NOT_FOUND] = "Failed to detect desktop picker", o[r.GENERAL] = "Generic getUserMedia error", o[r.PERMISSION_DENIED] = "User denied permission to use device(s): ", o[r.NOT_FOUND] = "Requested device(s) was/were not found: ", o[r.CONSTRAINT_FAILED] = "Constraint could not be satisfied: ", o[r.TRACK_IS_DISPOSED] = "Track has been already disposed", o[r.TRACK_NO_STREAM_FOUND] = "Track does not have an associated Media Stream", a.prototype = Object.create(Error.prototype), a.prototype.constructor = a, t.a = a
    }, function(e, t, n) {
        "use strict";
        n.r(t), n.d(t, "LOCAL_TRACK_STOPPED", (function() {
            return r
        })), n.d(t, "TRACK_AUDIO_LEVEL_CHANGED", (function() {
            return i
        })), n.d(t, "TRACK_AUDIO_OUTPUT_CHANGED", (function() {
            return o
        })), n.d(t, "TRACK_MUTE_CHANGED", (function() {
            return a
        })), n.d(t, "TRACK_VIDEOTYPE_CHANGED", (function() {
            return s
        })), n.d(t, "NO_DATA_FROM_SOURCE", (function() {
            return c
        }));
        var r = "track.stopped",
            i = "track.audioLevelsChanged",
            o = "track.audioOutputChanged",
            a = "track.trackMuteChanged",
            s = "track.videoTypeChanged",
            c = "track.no_data_from_source"
    }, function(e, t, n) {
        "use strict";
        n.r(t), n.d(t, "AUTHENTICATION_REQUIRED", (function() {
            return r
        })), n.d(t, "CHAT_ERROR", (function() {
            return i
        })), n.d(t, "CONFERENCE_DESTROYED", (function() {
            return o
        })), n.d(t, "CONFERENCE_MAX_USERS", (function() {
            return a
        })), n.d(t, "CONNECTION_ERROR", (function() {
            return s
        })), n.d(t, "NOT_ALLOWED_ERROR", (function() {
            return c
        })), n.d(t, "FOCUS_DISCONNECTED", (function() {
            return u
        })), n.d(t, "FOCUS_LEFT", (function() {
            return l
        })), n.d(t, "GRACEFUL_SHUTDOWN", (function() {
            return d
        })), n.d(t, "INCOMPATIBLE_SERVER_VERSIONS", (function() {
            return p
        })), n.d(t, "OFFER_ANSWER_FAILED", (function() {
            return h
        })), n.d(t, "PASSWORD_NOT_SUPPORTED", (function() {
            return f
        })), n.d(t, "PASSWORD_REQUIRED", (function() {
            return m
        })), n.d(t, "RESERVATION_ERROR", (function() {
            return v
        })), n.d(t, "SETUP_FAILED", (function() {
            return y
        })), n.d(t, "VIDEOBRIDGE_NOT_AVAILABLE", (function() {
            return g
        }));
        var r = "conference.authenticationRequired",
            i = "conference.chatError",
            o = "conference.destroyed",
            a = "conference.max_users",
            s = "conference.connectionError",
            c = "conference.connectionError.notAllowed",
            u = "conference.focusDisconnected",
            l = "conference.focusLeft",
            d = "conference.gracefulShutdown",
            p = "conference.incompatible_server_versions",
            h = "conference.offerAnswerFailed",
            f = "conference.passwordNotSupported",
            m = "conference.passwordRequired",
            v = "conference.reservationError",
            y = "conference.setup_failed",
            g = "conference.videobridgeNotAvailable"
    }, function(e, t, n) {
        "use strict";
        n.d(t, "a", (function() {
            return o
        }));
        var r = n(6);

        function i(e, t) {
            return function(e) {
                if (Array.isArray(e)) return e
            }(e) || function(e, t) {
                var n = [],
                    r = !0,
                    i = !1,
                    o = void 0;
                try {
                    for (var a, s = e[Symbol.iterator](); !(r = (a = s.next()).done) && (n.push(a.value), !t || n.length !== t); r = !0);
                } catch (e) {
                    i = !0, o = e
                } finally {
                    try {
                        r || null == s.return || s.return()
                    } finally {
                        if (i) throw o
                    }
                }
                return n
            }(e, t) || function() {
                throw new TypeError("Invalid attempt to destructure non-iterable instance")
            }()
        }

        function o(e) {
            for (var t = e.split("\r\nm="), n = 1, r = t.length; n < r; n++) {
                var i = "m=".concat(t[n]);
                n !== r - 1 && (i += "\r\n"), t[n] = i
            }
            var o = "".concat(t.shift(), "\r\n");
            this.media = t, this.raw = o + t.join(""), this.session = o
        }
        o.prototype.failICE = !1, o.prototype.removeTcpCandidates = !1, o.prototype.removeUdpCandidates = !1, o.prototype.getMediaSsrcMap = function() {
            for (var e, t = this, n = {}, i = function(i) {
                    e = r.a.findLines(t.media[i], "a=ssrc:");
                    var o = {
                        mediaindex: i,
                        mid: r.a.parseMID(r.a.findLine(t.media[i], "a=mid:")),
                        ssrcs: {},
                        ssrcGroups: []
                    };
                    n[i] = o, e.forEach((function(e) {
                        var t = e.substring(7).split(" ")[0];
                        o.ssrcs[t] || (o.ssrcs[t] = {
                            ssrc: t,
                            lines: []
                        }), o.ssrcs[t].lines.push(e)
                    })), (e = r.a.findLines(t.media[i], "a=ssrc-group:")).forEach((function(e) {
                        var t = e.indexOf(" "),
                            n = e.substr(0, t).substr(13),
                            r = e.substr(14 + n.length).split(" ");
                        r.length && o.ssrcGroups.push({
                            semantics: n,
                            ssrcs: r
                        })
                    }))
                }, o = 0; o < t.media.length; o++) i(o);
            return n
        }, o.prototype.containsSSRC = function(e) {
            var t = this.getMediaSsrcMap(),
                n = !1;
            return Object.keys(t).forEach((function(r) {
                n || t[r].ssrcs[e] && (n = !0)
            })), n
        }, o.prototype.mangle = function() {
            var e, t, n, i, o, a;
            for (e = 0; e < this.media.length; e++)
                if ((n = this.media[e].split("\r\n")).pop(), "audio" === (i = r.a.parseMLine(n.shift())).media) {
                    for (o = "", i.fmt.length = 0, t = 0; t < n.length; t++) {
                        if ("a=rtpmap:" === n[t].substr(0, 9)) {
                            if ("CN" === (a = r.a.parseRTPMap(n[t])).name || "ISAC" === a.name) continue;
                            i.fmt.push(a.id)
                        }
                        o += "".concat(n[t], "\r\n")
                    }
                    this.media[e] = "".concat(r.a.buildMLine(i), "\r\n").concat(o)
                } this.raw = this.session + this.media.join("")
        }, o.prototype.removeSessionLines = function(e) {
            var t = this,
                n = r.a.findLines(this.session, e);
            return n.forEach((function(e) {
                t.session = t.session.replace("".concat(e, "\r\n"), "")
            })), this.raw = this.session + this.media.join(""), n
        }, o.prototype.removeMediaLines = function(e, t) {
            var n = this,
                i = r.a.findLines(this.media[e], t);
            return i.forEach((function(t) {
                n.media[e] = n.media[e].replace("".concat(t, "\r\n"), "")
            })), this.raw = this.session + this.media.join(""), i
        }, o.prototype.toJingle = function(e, t) {
            var n, o, a, s, c, u, l, d;
            if ((s = r.a.findLines(this.session, "a=group:")).length)
                for (n = 0; n < s.length; n++) {
                    var p = (d = s[n].split(" ")).shift().substr(8);
                    for (e.c("group", {
                            xmlns: "urn:xmpp:jingle:apps:grouping:0",
                            semantics: p
                        }), o = 0; o < d.length; o++) e.c("content", {
                        name: d[o]
                    }).up();
                    e.up()
                }
            for (n = 0; n < this.media.length; n++)
                if ("audio" === (c = r.a.parseMLine(this.media[n].split("\r\n")[0])).media || "video" === c.media || "application" === c.media) {
                    var h = r.a.findLine(this.media[n], "a=ssrc:");
                    l = !!h && h.substring(7).split(" ")[0], e.c("content", {
                        creator: t,
                        name: c.media
                    });
                    var f = r.a.findLine(this.media[n], "a=mid:");
                    if (f) {
                        var m = r.a.parseMID(f);
                        e.attrs({
                            name: m
                        })
                    }
                    if (r.a.findLine(this.media[n], "a=rtpmap:").length) {
                        for (e.c("description", {
                                xmlns: "urn:xmpp:jingle:apps:rtp:1",
                                media: c.media
                            }), l && e.attrs({
                                ssrc: l
                            }), o = 0; o < c.fmt.length; o++) {
                            u = r.a.findLine(this.media[n], "a=rtpmap:".concat(c.fmt[o])), e.c("payload-type", r.a.parseRTPMap(u));
                            var v = r.a.findLine(this.media[n], "a=fmtp:".concat(c.fmt[o]));
                            if (v)
                                for (d = r.a.parseFmtp(v), a = 0; a < d.length; a++) e.c("parameter", d[a]).up();
                            this.rtcpFbToJingle(n, e, c.fmt[o]), e.up()
                        }
                        var y = r.a.findLines(this.media[n], "a=crypto:", this.session);
                        if (y.length && (e.c("encryption", {
                                required: 1
                            }), y.forEach((function(t) {
                                return e.c("crypto", r.a.parseCrypto(t)).up()
                            })), e.up()), l) {
                            var g = r.a.parseSSRC(this.media[n]),
                                _ = !0,
                                S = !1,
                                b = void 0;
                            try {
                                for (var E, T = g[Symbol.iterator](); !(_ = (E = T.next()).done); _ = !0) {
                                    var C = i(E.value, 2),
                                        R = C[0],
                                        A = C[1];
                                    e.c("source", {
                                        ssrc: R,
                                        xmlns: "urn:xmpp:jingle:apps:rtp:ssma:0"
                                    }), A.forEach((function(t) {
                                        var n = t.indexOf(" "),
                                            i = t.substr(n + 1);
                                        if (e.c("parameter"), -1 === i.indexOf(":")) e.attrs({
                                            name: i
                                        });
                                        else {
                                            var o = i.split(":", 2)[0];
                                            e.attrs({
                                                name: o
                                            });
                                            var a = i.split(":", 2)[1];
                                            a = r.a.filterSpecialChars(a), e.attrs({
                                                value: a
                                            })
                                        }
                                        e.up()
                                    })), e.up()
                                }
                            } catch (e) {
                                S = !0, b = e
                            } finally {
                                try {
                                    _ || null == T.return || T.return()
                                } finally {
                                    if (S) throw b
                                }
                            }
                            r.a.findLines(this.media[n], "a=ssrc-group:").forEach((function(t) {
                                var n = t.indexOf(" "),
                                    r = t.substr(0, n).substr(13),
                                    i = t.substr(14 + r.length).split(" ");
                                i.length && (e.c("ssrc-group", {
                                    semantics: r,
                                    xmlns: "urn:xmpp:jingle:apps:rtp:ssma:0"
                                }), i.forEach((function(t) {
                                    return e.c("source", {
                                        ssrc: t
                                    }).up()
                                })), e.up())
                            }))
                        }
                        var w = r.a.findLines(this.media[n], "a=rid");
                        if (w.length) {
                            var k = w.map((function(e) {
                                return e.split(":")[1]
                            })).map((function(e) {
                                return e.split(" ")[0]
                            }));
                            k.forEach((function(t) {
                                e.c("source", {
                                    rid: t,
                                    xmlns: "urn:xmpp:jingle:apps:rtp:ssma:0"
                                }), e.up()
                            })), r.a.findLine(this.media[n], "a=simulcast") && (e.c("rid-group", {
                                semantics: "SIM",
                                xmlns: "urn:xmpp:jingle:apps:rtp:ssma:0"
                            }), k.forEach((function(t) {
                                e.c("source", {
                                    rid: t
                                }).up()
                            })), e.up())
                        }
                        if (r.a.findLine(this.media[n], "a=rtcp-mux") && e.c("rtcp-mux").up(), this.rtcpFbToJingle(n, e, "*"), (s = r.a.findLines(this.media[n], "a=extmap:")).length)
                            for (o = 0; o < s.length; o++) {
                                if (d = r.a.parseExtmap(s[o]), e.c("rtp-hdrext", {
                                        xmlns: "urn:xmpp:jingle:apps:rtp:rtp-hdrext:0",
                                        uri: d.uri,
                                        id: d.value
                                    }), d.hasOwnProperty("direction")) switch (d.direction) {
                                    case "sendonly":
                                        e.attrs({
                                            senders: "responder"
                                        });
                                        break;
                                    case "recvonly":
                                        e.attrs({
                                            senders: "initiator"
                                        });
                                        break;
                                    case "sendrecv":
                                        e.attrs({
                                            senders: "both"
                                        });
                                        break;
                                    case "inactive":
                                        e.attrs({
                                            senders: "none"
                                        })
                                }
                                e.up()
                            }
                        e.up()
                    }
                    this.transportToJingle(n, e);
                    var O = this.media[n];
                    r.a.findLine(O, "a=sendrecv", this.session) ? e.attrs({
                        senders: "both"
                    }) : r.a.findLine(O, "a=sendonly", this.session) ? e.attrs({
                        senders: "initiator"
                    }) : r.a.findLine(O, "a=recvonly", this.session) ? e.attrs({
                        senders: "responder"
                    }) : r.a.findLine(O, "a=inactive", this.session) && e.attrs({
                        senders: "none"
                    }), "0" === c.port && e.attrs({
                        senders: "rejected"
                    }), e.up()
                } return e.up(), e
        }, o.prototype.transportToJingle = function(e, t) {
            var n, i = this;
            t.c("transport");
            var o = r.a.findLine(this.media[e], "a=sctpmap:", i.session);
            if (o) {
                var a = r.a.parseSCTPMap(o);
                t.c("sctpmap", {
                    xmlns: "urn:xmpp:jingle:transports:dtls-sctp:1",
                    number: a[0],
                    protocol: a[1]
                }), a.length > 2 && t.attrs({
                    streams: a[2]
                }), t.up()
            }
            if (r.a.findLines(this.media[e], "a=fingerprint:", this.session).forEach((function(o) {
                    (n = r.a.parseFingerprint(o)).xmlns = "urn:xmpp:jingle:apps:dtls:0", t.c("fingerprint").t(n.fingerprint), delete n.fingerprint, (o = r.a.findLine(i.media[e], "a=setup:", i.session)) && (n.setup = o.substr(8)), t.attrs(n), t.up()
                })), n = r.a.iceparams(this.media[e], this.session)) {
                n.xmlns = "urn:xmpp:jingle:transports:ice-udp:1", t.attrs(n);
                var s = r.a.findLines(this.media[e], "a=candidate:", this.session);
                s.length && s.forEach((function(e) {
                    var n = r.a.candidateToJingle(e);
                    i.failICE && (n.ip = "1.1.1.1");
                    var o = n && "string" == typeof n.protocol ? n.protocol.toLowerCase() : "";
                    i.removeTcpCandidates && ("tcp" === o || "ssltcp" === o) || i.removeUdpCandidates && "udp" === o || t.c("candidate", n).up()
                }))
            }
            t.up()
        }, o.prototype.rtcpFbToJingle = function(e, t, n) {
            r.a.findLines(this.media[e], "a=rtcp-fb:".concat(n)).forEach((function(e) {
                var n = r.a.parseRTCPFB(e);
                "trr-int" === n.type ? (t.c("rtcp-fb-trr-int", {
                    xmlns: "urn:xmpp:jingle:apps:rtp:rtcp-fb:0",
                    value: n.params[0]
                }), t.up()) : (t.c("rtcp-fb", {
                    xmlns: "urn:xmpp:jingle:apps:rtp:rtcp-fb:0",
                    type: n.type
                }), n.params.length > 0 && t.attrs({
                    subtype: n.params[0]
                }), t.up())
            }))
        }, o.prototype.rtcpFbFromJingle = function(e, t) {
            var n = "",
                r = e.find('>rtcp-fb-trr-int[xmlns="urn:xmpp:jingle:apps:rtp:rtcp-fb:0"]');
            return r.length && (n += "a=rtcp-fb:* trr-int ", r.attr("value") ? n += r.attr("value") : n += "0", n += "\r\n"), (r = e.find('>rtcp-fb[xmlns="urn:xmpp:jingle:apps:rtp:rtcp-fb:0"]')).each((function() {
                n += "a=rtcp-fb:".concat(t, " ").concat($(this).attr("type")), $(this).attr("subtype") && (n += " ".concat($(this).attr("subtype"))), n += "\r\n"
            })), n
        }, o.prototype.fromJingle = function(e) {
            var t = this;
            this.raw = "v=0\r\no=- 1923518516 2 IN IP4 0.0.0.0\r\ns=-\r\nt=0 0\r\n";
            var n = $(e).find('>group[xmlns="urn:xmpp:jingle:apps:grouping:0"]');
            n.length && n.each((function(e, n) {
                var r = $(n).find(">content").map((function(e, t) {
                    return t.getAttribute("name")
                })).get();
                r.length > 0 && (t.raw += "a=group:".concat(n.getAttribute("semantics") || n.getAttribute("type"), " ").concat(r.join(" "), "\r\n"))
            })), this.session = this.raw, e.find(">content").each((function() {
                var e = t.jingle2media($(this));
                t.media.push(e)
            })), this.raw = this.session + this.media.join("")
        }, o.prototype.jingle2media = function(e) {
            var t = e.find("description"),
                n = "",
                i = this,
                o = e.find('>transport>sctpmap[xmlns="urn:xmpp:jingle:transports:dtls-sctp:1"]'),
                a = {
                    media: t.attr("media"),
                    port: "1"
                };
            if ("rejected" === e.attr("senders") && (a.port = "0"), e.find(">transport>fingerprint").length || t.find("encryption").length ? a.proto = o.length ? "DTLS/SCTP" : "RTP/SAVPF" : a.proto = "RTP/AVPF", o.length) {
                n += "m=application ".concat(a.port, " DTLS/SCTP ").concat(o.attr("number"), "\r\n"), n += "a=sctpmap:".concat(o.attr("number"), " ").concat(o.attr("protocol"));
                var s = o.attr("streams");
                n += s ? " ".concat(s, "\r\n") : "\r\n"
            } else a.fmt = t.find("payload-type").map((function() {
                return this.getAttribute("id")
            })).get(), n += "".concat(r.a.buildMLine(a), "\r\n");
            switch (n += "c=IN IP4 0.0.0.0\r\n", o.length || (n += "a=rtcp:1 IN IP4 0.0.0.0\r\n"), (a = e.find('>transport[xmlns="urn:xmpp:jingle:transports:ice-udp:1"]')).length && (a.attr("ufrag") && (n += "".concat(r.a.buildICEUfrag(a.attr("ufrag")), "\r\n")), a.attr("pwd") && (n += "".concat(r.a.buildICEPwd(a.attr("pwd")), "\r\n")), a.find(">fingerprint").each((function() {
                n += "a=fingerprint:".concat(this.getAttribute("hash")), n += " ".concat($(this).text()), n += "\r\n", this.getAttribute("setup") && (n += "a=setup:".concat(this.getAttribute("setup"), "\r\n"))
            }))), e.attr("senders")) {
                case "initiator":
                    n += "a=sendonly\r\n";
                    break;
                case "responder":
                    n += "a=recvonly\r\n";
                    break;
                case "none":
                    n += "a=inactive\r\n";
                    break;
                case "both":
                    n += "a=sendrecv\r\n"
            }
            return n += "a=mid:".concat(e.attr("name"), "\r\n"), t.find("rtcp-mux").length && (n += "a=rtcp-mux\r\n"), t.find("encryption").length && t.find("encryption>crypto").each((function() {
                n += "a=crypto:".concat(this.getAttribute("tag")), n += " ".concat(this.getAttribute("crypto-suite")), n += " ".concat(this.getAttribute("key-params")), this.getAttribute("session-params") && (n += " ".concat(this.getAttribute("session-params"))), n += "\r\n"
            })), t.find("payload-type").each((function() {
                n += "".concat(r.a.buildRTPMap(this), "\r\n"), $(this).find(">parameter").length && (n += "a=fmtp:".concat(this.getAttribute("id"), " "), n += $(this).find("parameter").map((function() {
                    var e = this.getAttribute("name");
                    return (e ? "".concat(e, "=") : "") + this.getAttribute("value")
                })).get().join("; "), n += "\r\n"), n += i.rtcpFbFromJingle($(this), this.getAttribute("id"))
            })), n += i.rtcpFbFromJingle(t, "*"), (a = t.find('>rtp-hdrext[xmlns="urn:xmpp:jingle:apps:rtp:rtp-hdrext:0"]')).each((function() {
                n += "a=extmap:".concat(this.getAttribute("id"), " ").concat(this.getAttribute("uri"), "\r\n")
            })), e.find('>transport[xmlns="urn:xmpp:jingle:transports:ice-udp:1"]>candidate').each((function() {
                var e = this.getAttribute("protocol");
                e = "string" == typeof e ? e.toLowerCase() : "", i.removeTcpCandidates && ("tcp" === e || "ssltcp" === e) || i.removeUdpCandidates && "udp" === e || (i.failICE && this.setAttribute("ip", "1.1.1.1"), n += r.a.candidateFromJingle(this))
            })), e.find('description>ssrc-group[xmlns="urn:xmpp:jingle:apps:rtp:ssma:0"]').each((function() {
                var e = this.getAttribute("semantics"),
                    t = $(this).find(">source").map((function() {
                        return this.getAttribute("ssrc")
                    })).get();
                t.length && (n += "a=ssrc-group:".concat(e, " ").concat(t.join(" "), "\r\n"))
            })), (a = e.find('description>source[xmlns="urn:xmpp:jingle:apps:rtp:ssma:0"]')).each((function() {
                var e = this.getAttribute("ssrc");
                $(this).find(">parameter").each((function() {
                    var t = this.getAttribute("name"),
                        i = this.getAttribute("value");
                    i = r.a.filterSpecialChars(i), n += "a=ssrc:".concat(e, " ").concat(t), i && i.length && (n += ":".concat(i)), n += "\r\n"
                }))
            })), n
        }
    }, function(e, t, n) {
        "use strict";
        var r = {};
        n.r(r), n.d(r, "CHROME", (function() {
            return a
        })), n.d(r, "OPERA", (function() {
            return s
        })), n.d(r, "FIREFOX", (function() {
            return c
        })), n.d(r, "INTERNET_EXPLORER", (function() {
            return u
        })), n.d(r, "EDGE", (function() {
            return l
        })), n.d(r, "SAFARI", (function() {
            return d
        })), n.d(r, "NWJS", (function() {
            return p
        })), n.d(r, "ELECTRON", (function() {
            return h
        })), n.d(r, "REACT_NATIVE", (function() {
            return f
        })), n.d(r, "UNKNOWN", (function() {
            return m
        }));
        var i = n(46),
            o = n.n(i),
            a = "chrome",
            s = "opera",
            c = "firefox",
            u = "iexplorer",
            l = "edge",
            d = "safari",
            p = "nwjs",
            h = "electron",
            f = "react-native",
            m = "unknown";

        function v(e, t) {
            for (var n = 0; n < t.length; n++) {
                var r = t[n];
                r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
            }
        }
        var y = {
            Chrome: a,
            Chromium: a,
            Opera: s,
            Firefox: c,
            "Internet Explorer": u,
            "Microsoft Edge": l,
            Safari: d
        };

        function g() {
            var e = navigator.userAgent;
            if (e.match(/Electron/)) {
                var t = e.match(/Electron\/([\d.]+)/)[1];
                return {
                    name: h,
                    version: t
                }
            }
        }

        function _() {
            var e = navigator.userAgent;
            if (e.match(/JitsiMeetNW/)) {
                var t = e.match(/JitsiMeetNW\/([\d.]+)/)[1];
                return {
                    name: p,
                    version: t
                }
            }
        }

        function S() {
            var e, t, n = navigator.userAgent.match(/\b(react[ \t_-]*native)(?:\/(\S+))?/i);
            if (n || "ReactNative" === navigator.product) return n && n.length > 2 && (t = n[1], e = n[2]), t || (t = "react-native"), e || (e = "unknown"), {
                name: f,
                version: e
            }
        }

        function b() {
            for (var e, t = [S, g, _], n = 0; n < t.length; n++)
                if (e = t[n]()) return e;
            var r = o.a.name,
                i = o.a.version;
            return r in y ? {
                name: y[r],
                version: i
            } : (e = function() {
                var e = navigator.userAgent;
                if (Boolean(window.chrome) && !e.match(/Edge/) && e.match(/Chrome/)) {
                    var t = e.match(/Chrome\/([\d.]+)/)[1];
                    return {
                        name: a,
                        version: t
                    }
                }
            }()) || {
                name: m,
                version: void 0
            }
        }
        var E, T, C, R = function() {
            function e(t) {
                var n, r;
                if (function(e, t) {
                        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                    }(this, e), void 0 === t) {
                    var i = b();
                    n = i.name, r = i.version
                } else t.name in y ? (n = y[t.name], r = t.version) : (n = m, r = void 0);
                this._name = n, this._version = r
            }
            var t, n, r;
            return t = e, (n = [{
                key: "getName",
                value: function() {
                    return this._name
                }
            }, {
                key: "isChrome",
                value: function() {
                    return this._name === a
                }
            }, {
                key: "isOpera",
                value: function() {
                    return this._name === s
                }
            }, {
                key: "isFirefox",
                value: function() {
                    return this._name === c
                }
            }, {
                key: "isIExplorer",
                value: function() {
                    return this._name === u
                }
            }, {
                key: "isEdge",
                value: function() {
                    return this._name === l
                }
            }, {
                key: "isSafari",
                value: function() {
                    return this._name === d
                }
            }, {
                key: "isNWJS",
                value: function() {
                    return this._name === p
                }
            }, {
                key: "isElectron",
                value: function() {
                    return this._name === h
                }
            }, {
                key: "isReactNative",
                value: function() {
                    return this._name === f
                }
            }, {
                key: "getVersion",
                value: function() {
                    return this._version
                }
            }, {
                key: "compareVersion",
                value: function(e) {
                    if (this._version) return o.a.compareVersions([String(e), this._version])
                }
            }, {
                key: "isVersionGreaterThan",
                value: function(e) {
                    return -1 === this.compareVersion(e)
                }
            }, {
                key: "isVersionLessThan",
                value: function(e) {
                    return 1 === this.compareVersion(e)
                }
            }, {
                key: "isVersionEqualTo",
                value: function(e) {
                    return 0 === this.compareVersion(e)
                }
            }]) && v(t.prototype, n), r && v(t, r), e
        }();
        E = R, T = "compareVersions", C = o.a.compareVersions, T in E ? Object.defineProperty(E, T, {
            value: C,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : E[T] = C;
        n(73);
        n.d(t, "a", (function() {
            return R
        })), n.d(t, "b", (function() {
            return r
        }))
    }, function(e, t, n) {
        "use strict";
        n.r(t), n.d(t, "STATUS_AVAILABLE", (function() {
            return r
        })), n.d(t, "STATUS_UNDEFINED", (function() {
            return i
        })), n.d(t, "STATUS_BUSY", (function() {
            return o
        })), n.d(t, "STATE_ON", (function() {
            return a
        })), n.d(t, "STATE_OFF", (function() {
            return s
        })), n.d(t, "STATE_PENDING", (function() {
            return c
        })), n.d(t, "STATE_RETRYING", (function() {
            return u
        })), n.d(t, "STATE_FAILED", (function() {
            return l
        })), n.d(t, "ERROR_NO_CONNECTION", (function() {
            return d
        })), n.d(t, "ERROR_SESSION_EXISTS", (function() {
            return p
        }));
        var r = "available",
            i = "undefined",
            o = "busy",
            a = "on",
            s = "off",
            c = "pending",
            u = "retrying",
            l = "failed",
            d = "error_no_connection",
            p = "error_session_already_exists"
    }, function(e, t, n) {
        "use strict";
        n.r(t), n.d(t, "CONNECTION_DISCONNECTED", (function() {
            return r
        })), n.d(t, "CONNECTION_ESTABLISHED", (function() {
            return i
        })), n.d(t, "CONNECTION_FAILED", (function() {
            return o
        })), n.d(t, "WRONG_STATE", (function() {
            return a
        }));
        var r = "connection.connectionDisconnected",
            i = "connection.connectionEstablished",
            o = "connection.connectionFailed",
            a = "connection.wrongState"
    }, function(e, t, n) {
        var r = n(139),
            i = n(140);
        t.write = i, t.parse = r.parse, t.parseFmtpConfig = r.parseFmtpConfig, t.parseParams = r.parseParams, t.parsePayloads = r.parsePayloads, t.parseRemoteCandidates = r.parseRemoteCandidates, t.parseImageAttributes = r.parseImageAttributes, t.parseSimulcastStreamList = r.parseSimulcastStreamList
    }, function(e, t, n) {
        "use strict";
        n.d(t, "a", (function() {
            return r
        })), n.d(t, "b", (function() {
            return i
        })), n.d(t, "c", (function() {
            return o
        })), n.d(t, "d", (function() {
            return a
        }));
        var r = "statistics.audioLevel",
            i = "statistics.before_disposed",
            o = "statistics.byte_sent_stats",
            a = "statistics.connectionstats"
    }, function(e, t, n) {
        "use strict";
        n.d(t, "a", (function() {
            return a
        }));
        var r = n(28),
            i = n.n(r);

        function o(e, t) {
            for (var n = 0; n < t.length; n++) {
                var r = t[n];
                r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
            }
        }
        var a = function() {
            function e() {
                var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new i.a;
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this.eventEmitter = t, this.addEventListener = this.on = this.addListener, this.removeEventListener = this.off = this.removeListener
            }
            var t, n, r;
            return t = e, (n = [{
                key: "addListener",
                value: function(e, t) {
                    this.eventEmitter.addListener(e, t)
                }
            }, {
                key: "removeListener",
                value: function(e, t) {
                    this.eventEmitter.removeListener(e, t)
                }
            }]) && o(t.prototype, n), r && o(t, r), e
        }()
    }, function(e, t, n) {
        "use strict";
        n.r(t), n.d(t, "LOCAL_STATS_UPDATED", (function() {
            return r
        })), n.d(t, "REMOTE_STATS_UPDATED", (function() {
            return i
        }));
        var r = "cq.local_stats_updated",
            i = "cq.remote_stats_updated"
    }, function(e, t, n) {
        "use strict";
        n.d(t, "b", (function() {
            return s
        })), n.d(t, "c", (function() {
            return c
        })), n.d(t, "a", (function() {
            return d
        }));
        var r = n(22);

        function i(e, t) {
            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
        }

        function o(e, t) {
            for (var n = 0; n < t.length; n++) {
                var r = t[n];
                r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
            }
        }

        function a(e, t, n) {
            return t && o(e.prototype, t), n && o(e, n), e
        }

        function s(e) {
            return parseInt(e.ssrcs.split(" ")[0], 10)
        }

        function c(e) {
            return parseInt(e.ssrcs.split(" ")[1], 10)
        }

        function u(e) {
            return e.ssrcs ? e.ssrcs.map((function(e) {
                return e.id
            })).filter((function(e, t, n) {
                return n.indexOf(e) === t
            })).length : 0
        }
        var l = function() {
                function e(t) {
                    if (i(this, e), !t) throw new Error("mLine is undefined");
                    this.mLine = t
                }
                return a(e, [{
                    key: "getSSRCAttrValue",
                    value: function(e, t) {
                        var n = this.ssrcs.find((function(n) {
                            return n.id === e && n.attribute === t
                        }));
                        return n && n.value
                    }
                }, {
                    key: "removeSSRC",
                    value: function(e) {
                        this.mLine.ssrcs && this.mLine.ssrcs.length && (this.mLine.ssrcs = this.mLine.ssrcs.filter((function(t) {
                            return t.id !== e
                        })))
                    }
                }, {
                    key: "addSSRCAttribute",
                    value: function(e) {
                        this.ssrcs.push(e)
                    }
                }, {
                    key: "findGroup",
                    value: function(e, t) {
                        return this.ssrcGroups.find((function(n) {
                            return n.semantics === e && (!t || t === n.ssrcs)
                        }))
                    }
                }, {
                    key: "findGroups",
                    value: function(e) {
                        return this.ssrcGroups.filter((function(t) {
                            return t.semantics === e
                        }))
                    }
                }, {
                    key: "findGroupByPrimarySSRC",
                    value: function(e, t) {
                        return this.ssrcGroups.find((function(n) {
                            return n.semantics === e && s(n) === t
                        }))
                    }
                }, {
                    key: "findSSRCByMSID",
                    value: function(e) {
                        return this.ssrcs.find((function(t) {
                            return "msid" === t.attribute && (null === e || t.value === e)
                        }))
                    }
                }, {
                    key: "getSSRCCount",
                    value: function() {
                        return u(this.mLine)
                    }
                }, {
                    key: "containsAnySSRCGroups",
                    value: function() {
                        return void 0 !== this.mLine.ssrcGroups
                    }
                }, {
                    key: "getPrimaryVideoSsrc",
                    value: function() {
                        var e = this.mLine.type;
                        if ("video" !== e) throw new Error("getPrimarySsrc doesn't work with '".concat(e, "'"));
                        if (1 === u(this.mLine)) return this.mLine.ssrcs[0].id;
                        if (this.mLine.ssrcGroups) {
                            var t = this.findGroup("SIM");
                            if (t) return s(t);
                            var n = this.findGroup("FID");
                            if (n) return s(n);
                            var r = this.findGroup("FEC-FR");
                            if (r) return s(r)
                        }
                    }
                }, {
                    key: "getRtxSSRC",
                    value: function(e) {
                        var t = this.findGroupByPrimarySSRC("FID", e);
                        return t && c(t)
                    }
                }, {
                    key: "getSSRCs",
                    value: function() {
                        return this.ssrcs.map((function(e) {
                            return e.id
                        })).filter((function(e, t, n) {
                            return n.indexOf(e) === t
                        }))
                    }
                }, {
                    key: "getPrimaryVideoSSRCs",
                    value: function() {
                        var e = this.mLine.type;
                        if ("video" !== e) throw new Error("getPrimaryVideoSSRCs doesn't work with ".concat(e));
                        var t = this.getSSRCs(),
                            n = !0,
                            r = !1,
                            i = void 0;
                        try {
                            for (var o, a = this.ssrcGroups[Symbol.iterator](); !(n = (o = a.next()).done); n = !0) {
                                var s = o.value;
                                if ("FID" === s.semantics || "FEC-FR" === s.semantics) {
                                    var u = c(s);
                                    t.splice(t.indexOf(u), 1)
                                }
                            }
                        } catch (e) {
                            r = !0, i = e
                        } finally {
                            try {
                                n || null == a.return || a.return()
                            } finally {
                                if (r) throw i
                            }
                        }
                        return t
                    }
                }, {
                    key: "dumpSSRCGroups",
                    value: function() {
                        return JSON.stringify(this.mLine.ssrcGroups)
                    }
                }, {
                    key: "removeGroupsWithSSRC",
                    value: function(e) {
                        this.mLine.ssrcGroups && (this.mLine.ssrcGroups = this.mLine.ssrcGroups.filter((function(t) {
                            return -1 === t.ssrcs.indexOf("".concat(e))
                        })))
                    }
                }, {
                    key: "removeGroupsBySemantics",
                    value: function(e) {
                        this.mLine.ssrcGroups && (this.mLine.ssrcGroups = this.mLine.ssrcGroups.filter((function(t) {
                            return t.semantics !== e
                        })))
                    }
                }, {
                    key: "replaceSSRC",
                    value: function(e, t) {
                        this.mLine.ssrcs && this.mLine.ssrcs.forEach((function(n) {
                            n.id === e && (n.id = t)
                        }))
                    }
                }, {
                    key: "addSSRCGroup",
                    value: function(e) {
                        this.ssrcGroups.push(e)
                    }
                }, {
                    key: "ssrcs",
                    get: function() {
                        return this.mLine.ssrcs || (this.mLine.ssrcs = []), this.mLine.ssrcs
                    },
                    set: function(e) {
                        this.mLine.ssrcs = e
                    }
                }, {
                    key: "direction",
                    get: function() {
                        return this.mLine.direction
                    },
                    set: function(e) {
                        this.mLine.direction = e
                    }
                }, {
                    key: "ssrcGroups",
                    get: function() {
                        return this.mLine.ssrcGroups || (this.mLine.ssrcGroups = []), this.mLine.ssrcGroups
                    },
                    set: function(e) {
                        this.mLine.ssrcGroups = e
                    }
                }]), e
            }(),
            d = function() {
                function e(t) {
                    i(this, e), this.parsedSDP = r.parse(t)
                }
                return a(e, [{
                    key: "selectMedia",
                    value: function(e) {
                        var t = this.parsedSDP.media.find((function(t) {
                            return t.type === e
                        }));
                        return t ? new l(t) : null
                    }
                }, {
                    key: "toRawSDP",
                    value: function() {
                        return r.write(this.parsedSDP)
                    }
                }]), e
            }()
    }, function(e, t, n) {
        "use strict";
        n.d(t, "a", (function() {
            return r
        }));
        var r = {
            ACCEPT: "session-accept",
            CONNECTION_ERROR: "connection-error-encountered",
            INITIATE: "session-initiate",
            TERMINATE: "session-terminate",
            TRANSPORT_INFO: "transport-info",
            UNAVAILABLE: "unavailable"
        }
    }, function(e, t, n) {
        "use strict";

        function r(e) {
            return (r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                return typeof e
            } : function(e) {
                return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
            })(e)
        }
        var i, o = "object" === ("undefined" == typeof Reflect ? "undefined" : r(Reflect)) ? Reflect : null,
            a = o && "function" == typeof o.apply ? o.apply : function(e, t, n) {
                return Function.prototype.apply.call(e, t, n)
            };
        i = o && "function" == typeof o.ownKeys ? o.ownKeys : Object.getOwnPropertySymbols ? function(e) {
            return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e))
        } : function(e) {
            return Object.getOwnPropertyNames(e)
        };
        var s = Number.isNaN || function(e) {
            return e != e
        };

        function c() {
            c.init.call(this)
        }
        e.exports = c, c.EventEmitter = c, c.prototype._events = void 0, c.prototype._eventsCount = 0, c.prototype._maxListeners = void 0;
        var u = 10;

        function l(e) {
            return void 0 === e._maxListeners ? c.defaultMaxListeners : e._maxListeners
        }

        function d(e, t, n, i) {
            var o, a, s, c;
            if ("function" != typeof n) throw new TypeError('The "listener" argument must be of type Function. Received type ' + r(n));
            if (void 0 === (a = e._events) ? (a = e._events = Object.create(null), e._eventsCount = 0) : (void 0 !== a.newListener && (e.emit("newListener", t, n.listener ? n.listener : n), a = e._events), s = a[t]), void 0 === s) s = a[t] = n, ++e._eventsCount;
            else if ("function" == typeof s ? s = a[t] = i ? [n, s] : [s, n] : i ? s.unshift(n) : s.push(n), (o = l(e)) > 0 && s.length > o && !s.warned) {
                s.warned = !0;
                var u = new Error("Possible EventEmitter memory leak detected. " + s.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
                u.name = "MaxListenersExceededWarning", u.emitter = e, u.type = t, u.count = s.length, c = u, console && console.warn && console.warn(c)
            }
            return e
        }

        function p() {
            for (var e = [], t = 0; t < arguments.length; t++) e.push(arguments[t]);
            this.fired || (this.target.removeListener(this.type, this.wrapFn), this.fired = !0, a(this.listener, this.target, e))
        }

        function h(e, t, n) {
            var r = {
                    fired: !1,
                    wrapFn: void 0,
                    target: e,
                    type: t,
                    listener: n
                },
                i = p.bind(r);
            return i.listener = n, r.wrapFn = i, i
        }

        function f(e, t, n) {
            var r = e._events;
            if (void 0 === r) return [];
            var i = r[t];
            return void 0 === i ? [] : "function" == typeof i ? n ? [i.listener || i] : [i] : n ? function(e) {
                for (var t = new Array(e.length), n = 0; n < t.length; ++n) t[n] = e[n].listener || e[n];
                return t
            }(i) : v(i, i.length)
        }

        function m(e) {
            var t = this._events;
            if (void 0 !== t) {
                var n = t[e];
                if ("function" == typeof n) return 1;
                if (void 0 !== n) return n.length
            }
            return 0
        }

        function v(e, t) {
            for (var n = new Array(t), r = 0; r < t; ++r) n[r] = e[r];
            return n
        }
        Object.defineProperty(c, "defaultMaxListeners", {
            enumerable: !0,
            get: function() {
                return u
            },
            set: function(e) {
                if ("number" != typeof e || e < 0 || s(e)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e + ".");
                u = e
            }
        }), c.init = function() {
            void 0 !== this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0
        }, c.prototype.setMaxListeners = function(e) {
            if ("number" != typeof e || e < 0 || s(e)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + ".");
            return this._maxListeners = e, this
        }, c.prototype.getMaxListeners = function() {
            return l(this)
        }, c.prototype.emit = function(e) {
            for (var t = [], n = 1; n < arguments.length; n++) t.push(arguments[n]);
            var r = "error" === e,
                i = this._events;
            if (void 0 !== i) r = r && void 0 === i.error;
            else if (!r) return !1;
            if (r) {
                var o;
                if (t.length > 0 && (o = t[0]), o instanceof Error) throw o;
                var s = new Error("Unhandled error." + (o ? " (" + o.message + ")" : ""));
                throw s.context = o, s
            }
            var c = i[e];
            if (void 0 === c) return !1;
            if ("function" == typeof c) a(c, this, t);
            else {
                var u = c.length,
                    l = v(c, u);
                for (n = 0; n < u; ++n) a(l[n], this, t)
            }
            return !0
        }, c.prototype.addListener = function(e, t) {
            return d(this, e, t, !1)
        }, c.prototype.on = c.prototype.addListener, c.prototype.prependListener = function(e, t) {
            return d(this, e, t, !0)
        }, c.prototype.once = function(e, t) {
            if ("function" != typeof t) throw new TypeError('The "listener" argument must be of type Function. Received type ' + r(t));
            return this.on(e, h(this, e, t)), this
        }, c.prototype.prependOnceListener = function(e, t) {
            if ("function" != typeof t) throw new TypeError('The "listener" argument must be of type Function. Received type ' + r(t));
            return this.prependListener(e, h(this, e, t)), this
        }, c.prototype.removeListener = function(e, t) {
            var n, i, o, a, s;
            if ("function" != typeof t) throw new TypeError('The "listener" argument must be of type Function. Received type ' + r(t));
            if (void 0 === (i = this._events)) return this;
            if (void 0 === (n = i[e])) return this;
            if (n === t || n.listener === t) 0 == --this._eventsCount ? this._events = Object.create(null) : (delete i[e], i.removeListener && this.emit("removeListener", e, n.listener || t));
            else if ("function" != typeof n) {
                for (o = -1, a = n.length - 1; a >= 0; a--)
                    if (n[a] === t || n[a].listener === t) {
                        s = n[a].listener, o = a;
                        break
                    } if (o < 0) return this;
                0 === o ? n.shift() : function(e, t) {
                    for (; t + 1 < e.length; t++) e[t] = e[t + 1];
                    e.pop()
                }(n, o), 1 === n.length && (i[e] = n[0]), void 0 !== i.removeListener && this.emit("removeListener", e, s || t)
            }
            return this
        }, c.prototype.off = c.prototype.removeListener, c.prototype.removeAllListeners = function(e) {
            var t, n, r;
            if (void 0 === (n = this._events)) return this;
            if (void 0 === n.removeListener) return 0 === arguments.length ? (this._events = Object.create(null), this._eventsCount = 0) : void 0 !== n[e] && (0 == --this._eventsCount ? this._events = Object.create(null) : delete n[e]), this;
            if (0 === arguments.length) {
                var i, o = Object.keys(n);
                for (r = 0; r < o.length; ++r) "removeListener" !== (i = o[r]) && this.removeAllListeners(i);
                return this.removeAllListeners("removeListener"), this._events = Object.create(null), this._eventsCount = 0, this
            }
            if ("function" == typeof(t = n[e])) this.removeListener(e, t);
            else if (void 0 !== t)
                for (r = t.length - 1; r >= 0; r--) this.removeListener(e, t[r]);
            return this
        }, c.prototype.listeners = function(e) {
            return f(this, e, !0)
        }, c.prototype.rawListeners = function(e) {
            return f(this, e, !1)
        }, c.listenerCount = function(e, t) {
            return "function" == typeof e.listenerCount ? e.listenerCount(t) : m.call(e, t)
        }, c.prototype.listenerCount = m, c.prototype.eventNames = function() {
            return this._eventsCount > 0 ? i(this._events) : []
        }
    }, function(e, t) {
        e.exports = {
            1080: {
                width: 1920,
                height: 1080,
                order: 8
            },
            fullhd: {
                width: 1920,
                height: 1080,
                order: 8
            },
            720: {
                width: 1280,
                height: 720,
                order: 7
            },
            hd: {
                width: 1280,
                height: 720,
                order: 7
            },
            960: {
                width: 960,
                height: 720,
                order: 6
            },
            540: {
                width: 960,
                height: 540,
                order: 5
            },
            qhd: {
                width: 960,
                height: 540,
                order: 5
            },
            360: {
                width: 640,
                height: 360,
                order: 4
            },
            640: {
                width: 640,
                height: 480,
                order: 3
            },
            vga: {
                width: 640,
                height: 480,
                order: 3
            },
            180: {
                width: 320,
                height: 180,
                order: 2
            },
            320: {
                width: 320,
                height: 240,
                order: 1
            }
        }
    }, function(e, t, n) {
        "use strict";
        n.d(t, "c", (function() {
            return r
        })), n.d(t, "a", (function() {
            return i
        })), n.d(t, "b", (function() {
            return o
        }));
        var r = "pending",
            i = "active",
            o = "ended"
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return D
            }));
            var r = n(3),
                i = n(11),
                o = n.n(i);

            function a(e, t) {
                for (var n = 0; n < t.length; n++) {
                    var r = t[n];
                    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                }
            }

            function s(e, t, n) {
                return t && a(e.prototype, t), n && a(e, n), e
            }
            var c, u = n(4).getLogger(e),
                l = "createOffer",
                d = "createAnswer",
                p = "setLocalDescription",
                h = "setRemoteDescription",
                f = "addIceCandidate",
                m = "getUserMedia",
                v = "iceConnectionFailure",
                y = "applicationLog",
                g = "fabricHold",
                _ = "fabricResume",
                S = "audioMute",
                b = "audioUnmute",
                E = "videoPause",
                T = "videoResume",
                C = "screenShareStart",
                R = "screenShareStop",
                A = "dominantSpeaker",
                w = "activeDeviceList",
                k = "jitsi",
                O = "error",
                I = "event",
                P = "mstWithUserID",
                D = function() {
                    function e(t, n) {
                        ! function(e, t) {
                            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                        }(this, e), this.confID = n.confID, this.tpc = t, this.peerconnection = t.peerconnection, this.remoteUserID = n.remoteUserID || k, this.hasFabric = !1, e.fabrics.add(this), e.backendInitialized && (this._addNewFabric(), 1 === e.fabrics.size && e._emptyReportQueue(this))
                    }
                    return s(e, null, [{
                        key: "_addNewFabricCallback",
                        value: function(t, n) {
                            e.backend && "success" !== t && u.error("Monitoring status: ".concat(t, " msg: ").concat(n))
                        }
                    }, {
                        key: "_initCallback",
                        value: function(t, n) {
                            if (u.log("CallStats Status: err=".concat(t, " msg=").concat(n)), "success" === t) {
                                e.backendInitialized = !0;
                                var r = !1,
                                    i = null,
                                    o = !0,
                                    a = !1,
                                    s = void 0;
                                try {
                                    for (var c, l = e.fabrics.values()[Symbol.iterator](); !(o = (c = l.next()).done); o = !0) {
                                        var d = c.value;
                                        d.hasFabric || (u.debug("addNewFabric - initCallback"), d._addNewFabric() && (r = !0, i || (i = d)))
                                    }
                                } catch (e) {
                                    a = !0, s = e
                                } finally {
                                    try {
                                        o || null == l.return || l.return()
                                    } finally {
                                        if (a) throw s
                                    }
                                }
                                r && e._emptyReportQueue(i)
                            }
                        }
                    }, {
                        key: "_emptyReportQueue",
                        value: function(t) {
                            var n = t.confID,
                                r = t.peerconnection,
                                i = !0,
                                o = !1,
                                a = void 0;
                            try {
                                for (var s, c = e.reportsQueue[Symbol.iterator](); !(i = (s = c.next()).done); i = !0) {
                                    var u = s.value;
                                    if (u.type === O) {
                                        var l = u.data;
                                        e._reportError(t, l.type, l.error, l.pc || r)
                                    } else if (u.type === I) {
                                        var d = u.data;
                                        e.backend.sendFabricEvent(u.pc || r, d.event, n, d.eventData)
                                    } else if (u.type === P) {
                                        var p = u.data;
                                        e.backend.associateMstWithUserID(u.pc || r, p.callStatsId, n, p.ssrc, p.usageLabel, p.containerId)
                                    }
                                }
                            } catch (e) {
                                o = !0, a = e
                            } finally {
                                try {
                                    i || null == c.return || c.return()
                                } finally {
                                    if (o) throw a
                                }
                            }
                            e.reportsQueue.length = 0
                        }
                    }, {
                        key: "_reportError",
                        value: function(t, n, r, i) {
                            var o = r;
                            o || (u.warn("No error is passed!"), o = new Error("Unknown error")), e.backendInitialized && t ? e.backend.reportError(i, t.confID, n, o) : e.reportsQueue.push({
                                type: O,
                                data: {
                                    error: o,
                                    pc: i,
                                    type: n
                                }
                            })
                        }
                    }, {
                        key: "_reportEvent",
                        value: function(t, n, r) {
                            var i = t && t.peerconnection,
                                o = t && t.confID;
                            e.backendInitialized && t ? e.backend.sendFabricEvent(i, n, o, r) : e.reportsQueue.push({
                                confID: o,
                                pc: i,
                                type: I,
                                data: {
                                    event: n,
                                    eventData: r
                                }
                            })
                        }
                    }, {
                        key: "_traceAndCatchBackendCalls",
                        value: function(e) {
                            for (var t = ["associateMstWithUserID", "sendFabricEvent", "sendUserFeedback"], n = function() {
                                    var n = t[i],
                                        r = e[n];
                                    e[n] = function() {
                                        try {
                                            for (var t = arguments.length, n = new Array(t), i = 0; i < t; i++) n[i] = arguments[i];
                                            return r.apply(e, n)
                                        } catch (e) {
                                            o.a.callErrorHandler(e)
                                        }
                                    }
                                }, i = 0; i < t.length; i++) n();
                            for (var a = ["associateMstWithUserID", "sendFabricEvent", "sendUserFeedback"], s = function() {
                                    var t = a[c],
                                        n = e[t];
                                    e[t] = function() {
                                        for (var r = arguments.length, i = new Array(r), o = 0; o < r; o++) i[o] = arguments[o];
                                        u.debug(t, i), n.apply(e, i)
                                    }
                                }, c = 0; c < a.length; c++) s();
                            var l = e.reportError;
                            e.reportError = function(t, n, i) {
                                for (var a = arguments.length, s = new Array(a > 3 ? a - 3 : 0), c = 3; c < a; c++) s[c - 3] = arguments[c];
                                i === y ? r.a.isReactNative() || console && console.debug("reportError", t, n, i) : u.debug.apply(u, ["reportError", t, n, i].concat(s));
                                try {
                                    l.call.apply(l, [e, t, n, i].concat(s))
                                } catch (e) {
                                    i === y ? console && console.error("reportError", e) : o.a.callErrorHandler(e)
                                }
                            }
                        }
                    }, {
                        key: "initBackend",
                        value: function(t) {
                            if (e.backend) throw new Error("CallStats backend has been initialized already!");
                            try {
                                var n, i = callstats;
                                if (e.backend = new i, e._traceAndCatchBackendCalls(e.backend), e.userID = {
                                        aliasName: t.aliasName,
                                        userName: t.userName
                                    }, e.callStatsID = t.callStatsID, e.callStatsSecret = t.callStatsSecret, t.applicationName && (n = {
                                        applicationVersion: "".concat(t.applicationName, " (").concat(r.a.getName(), ")")
                                    }), t.confID) {
                                    var a = t.confID.match(/.*\/(.*)\/.*/);
                                    n.siteID = a && a[1] || "/"
                                }
                                e.backend.initialize(e.callStatsID, e.callStatsSecret, e.userID, e._initCallback, void 0, n);
                                var s = t.getWiFiStatsMethod;
                                return s && (e.backend.attachWifiStatsHandler(s), s().then((function(e) {
                                    e && u.info("Reported wifi addresses:", JSON.parse(e).addresses)
                                })).catch((function() {}))), !0
                            } catch (t) {
                                return o.a.callErrorHandler(t), e.backend = null, u.error(t), !1
                            }
                        }
                    }, {
                        key: "isBackendInitialized",
                        value: function() {
                            return Boolean(e.backend)
                        }
                    }, {
                        key: "sendActiveDeviceListEvent",
                        value: function(t, n) {
                            e._reportEvent(n, w, t)
                        }
                    }, {
                        key: "sendApplicationLog",
                        value: function(t, n) {
                            try {
                                e._reportError(n, y, t, n && n.peerconnection)
                            } catch (e) {
                                console && "function" == typeof console.error && console.error("sendApplicationLog failed", e)
                            }
                        }
                    }, {
                        key: "sendFeedback",
                        value: function(t, n, r) {
                            return new Promise((function(i, o) {
                                if (e.backend) e.backend.sendUserFeedback(t, {
                                    userID: e.userID,
                                    overall: n,
                                    comment: r
                                }, (function(e, t) {
                                    "success" === e ? i(t) : o(t)
                                }));
                                else {
                                    var a = "Failed to submit feedback to CallStats - no backend";
                                    u.error(a), o(a)
                                }
                            }))
                        }
                    }, {
                        key: "sendGetUserMediaFailed",
                        value: function(t, n) {
                            e._reportError(n, m, t, null)
                        }
                    }, {
                        key: "sendMuteEvent",
                        value: function(t, n, r) {
                            var i;
                            i = "video" === n ? t ? E : T : t ? S : b, e._reportEvent(r, i)
                        }
                    }, {
                        key: "fabrics",
                        get: function() {
                            return c || (c = new Set), c
                        }
                    }]), s(e, [{
                        key: "_addNewFabric",
                        value: function() {
                            u.info("addNewFabric", this.remoteUserID);
                            try {
                                var t = {
                                        remoteEndpointType: this.tpc.isP2P ? e.backend.endpointType.peer : e.backend.endpointType.server
                                    },
                                    n = e.backend.addNewFabric(this.peerconnection, this.remoteUserID, e.backend.fabricUsage.multiplex, this.confID, t, e._addNewFabricCallback);
                                this.hasFabric = !0;
                                var r = "success" === n.status;
                                return r || u.error("callstats fabric not initilized", n.message), r
                            } catch (e) {
                                return o.a.callErrorHandler(e), !1
                            }
                        }
                    }, {
                        key: "associateStreamWithVideoTag",
                        value: function(t, n, r, i, o) {
                            if (e.backend) {
                                var a = n ? e.userID : r;
                                e.backendInitialized ? e.backend.associateMstWithUserID(this.peerconnection, a, this.confID, t, i, o) : e.reportsQueue.push({
                                    type: P,
                                    pc: this.peerconnection,
                                    data: {
                                        callStatsId: a,
                                        containerId: o,
                                        ssrc: t,
                                        usageLabel: i
                                    }
                                })
                            }
                        }
                    }, {
                        key: "sendDominantSpeakerEvent",
                        value: function() {
                            e._reportEvent(this, A)
                        }
                    }, {
                        key: "sendTerminateEvent",
                        value: function() {
                            e.backendInitialized && e.backend.sendFabricEvent(this.peerconnection, e.backend.fabricEvent.fabricTerminated, this.confID), e.fabrics.delete(this)
                        }
                    }, {
                        key: "sendIceConnectionFailedEvent",
                        value: function() {
                            e._reportError(this, v, null, this.peerconnection)
                        }
                    }, {
                        key: "sendCreateOfferFailed",
                        value: function(t) {
                            e._reportError(this, l, t, this.peerconnection)
                        }
                    }, {
                        key: "sendCreateAnswerFailed",
                        value: function(t) {
                            e._reportError(this, d, t, this.peerconnection)
                        }
                    }, {
                        key: "sendResumeOrHoldEvent",
                        value: function(t) {
                            e._reportEvent(this, t ? _ : g)
                        }
                    }, {
                        key: "sendScreenSharingEvent",
                        value: function(t, n) {
                            var r;
                            n && (r = {
                                ssrc: n
                            }), e._reportEvent(this, t ? C : R, r)
                        }
                    }, {
                        key: "sendSetLocalDescFailed",
                        value: function(t) {
                            e._reportError(this, p, t, this.peerconnection)
                        }
                    }, {
                        key: "sendSetRemoteDescFailed",
                        value: function(t) {
                            e._reportError(this, h, t, this.peerconnection)
                        }
                    }, {
                        key: "sendAddIceCandidateFailed",
                        value: function(t) {
                            e._reportError(this, f, t, this.peerconnection)
                        }
                    }]), e
                }();
            D.backend = null, D.reportsQueue = [], D.backendInitialized = !1, D.callStatsID = null, D.callStatsSecret = null, D.userID = null
        }).call(this, "modules/statistics/CallStats.js")
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            var r, i, o = n(4),
                a = n(80),
                s = n.n(a),
                c = Object(o.getLogger)(e);

            function u() {
                var e;
                try {
                    e = (window || this).localStorage
                } catch (e) {
                    c.error(e)
                }
                return e
            }

            function l() {
                return "".concat(Math.random().toString(16), "000000000").substr(2, 8)
            }
            t.a = {
                get callStatsUserName() {
                    if (!r) {
                        var e = u();
                        e && (r = e.getItem("callStatsUserName")), r || (t = s.a.generateUsername(), c.log("generated callstats uid", t), r = t, e && e.setItem("callStatsUserName", r))
                    }
                    var t;
                    return r
                },
                get machineId() {
                    if (!i) {
                        var e = u();
                        e && (i = e.getItem("jitsiMeetId")), i || (t = l() + l() + l() + l(), c.log("generated id", t), i = t, e && e.setItem("jitsiMeetId", i))
                    }
                    var t;
                    return i
                },
                get sessionId() {
                    var e = u();
                    return e ? e.getItem("sessionId") : void 0
                },
                set sessionId(e) {
                    var t = u();
                    t && (e ? t.setItem("sessionId", e) : t.removeItem("sessionId"))
                }
            }
        }).call(this, "modules/settings/Settings.js")
    }, function(e, t) {
        var n = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";

        function r(e, t) {
            return Math.floor(Math.random() * (t - e + 1)) + e
        }

        function i(e) {
            return e[r(0, e.length - 1)]
        }
        var o = {
            randomHexDigit: function() {
                return i("0123456789abcdef")
            },
            randomHexString: function(e) {
                for (var t = ""; e--;) t += this.randomHexDigit();
                return t
            },
            randomElement: i,
            randomAlphanumStr: function(e) {
                for (var t = "", r = 0; r < e; r += 1) t += i(n);
                return t
            },
            randomInt: r
        };
        e.exports = o
    }, function(e, t, n) {
        "use strict";
        n.d(t, "a", (function() {
            return d
        }));
        var r = n(24);

        function i(e) {
            return (i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                return typeof e
            } : function(e) {
                return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
            })(e)
        }

        function o(e, t) {
            for (var n = 0; n < t.length; n++) {
                var r = t[n];
                r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
            }
        }

        function a(e, t) {
            return !t || "object" !== i(t) && "function" != typeof t ? function(e) {
                if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return e
            }(e) : t
        }

        function s(e) {
            return (s = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
                return e.__proto__ || Object.getPrototypeOf(e)
            })(e)
        }

        function c(e, t) {
            return (c = Object.setPrototypeOf || function(e, t) {
                return e.__proto__ = t, e
            })(e, t)
        }

        function u(e, t) {
            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
        }

        function l() {
            return function(e) {
                function t() {
                    var e, n;
                    u(this, t);
                    for (var r = arguments.length, i = new Array(r), o = 0; o < r; o++) i[o] = arguments[o];
                    return (n = a(this, (e = s(t)).call.apply(e, [this].concat(i)))).connection = null, n
                }
                var n, r, i;
                return function(e, t) {
                    if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
                    e.prototype = Object.create(t && t.prototype, {
                        constructor: {
                            value: e,
                            writable: !0,
                            configurable: !0
                        }
                    }), t && c(e, t)
                }(t, e), n = t, (r = [{
                    key: "init",
                    value: function(e) {
                        this.connection = e
                    }
                }]) && o(n.prototype, r), i && o(n, i), t
            }(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : function() {
                return function e() {
                    u(this, e)
                }
            }())
        }
        t.b = l();
        var d = l(r.a)
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return O
            })), n.d(t, "b", (function() {
                return I
            })), n.d(t, "c", (function() {
                return P
            }));
            var r = n(4),
                i = n(1),
                o = (n(125), n(33)),
                a = n.n(o),
                s = n(36),
                c = n(21),
                u = n(3),
                l = n(77),
                d = n(81),
                p = n(88),
                h = n(89),
                f = n(90),
                m = n(91),
                v = n(92),
                y = n(24),
                g = n(93),
                _ = n(11),
                S = n.n(_),
                b = n(0),
                E = n.n(b);

            function T(e) {
                return (T = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                    return typeof e
                } : function(e) {
                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                })(e)
            }

            function C(e, t) {
                for (var n = 0; n < t.length; n++) {
                    var r = t[n];
                    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                }
            }

            function R(e) {
                return (R = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
                    return e.__proto__ || Object.getPrototypeOf(e)
                })(e)
            }

            function A(e, t) {
                return (A = Object.setPrototypeOf || function(e, t) {
                    return e.__proto__ = t, e
                })(e, t)
            }

            function w(e) {
                if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return e
            }
            var k = Object(r.getLogger)(e);
            var O = [{
                    urls: "stun:stun.l.google.com:19302"
                }, {
                    urls: "stun:stun1.l.google.com:19302"
                }, {
                    urls: "stun:stun2.l.google.com:19302"
                }],
                I = "type",
                P = function(e) {
                    function t(e, n) {
                        var r;
                        return function(e, t) {
                            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                        }(this, t), (r = function(e, t) {
                            return !t || "object" !== T(t) && "function" != typeof t ? w(e) : t
                        }(this, R(t).call(this))).connection = null, r.disconnectInProgress = !1, r.connectionTimes = {}, r.options = e, r.token = n, r.authenticatedUser = !1, r._initStrophePlugins(w(w(r))), r.connection = function(e) {
                            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "/http-bind";
                            e && (t += "".concat(-1 === t.indexOf("?") ? "?" : "&", "token=").concat(e));
                            var n = new i.Strophe.Connection(t);
                            return n.maxRetries = 3, n
                        }(n, e.bosh), r._lastSuccessTracker = new v.a, r._lastSuccessTracker.startTracking(r.connection), r.caps = new g.a(r.connection, r.options.clientNode), r.initFeaturesList(), $(window).on("beforeunload unload", (function(e) {
                            r.disconnect(e).catch((function() {}))
                        })), r
                    }
                    var n, r, o;
                    return function(e, t) {
                        if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
                        e.prototype = Object.create(t && t.prototype, {
                            constructor: {
                                value: e,
                                writable: !0,
                                configurable: !0
                            }
                        }), t && A(e, t)
                    }(t, e), n = t, (r = [{
                        key: "initFeaturesList",
                        value: function() {
                            this.caps.addFeature("urn:xmpp:jingle:1"), this.caps.addFeature("urn:xmpp:jingle:apps:rtp:1"), this.caps.addFeature("urn:xmpp:jingle:transports:ice-udp:1"), this.caps.addFeature("urn:xmpp:jingle:apps:dtls:0"), this.caps.addFeature("urn:xmpp:jingle:transports:dtls-sctp:1"), this.caps.addFeature("urn:xmpp:jingle:apps:rtp:audio"), this.caps.addFeature("urn:xmpp:jingle:apps:rtp:video"), !this.options.disableRtx && u.a.supportsRtx() && this.caps.addFeature("urn:ietf:rfc:4588"), this.caps.addFeature("urn:ietf:rfc:5761"), this.caps.addFeature("urn:ietf:rfc:5888"), u.a.isChrome() && !1 !== this.options.enableLipSync && (k.info("Lip-sync enabled !"), this.caps.addFeature("http://jitsi.org/meet/lipsync")), this.connection.rayo && this.caps.addFeature("urn:xmpp:rayo:client:1")
                        }
                    }, {
                        key: "isPingSupported",
                        value: function() {
                            return !1 !== this._pingSupported
                        }
                    }, {
                        key: "getConnection",
                        value: function() {
                            return this.connection
                        }
                    }, {
                        key: "connectionHandler",
                        value: function() {
                            var e = this,
                                t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                                n = arguments.length > 1 ? arguments[1] : void 0,
                                r = arguments.length > 2 ? arguments[2] : void 0,
                                o = window.performance.now(),
                                a = i.Strophe.getStatusString(n).toLowerCase();
                            if (this.connectionTimes[a] = o, k.log("(TIME) Strophe ".concat(a).concat(r ? "[".concat(r, "]") : "", ":\t"), o), this.eventEmitter.emit(E.a.CONNECTION_STATUS_CHANGED, t, n, r), n === i.Strophe.Status.CONNECTED || n === i.Strophe.Status.ATTACHED) {
                                (this.options.useStunTurn || this.options.p2p && this.options.p2p.useStunTurn) && this.connection.jingle.getStunAndTurnCredentials(), k.info("My Jabber ID: ".concat(this.connection.jid));
                                var u = this.connection.domain;
                                this.caps.getFeaturesAndIdentities(u).then((function(t) {
                                    var n = t.features,
                                        r = t.identities;
                                    n.has(i.Strophe.NS.PING) ? (e._pingSupported = !0, e.connection.ping.startInterval(u)) : k.warn("Ping NOT supported by ".concat(u)), r.forEach((function(t) {
                                        "speakerstats" === t.type && (e.speakerStatsComponentAddress = t.name, e.connection.addHandler(e._onPrivateMessage.bind(e), null, "message", null, null))
                                    }))
                                })).catch((function(e) {
                                    var t = "Feature discovery error";
                                    S.a.callErrorHandler(new Error("".concat(t, ": ").concat(e))), k.error(t, e)
                                })), t.password && (this.authenticatedUser = !0), this.connection && this.connection.connected && i.Strophe.getResourceFromJid(this.connection.jid) && this.eventEmitter.emit(c.CONNECTION_ESTABLISHED, i.Strophe.getResourceFromJid(this.connection.jid))
                            } else if (n === i.Strophe.Status.CONNFAIL) "x-strophe-bad-non-anon-jid" === r ? this.anonymousConnectionFailed = !0 : this.connectionFailed = !0, this.lastErrorMsg = r, "giving-up" === r && this.eventEmitter.emit(c.CONNECTION_FAILED, s.OTHER_ERROR, r);
                            else if (n === i.Strophe.Status.DISCONNECTED) {
                                this.connection.ping.stopInterval();
                                var l = this.disconnectInProgress,
                                    d = r || this.lastErrorMsg;
                                if (this.disconnectInProgress = !1, this.anonymousConnectionFailed) this.eventEmitter.emit(c.CONNECTION_FAILED, s.PASSWORD_REQUIRED);
                                else if (this.connectionFailed) this.eventEmitter.emit(c.CONNECTION_FAILED, s.OTHER_ERROR, d, void 0, this._getConnectionFailedReasonDetails());
                                else if (l) this.eventEmitter.emit(c.CONNECTION_DISCONNECTED, d);
                                else {
                                    k.error("XMPP connection dropped!");
                                    var p = i.Strophe.getLastErrorStatus();
                                    p >= 500 && p < 600 ? this.eventEmitter.emit(c.CONNECTION_FAILED, s.SERVER_ERROR, d || "server-error", void 0, this._getConnectionFailedReasonDetails()) : this.eventEmitter.emit(c.CONNECTION_FAILED, s.CONNECTION_DROPPED_ERROR, d || "connection-dropped-error", void 0, this._getConnectionFailedReasonDetails())
                                }
                            } else n === i.Strophe.Status.AUTHFAIL && this.eventEmitter.emit(c.CONNECTION_FAILED, s.PASSWORD_REQUIRED, r, t)
                        }
                    }, {
                        key: "_connect",
                        value: function(e, t) {
                            this.anonymousConnectionFailed = !1, this.connectionFailed = !1, this.lastErrorMsg = void 0, this.connection.connect(e, t, this.connectionHandler.bind(this, {
                                jid: e,
                                password: t
                            }))
                        }
                    }, {
                        key: "attach",
                        value: function(e) {
                            var t = this.connectionTimes.attaching = window.performance.now();
                            k.log("(TIME) Strophe Attaching\t:".concat(t)), this.connection.attach(e.jid, e.sid, parseInt(e.rid, 10) + 1, this.connectionHandler.bind(this, {
                                jid: e.jid,
                                password: e.password
                            }))
                        }
                    }, {
                        key: "connect",
                        value: function(e, t) {
                            if (!e) {
                                var n = this.options.hosts,
                                    r = n.anonymousdomain,
                                    i = n.domain,
                                    o = r || i,
                                    a = window.location;
                                if (r) {
                                    var s = a && a.search;
                                    (s && -1 !== s.indexOf("login=true") || this.token) && (o = i)
                                }
                                e = o || a && a.hostname
                            }
                            return this._connect(e, t)
                        }
                    }, {
                        key: "createRoom",
                        value: function(e, t, n) {
                            var r = "".concat(e, "@").concat(this.options.hosts.muc, "/"),
                                i = n ? n(this.connection.jid, this.authenticatedUser) : a.a.randomHexString(8).toLowerCase();
                            return k.info("JID ".concat(this.connection.jid, " using MUC nickname ").concat(i)), r += i, this.connection.emuc.createRoom(r, null, t)
                        }
                    }, {
                        key: "getJid",
                        value: function() {
                            return this.connection.jid
                        }
                    }, {
                        key: "getJingleLog",
                        value: function() {
                            var e = this.connection.jingle;
                            return e ? e.getLog() : {}
                        }
                    }, {
                        key: "getXmppLog",
                        value: function() {
                            return (this.connection.logger || {}).log || null
                        }
                    }, {
                        key: "dial",
                        value: function() {
                            var e;
                            (e = this.connection.rayo).dial.apply(e, arguments)
                        }
                    }, {
                        key: "ping",
                        value: function(e) {
                            var t = this;
                            return new Promise((function(n, r) {
                                t.isPingSupported() ? t.connection.ping.ping(t.connection.domain, n, r, e) : r("PING operation is not supported by the server")
                            }))
                        }
                    }, {
                        key: "getSessions",
                        value: function() {
                            return this.connection.jingle.sessions
                        }
                    }, {
                        key: "disconnect",
                        value: function(e) {
                            var t = this;
                            return this.disconnectInProgress || !this.connection ? (this.eventEmitter.emit(c.WRONG_STATE), Promise.reject(new Error("Wrong connection state!"))) : (this.disconnectInProgress = !0, new Promise((function(n) {
                                if (t.eventEmitter.on(E.a.CONNECTION_STATUS_CHANGED, (function e(r, o) {
                                        o === i.Strophe.Status.DISCONNECTED && (n(), t.eventEmitter.removeListener(E.a.CONNECTION_STATUS_CHANGED, e))
                                    })), t.connection.flush(), null != e) {
                                    var r = e.type;
                                    if (("beforeunload" === r || "unload" === r) && (t.connection.options.sync = !0, navigator.sendBeacon && !t.connection.disconnecting && t.connection.connected)) {
                                        t.connection._changeConnectStatus(i.Strophe.Status.DISCONNECTING), t.connection.disconnecting = !0;
                                        var o = t.connection._proto._buildBody().attrs({
                                                type: "terminate"
                                            }),
                                            a = Object(i.$pres)({
                                                xmlns: i.Strophe.NS.CLIENT,
                                                type: "unavailable"
                                            });
                                        o.cnode(a.tree());
                                        var s = navigator.sendBeacon("https:".concat(t.connection.service), i.Strophe.serialize(o.tree()));
                                        return k.info("Successfully send unavailable beacon ".concat(s)), t.connection._proto._abortAllRequests(), void t.connection._doDisconnect()
                                    }
                                }
                                t.connection.disconnect(), !0 !== t.connection.options.sync && t.connection.flush()
                            })))
                        }
                    }, {
                        key: "_initStrophePlugins",
                        value: function() {
                            var e = {
                                    jvb: {
                                        iceServers: []
                                    },
                                    p2p: {
                                        iceServers: []
                                    }
                                },
                                t = this.options.p2p && this.options.p2p.stunServers || O;
                            Array.isArray(t) && (k.info("P2P STUN servers: ", t), e.p2p.iceServers = t), this.options.p2p && this.options.p2p.iceTransportPolicy && (k.info("P2P ICE transport policy: ", this.options.p2p.iceTransportPolicy), e.p2p.iceTransportPolicy = this.options.p2p.iceTransportPolicy), Object(l.a)(this), Object(d.a)(this, this.eventEmitter, e), Object(p.a)(), Object(h.a)(this), Object(f.a)(), Object(m.a)()
                        }
                    }, {
                        key: "_getConnectionFailedReasonDetails",
                        value: function() {
                            var e = {};
                            if (this.options.deploymentInfo && this.options.deploymentInfo.shard && this.connection._proto && this.connection._proto.lastResponseHeaders) {
                                var t = this.connection._proto.lastResponseHeaders.trim().split(/[\r\n]+/),
                                    n = {};
                                t.forEach((function(e) {
                                    var t = e.split(": "),
                                        r = t.shift(),
                                        i = t.join(": ");
                                    n[r] = i
                                })), e.shard_changed = this.options.deploymentInfo.shard !== n["x-jitsi-shard"]
                            }
                            return e.suspend_time = this.connection.ping.getPingSuspendTime(), e.time_since_last_success = this._lastSuccessTracker.getTimeSinceLastSuccess(), e
                        }
                    }, {
                        key: "sendDominantSpeakerEvent",
                        value: function(e) {
                            if (this.speakerStatsComponentAddress && e) {
                                var t = Object(i.$msg)({
                                    to: this.speakerStatsComponentAddress
                                });
                                t.c("speakerstats", {
                                    xmlns: "http://jitsi.org/jitmeet",
                                    room: e
                                }).up(), this.connection.send(t)
                            }
                        }
                    }, {
                        key: "tryParseJSONAndVerify",
                        value: function(e) {
                            try {
                                var t = JSON.parse(e);
                                if (t && "object" === T(t)) {
                                    var n = t[I];
                                    if (void 0 !== n) return t;
                                    k.debug("parsing valid json but does not have correct structure", "topic: ", n)
                                }
                            } catch (e) {
                                return !1
                            }
                            return !1
                        }
                    }, {
                        key: "_onPrivateMessage",
                        value: function(e) {
                            var t = e.getAttribute("from");
                            if (this.speakerStatsComponentAddress && t === this.speakerStatsComponentAddress) {
                                var n = $(e).find(">json-message").text(),
                                    r = this.tryParseJSONAndVerify(n);
                                return r && "speakerstats" === r[I] && r.users && this.eventEmitter.emit(E.a.SPEAKER_STATS_RECEIVED, r.users), !0
                            }
                        }
                    }]) && C(n.prototype, r), o && C(n, o), t
                }(y.a)
        }).call(this, "modules/xmpp/xmpp.js")
    }, function(e, t, n) {
        "use strict";
        n.r(t), n.d(t, "CONNECTION_DROPPED_ERROR", (function() {
            return r
        })), n.d(t, "OTHER_ERROR", (function() {
            return i
        })), n.d(t, "PASSWORD_REQUIRED", (function() {
            return o
        })), n.d(t, "SERVER_ERROR", (function() {
            return a
        }));
        var r = "connection.droppedError",
            i = "connection.otherError",
            o = "connection.passwordRequired",
            a = "connection.serverError"
    }, function(e, t, n) {
        "use strict";
        n.d(t, "a", (function() {
            return r
        })), n.d(t, "b", (function() {
            return i
        }));
        var r = "signaling.peerMuted",
            i = "signaling.peerVideoType"
    }, function(e, t, n) {
        "use strict";

        function r(e) {
            return (r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                return typeof e
            } : function(e) {
                return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
            })(e)
        }
        var i = !0,
            o = !0,
            a = {
                disableLog: function(e) {
                    return "boolean" != typeof e ? new Error("Argument type: " + r(e) + ". Please use a boolean.") : (i = e, e ? "adapter.js logging disabled" : "adapter.js logging enabled")
                },
                disableWarnings: function(e) {
                    return "boolean" != typeof e ? new Error("Argument type: " + r(e) + ". Please use a boolean.") : (o = !e, "adapter.js deprecation warnings " + (e ? "disabled" : "enabled"))
                },
                log: function() {
                    if ("object" === ("undefined" == typeof window ? "undefined" : r(window))) {
                        if (i) return;
                        "undefined" != typeof console && "function" == typeof console.debug && console.debug.apply(console, arguments)
                    }
                },
                deprecated: function(e, t) {
                    o && console.warn(e + " is deprecated, please use " + t + " instead.")
                },
                extractVersion: function(e, t, n) {
                    var r = e.match(t);
                    return r && r.length >= n && parseInt(r[n], 10)
                },
                detectBrowser: function(e) {
                    var t = e && e.navigator,
                        n = {
                            browser: null,
                            version: null
                        };
                    if (void 0 === e || !e.navigator) return n.browser = "Not a browser.", n;
                    if (t.mozGetUserMedia) n.browser = "firefox", n.version = this.extractVersion(t.userAgent, /Firefox\/(\d+)\./, 1);
                    else if (t.webkitGetUserMedia)
                        if (e.webkitRTCPeerConnection) n.browser = "chrome", n.version = this.extractVersion(t.userAgent, /Chrom(e|ium)\/(\d+)\./, 2);
                        else {
                            if (!t.userAgent.match(/Version\/(\d+).(\d+)/)) return n.browser = "Unsupported webkit-based browser with GUM support but no WebRTC support.", n;
                            n.browser = "safari", n.version = this.extractVersion(t.userAgent, /AppleWebKit\/(\d+)\./, 1)
                        }
                    else if (t.mediaDevices && t.userAgent.match(/Edge\/(\d+).(\d+)$/)) n.browser = "edge", n.version = this.extractVersion(t.userAgent, /Edge\/(\d+).(\d+)$/, 2);
                    else {
                        if (!t.mediaDevices || !t.userAgent.match(/AppleWebKit\/(\d+)\./)) return n.browser = "Not a supported browser.", n;
                        n.browser = "safari", n.version = this.extractVersion(t.userAgent, /AppleWebKit\/(\d+)\./, 1)
                    }
                    return n
                }
            };
        e.exports = {
            log: a.log,
            deprecated: a.deprecated,
            disableLog: a.disableLog,
            disableWarnings: a.disableWarnings,
            extractVersion: a.extractVersion,
            shimCreateObjectURL: a.shimCreateObjectURL,
            detectBrowser: a.detectBrowser.bind(a)
        }
    }, function(e, t) {
        e.exports = {
            ENVIRONMENT: "environment",
            USER: "user"
        }
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            var r = n(15),
                i = n(12),
                o = n(3);

            function a(e, t, n) {
                return t in e ? Object.defineProperty(e, t, {
                    value: n,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : e[t] = n, e
            }
            var s = n(4).getLogger(e),
                c = n(11),
                u = !1,
                l = !1,
                d = null,
                p = {
                    intChromeExtPromise: null,
                    obtainStream: null,
                    init: function() {
                        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {
                                desktopSharingChromeDisabled: !1,
                                desktopSharingChromeExtId: null,
                                desktopSharingFirefoxDisabled: !1
                            },
                            t = arguments.length > 1 ? arguments[1] : void 0;
                        this.options = e, d = t, this.obtainStream = this._createObtainStreamMethod(e), this.obtainStream || s.info("Desktop sharing disabled")
                    },
                    _createObtainStreamMethod: function(e) {
                        var t = this;
                        return o.a.isNWJS() ? function(e, t, n) {
                            window.JitsiMeetNW.obtainDesktopStream(t, (function(e, t) {
                                var o;
                                o = e && "InvalidStateError" === e.name ? new r.a(i.CHROME_EXTENSION_USER_CANCELED) : new r.a(e, t, ["desktop"]), "function" == typeof n && n(o)
                            }))
                        } : o.a.isElectron() ? this.obtainScreenOnElectron : o.a.isChrome() || o.a.isOpera() ? o.a.supportsGetDisplayMedia() && !e.desktopSharingChromeDisabled ? this.obtainScreenFromGetDisplayMedia : e.desktopSharingChromeDisabled || !e.desktopSharingChromeExtId ? null : (s.info("Using Chrome extension for desktop sharing"), this.intChromeExtPromise = function(e) {
                            return function(e) {
                                0 === $("link[rel=chrome-webstore-item]").length && $("head").append('<link rel="chrome-webstore-item">');
                                $("link[rel=chrome-webstore-item]").attr("href", h(e))
                            }(e), new Promise((function(t) {
                                f((function(e, n) {
                                    u = e, l = n, s.info("Chrome extension installed: ".concat(u, " updateRequired: ").concat(l)), t()
                                }), e)
                            }))
                        }(e).then((function() {
                            t.intChromeExtPromise = null
                        })), this.obtainScreenFromExtension) : o.a.isFirefox() ? e.desktopSharingFirefoxDisabled ? null : o.a.supportsGetDisplayMedia() ? this.obtainScreenFromGetDisplayMedia : this.obtainScreenOnFirefox : o.a.isEdge() && o.a.supportsGetDisplayMedia() ? this.obtainScreenFromGetDisplayMedia : (s.log("Screen sharing not supported by the current browser: ", o.a.getName()), null)
                    },
                    isSupported: function() {
                        return null !== this.obtainStream
                    },
                    obtainScreenOnFirefox: function(e, t, n) {
                        ! function(e, t, n) {
                            d(["screen"], e).then((function(e) {
                                return t({
                                    stream: e
                                })
                            }), n)
                        }(e.gumOptions, t, n)
                    },
                    obtainScreenOnElectron: function() {
                        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                            t = arguments.length > 1 ? arguments[1] : void 0,
                            n = arguments.length > 2 ? arguments[2] : void 0;
                        if (window.JitsiMeetScreenObtainer && window.JitsiMeetScreenObtainer.openDesktopPicker) {
                            var o = e.desktopSharingSources,
                                a = e.gumOptions;
                            window.JitsiMeetScreenObtainer.openDesktopPicker({
                                desktopSharingSources: o || this.options.desktopSharingChromeSources
                            }, (function(e, r) {
                                return m({
                                    response: {
                                        streamId: e,
                                        streamType: r
                                    },
                                    gumOptions: a
                                }, t, n)
                            }), (function(e) {
                                return n(new r.a(i.ELECTRON_DESKTOP_PICKER_ERROR, e))
                            }))
                        } else n(new r.a(i.ELECTRON_DESKTOP_PICKER_NOT_FOUND))
                    },
                    obtainScreenFromExtension: function(e, t, n) {
                        var o = this;
                        if (null === this.intChromeExtPromise) {
                            var a = this.options,
                                c = a.desktopSharingChromeExtId,
                                d = a.desktopSharingChromeSources,
                                p = e.gumOptions,
                                h = {
                                    desktopSharingChromeExtId: c,
                                    desktopSharingChromeSources: e.desktopSharingSources || d,
                                    gumOptions: p
                                };
                            u ? function(e, t, n) {
                                var o = e.desktopSharingChromeSources,
                                    a = e.desktopSharingChromeExtId,
                                    c = e.gumOptions;
                                chrome.runtime.sendMessage(a, {
                                    getStream: !0,
                                    sources: o
                                }, (function(e) {
                                    if (e) s.log("Response from extension: ", e), m({
                                        response: e,
                                        gumOptions: c
                                    }, t, n);
                                    else {
                                        var o = chrome.runtime.lastError;
                                        n(o instanceof Error ? o : new r.a(i.CHROME_EXTENSION_GENERIC_ERROR, o))
                                    }
                                }))
                            }(h, t, n) : (l && alert("Jitsi Desktop Streamer requires update. Changes will take effect after next Chrome restart."), this.handleExternalInstall(e, t, n))
                        } else this.intChromeExtPromise.then((function() {
                            o.obtainScreenFromExtension(e, t, n)
                        }))
                    },
                    handleExternalInstall: function(e, t, n, r) {
                        var i = h(this.options);
                        e.listener("waitingForExtension", i), this.checkForChromeExtensionOnInterval(e, t, n, r)
                    },
                    checkForChromeExtensionOnInterval: function(e, t, n) {
                        var o = this;
                        !1 !== e.checkAgain() ? function(e, t, n) {
                            if (0 === n) return Promise.reject();
                            return new Promise((function(r, i) {
                                var o = n,
                                    a = window.setInterval((function() {
                                        f((function(e) {
                                            e ? (window.clearInterval(a), r()) : 0 === --o && (i(), window.clearInterval(a))
                                        }), e)
                                    }), t)
                            }))
                        }(this.options, e.interval, 1).then((function() {
                            u = !0, e.listener("extensionFound"), o.obtainScreenFromExtension(e, t, n)
                        })).catch((function() {
                            o.checkForChromeExtensionOnInterval(e, t, n)
                        })) : n(new r.a(i.CHROME_EXTENSION_INSTALLATION_ERROR))
                    },
                    obtainScreenFromGetDisplayMedia: function(e, t, n) {
                        s.info("Using getDisplayMedia for screen sharing"), (navigator.getDisplayMedia ? navigator.getDisplayMedia.bind(navigator) : navigator.mediaDevices.getDisplayMedia.bind(navigator.mediaDevices))({
                            video: !0
                        }).then((function(n) {
                            (n && n.getTracks() && n.getTracks().length > 0 ? n.getTracks()[0].applyConstraints(e.trackOptions) : Promise.resolve()).then((function() {
                                return t({
                                    stream: n,
                                    sourceId: n.id
                                })
                            }))
                        })).catch((function() {
                            return n(new r.a(i.CHROME_EXTENSION_USER_CANCELED))
                        }))
                    }
                };

            function h(e) {
                return "https://chrome.google.com/webstore/detail/".concat(e.desktopSharingChromeExtId)
            }

            function f(e, t) {
                "undefined" != typeof chrome && chrome && chrome.runtime ? chrome.runtime.sendMessage(t.desktopSharingChromeExtId, {
                    getVersion: !0
                }, (function(n) {
                    if (!n || !n.version) return s.warn("Extension not installed?: ", chrome.runtime.lastError), void e(!1, !1);
                    var r = n.version;
                    s.log("Extension version is: ".concat(r));
                    var i = function(e, t) {
                        try {
                            for (var n = e.split("."), r = t.split("."), i = Math.max(n.length, r.length), o = 0; o < i; o++) {
                                var a = 0,
                                    u = 0;
                                if (o < n.length && (a = parseInt(n[o], 10)), o < r.length && (u = parseInt(r[o], 10)), isNaN(a) || isNaN(u)) return !0;
                                if (a !== u) return a > u
                            }
                            return !1
                        } catch (e) {
                            return c.callErrorHandler(e), s.error("Failed to parse extension version", e), !0
                        }
                    }(t.desktopSharingChromeMinExtVersion, r);
                    e(!i, i)
                })) : e(!1, !1)
            }

            function m() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {
                        response: {},
                        gumOptions: {}
                    },
                    t = arguments.length > 1 ? arguments[1] : void 0,
                    n = arguments.length > 2 ? arguments[2] : void 0,
                    o = e.response || {},
                    s = o.streamId,
                    c = o.streamType,
                    u = o.error;
                if (s) {
                    var l = function(e) {
                        for (var t = 1; t < arguments.length; t++) {
                            var n = null != arguments[t] ? arguments[t] : {},
                                r = Object.keys(n);
                            "function" == typeof Object.getOwnPropertySymbols && (r = r.concat(Object.getOwnPropertySymbols(n).filter((function(e) {
                                return Object.getOwnPropertyDescriptor(n, e).enumerable
                            })))), r.forEach((function(t) {
                                a(e, t, n[t])
                            }))
                        }
                        return e
                    }({
                        desktopStream: s
                    }, e.gumOptions);
                    d(["desktop"], l).then((function(e) {
                        return t({
                            stream: e,
                            sourceId: s,
                            sourceType: c
                        })
                    }), n)
                } else {
                    if ("" === s) return void n(new r.a(i.CHROME_EXTENSION_USER_CANCELED));
                    n(new r.a(i.CHROME_EXTENSION_GENERIC_ERROR, u))
                }
            }
            t.a = p
        }).call(this, "modules/RTC/ScreenObtainer.js")
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return _
            })), n.d(t, "b", (function() {
                return S
            }));
            var r = n(4),
                i = n(2),
                o = n(16),
                a = n(9),
                s = n(3),
                c = n(8),
                u = n.n(c),
                l = n(5),
                d = n(7);

            function p(e) {
                for (var t = 1; t < arguments.length; t++) {
                    var n = null != arguments[t] ? arguments[t] : {},
                        r = Object.keys(n);
                    "function" == typeof Object.getOwnPropertySymbols && (r = r.concat(Object.getOwnPropertySymbols(n).filter((function(e) {
                        return Object.getOwnPropertyDescriptor(n, e).enumerable
                    })))), r.forEach((function(t) {
                        h(e, t, n[t])
                    }))
                }
                return e
            }

            function h(e, t, n) {
                return t in e ? Object.defineProperty(e, t, {
                    value: n,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : e[t] = n, e
            }

            function f(e, t) {
                for (var n = 0; n < t.length; n++) {
                    var r = t[n];
                    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                }
            }

            function m(e, t, n) {
                return t && f(e.prototype, t), n && f(e, n), e
            }
            var v = Object(r.getLogger)(e),
                y = 500,
                g = 1e4,
                _ = {
                    ACTIVE: "active",
                    INACTIVE: "inactive",
                    INTERRUPTED: "interrupted",
                    RESTORING: "restoring"
                },
                S = function() {
                    function e(t, n, r) {
                        ! function(e, t) {
                            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                        }(this, e), this.rtc = t, this.conference = n, this.trackTimers = {}, this.connStatusFromJvb = {}, this.outOfLastNTimeout = "number" == typeof r.outOfLastNTimeout ? r.outOfLastNTimeout : y, this.rtcMuteTimeout = "number" == typeof r.rtcMuteTimeout ? r.rtcMuteTimeout : g, this.rtcMutedTimestamp = {}, v.info("RtcMuteTimeout set to: ".concat(this.rtcMuteTimeout)), this.enteredLastNTimestamp = new Map, this.restoringTimers = new Map, this.connectionStatusMap = new Map
                    }
                    return m(e, null, [{
                        key: "_getNewStateForJvbMode",
                        value: function(e, t, n, r, i) {
                            return e ? r ? _.ACTIVE : s.a.supportsVideoMuteOnConnInterrupted() ? i ? t ? n ? _.INTERRUPTED : _.RESTORING : _.INACTIVE : _.ACTIVE : t ? _.ACTIVE : _.INACTIVE : _.INTERRUPTED
                        }
                    }, {
                        key: "_getNewStateForP2PMode",
                        value: function(e, t) {
                            return s.a.supportsVideoMuteOnConnInterrupted() ? e || !t ? _.ACTIVE : _.INTERRUPTED : _.ACTIVE
                        }
                    }]), m(e, [{
                        key: "_getVideoFrozenTimeout",
                        value: function(e) {
                            return this.rtc.isInLastN(e) ? this.rtcMuteTimeout : this.outOfLastNTimeout
                        }
                    }, {
                        key: "init",
                        value: function() {
                            this._onEndpointConnStatusChanged = this.onEndpointConnStatusChanged.bind(this), this.rtc.addListener(u.a.ENDPOINT_CONN_STATUS_CHANGED, this._onEndpointConnStatusChanged), this._onP2PStatus = this.refreshConnectionStatusForAll.bind(this), this.conference.on(i.P2P_STATUS, this._onP2PStatus), this._onUserLeft = this.onUserLeft.bind(this), this.conference.on(i.USER_LEFT, this._onUserLeft), s.a.supportsVideoMuteOnConnInterrupted() && (this._onTrackRtcMuted = this.onTrackRtcMuted.bind(this), this.rtc.addListener(u.a.REMOTE_TRACK_MUTE, this._onTrackRtcMuted), this._onTrackRtcUnmuted = this.onTrackRtcUnmuted.bind(this), this.rtc.addListener(u.a.REMOTE_TRACK_UNMUTE, this._onTrackRtcUnmuted), this._onRemoteTrackAdded = this.onRemoteTrackAdded.bind(this), this.conference.on(i.TRACK_ADDED, this._onRemoteTrackAdded), this._onRemoteTrackRemoved = this.onRemoteTrackRemoved.bind(this), this.conference.on(i.TRACK_REMOVED, this._onRemoteTrackRemoved), this._onSignallingMuteChanged = this.onSignallingMuteChanged.bind(this), this._onTrackVideoTypeChanged = this.onTrackVideoTypeChanged.bind(this)), this._onLastNChanged = this._onLastNChanged.bind(this), this.conference.on(i.LAST_N_ENDPOINTS_CHANGED, this._onLastNChanged), this._onLastNValueChanged = this.refreshConnectionStatusForAll.bind(this), this.rtc.on(u.a.LASTN_VALUE_CHANGED, this._onLastNValueChanged)
                        }
                    }, {
                        key: "dispose",
                        value: function() {
                            this.rtc.removeListener(u.a.ENDPOINT_CONN_STATUS_CHANGED, this._onEndpointConnStatusChanged), s.a.supportsVideoMuteOnConnInterrupted() && (this.rtc.removeListener(u.a.REMOTE_TRACK_MUTE, this._onTrackRtcMuted), this.rtc.removeListener(u.a.REMOTE_TRACK_UNMUTE, this._onTrackRtcUnmuted), this.conference.off(i.TRACK_ADDED, this._onRemoteTrackAdded), this.conference.off(i.TRACK_REMOVED, this._onRemoteTrackRemoved)), this.conference.off(i.LAST_N_ENDPOINTS_CHANGED, this._onLastNChanged), this.rtc.removeListener(u.a.LASTN_VALUE_CHANGED, this._onLastNValueChanged), this.conference.off(i.P2P_STATUS, this._onP2PStatus), this.conference.off(i.USER_LEFT, this._onUserLeft);
                            for (var e = Object.keys(this.trackTimers), t = 0; t < e.length; t++) {
                                var n = e[t];
                                this.clearTimeout(n), this.clearRtcMutedTimestamp(n)
                            }
                            for (var r in this.connectionStatusMap) this.connectionStatusMap.hasOwnProperty(r) && this.onUserLeft(r);
                            this.connStatusFromJvb = {}
                        }
                    }, {
                        key: "onEndpointConnStatusChanged",
                        value: function(e, t) {
                            v.debug("Detector RTCEvents.ENDPOINT_CONN_STATUS_CHANGED(".concat(Date.now(), "): ").concat(e, ": ").concat(t)), e !== this.conference.myUserId() && (this.connStatusFromJvb[e] = t, this.figureOutConnectionStatus(e))
                        }
                    }, {
                        key: "_changeConnectionStatus",
                        value: function(e, t) {
                            if (e.getConnectionStatus() !== t) {
                                var n = e.getId();
                                e._setConnectionStatus(t), v.debug("Emit endpoint conn status(".concat(Date.now(), ") ").concat(n, ": ").concat(t)), l.a.sendLog(JSON.stringify({
                                    id: "peer.conn.status",
                                    participant: n,
                                    status: t
                                })), this.conference.eventEmitter.emit(i.PARTICIPANT_CONN_STATUS_CHANGED, n, t)
                            }
                        }
                    }, {
                        key: "clearTimeout",
                        value: function(e) {
                            this.trackTimers[e] && (window.clearTimeout(this.trackTimers[e]), this.trackTimers[e] = null)
                        }
                    }, {
                        key: "clearRtcMutedTimestamp",
                        value: function(e) {
                            this.rtcMutedTimestamp[e] = null
                        }
                    }, {
                        key: "onRemoteTrackAdded",
                        value: function(e) {
                            var t = this;
                            e.isLocal() || e.getType() !== a.b || (v.debug("Detector on remote track added for: ".concat(e.getParticipantId())), e.on(o.TRACK_MUTE_CHANGED, this._onSignallingMuteChanged), e.on(o.TRACK_VIDEOTYPE_CHANGED, (function(n) {
                                return t._onTrackVideoTypeChanged(e, n)
                            })))
                        }
                    }, {
                        key: "onRemoteTrackRemoved",
                        value: function(e) {
                            if (!e.isLocal() && e.getType() === a.b) {
                                var t = e.getParticipantId();
                                v.debug("Detector on remote track removed: ".concat(t)), e.off(o.TRACK_MUTE_CHANGED, this._onSignallingMuteChanged), this.clearTimeout(t), this.clearRtcMutedTimestamp(t), this.figureOutConnectionStatus(t)
                            }
                        }
                    }, {
                        key: "isVideoTrackFrozen",
                        value: function(e) {
                            if (!s.a.supportsVideoMuteOnConnInterrupted()) return !1;
                            var t = e.getId(),
                                n = e.hasAnyVideoTrackWebRTCMuted(),
                                r = this.rtcMutedTimestamp[t],
                                i = this._getVideoFrozenTimeout(t);
                            return n && "number" == typeof r && Date.now() - r >= i
                        }
                    }, {
                        key: "refreshConnectionStatusForAll",
                        value: function() {
                            var e = this.conference.getParticipants(),
                                t = !0,
                                n = !1,
                                r = void 0;
                            try {
                                for (var i, o = e[Symbol.iterator](); !(t = (i = o.next()).done); t = !0) {
                                    var a = i.value;
                                    this.figureOutConnectionStatus(a.getId())
                                }
                            } catch (e) {
                                n = !0, r = e
                            } finally {
                                try {
                                    t || null == o.return || o.return()
                                } finally {
                                    if (n) throw r
                                }
                            }
                        }
                    }, {
                        key: "figureOutConnectionStatus",
                        value: function(t) {
                            var n = this.conference.getParticipantById(t);
                            if (n) {
                                var r = this.conference.isP2PActive(),
                                    i = this._isRestoringTimedout(t),
                                    o = 0 === this.rtc.getLastN(),
                                    s = n.isVideoMuted() || o,
                                    c = this.isVideoTrackFrozen(n),
                                    u = this.rtc.isInLastN(t),
                                    l = this.connStatusFromJvb[t];
                                "boolean" != typeof l && (v.debug("Assuming connection active by JVB - no notification"), l = !0);
                                var d = r ? e._getNewStateForP2PMode(s, c) : e._getNewStateForJvbMode(l, u, i, s, c);
                                d !== _.RESTORING && this._clearRestoringTimer(t), v.debug("Figure out conn status for ".concat(t, ", is video muted: ").concat(s, " is active(jvb): ").concat(l, " video track frozen: ").concat(c, " p2p mode: ").concat(r, " is in last N: ").concat(u, " currentStatus => newStatus: ").concat(n.getConnectionStatus(), " => ").concat(d));
                                var h = this.connectionStatusMap[t] || {};
                                if (!("p2p" in h && "connectionStatus" in h && h.p2p === r && h.connectionStatus === d)) {
                                    var f = Date.now();
                                    if (this.maybeSendParticipantConnectionStatusEvent(t, f), this.connectionStatusMap[t] = p({}, h, {
                                            connectionStatus: d,
                                            p2p: r,
                                            startedMs: f
                                        }), !("videoType" in this.connectionStatusMap[t])) {
                                        var m = n.getTracksByMediaType(a.b);
                                        Array.isArray(m) && 0 !== m.length && (this.connectionStatusMap[t].videoType = m[0].videoType)
                                    }
                                }
                                this._changeConnectionStatus(n, d)
                            } else v.debug("figure out conn status - no participant for: ".concat(t))
                        }
                    }, {
                        key: "maybeSendParticipantConnectionStatusEvent",
                        value: function(e, t) {
                            var n = this.connectionStatusMap[e];
                            n && "startedMs" in n && "videoType" in n && "connectionStatus" in n && "p2p" in n && (n.value = t - n.startedMs, l.a.sendAnalytics(Object(d.I)(n)))
                        }
                    }, {
                        key: "_onLastNChanged",
                        value: function() {
                            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
                                t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [],
                                n = Date.now();
                            v.debug("leaving/entering lastN", e, t, n);
                            var r = !0,
                                i = !1,
                                o = void 0;
                            try {
                                for (var a, s = e[Symbol.iterator](); !(r = (a = s.next()).done); r = !0) {
                                    var c = a.value;
                                    this.enteredLastNTimestamp.delete(c), this._clearRestoringTimer(c), this.figureOutConnectionStatus(c)
                                }
                            } catch (e) {
                                i = !0, o = e
                            } finally {
                                try {
                                    r || null == s.return || s.return()
                                } finally {
                                    if (i) throw o
                                }
                            }
                            var u = !0,
                                l = !1,
                                d = void 0;
                            try {
                                for (var p, h = t[Symbol.iterator](); !(u = (p = h.next()).done); u = !0) {
                                    var f = p.value;
                                    this.enteredLastNTimestamp.set(f, n), this.figureOutConnectionStatus(f)
                                }
                            } catch (e) {
                                l = !0, d = e
                            } finally {
                                try {
                                    u || null == h.return || h.return()
                                } finally {
                                    if (l) throw d
                                }
                            }
                        }
                    }, {
                        key: "_clearRestoringTimer",
                        value: function(e) {
                            var t = this.restoringTimers.get(e);
                            t && (clearTimeout(t), this.restoringTimers.delete(e))
                        }
                    }, {
                        key: "_isRestoringTimedout",
                        value: function(e) {
                            var t = this,
                                n = this.enteredLastNTimestamp.get(e);
                            return !!(n && Date.now() - n >= 1e4) || (this.restoringTimers.get(e) || this.restoringTimers.set(e, setTimeout((function() {
                                return t.figureOutConnectionStatus(e)
                            }), 1e4)), !1)
                        }
                    }, {
                        key: "onUserLeft",
                        value: function(e) {
                            this.maybeSendParticipantConnectionStatusEvent(e, Date.now()), delete this.connectionStatusMap[e]
                        }
                    }, {
                        key: "onTrackRtcMuted",
                        value: function(e) {
                            var t = this,
                                n = e.getParticipantId(),
                                r = this.conference.getParticipantById(n);
                            if (v.debug("Detector track RTC muted: ".concat(n), Date.now()), r) {
                                if (this.rtcMutedTimestamp[n] = Date.now(), !r.isVideoMuted()) {
                                    this.clearTimeout(n);
                                    var i = this._getVideoFrozenTimeout(n);
                                    this.trackTimers[n] = window.setTimeout((function() {
                                        v.debug("Set RTC mute timeout for: ".concat(n, "                     of ").concat(i, " ms")), t.clearTimeout(n), t.figureOutConnectionStatus(n)
                                    }), i)
                                }
                            } else v.error("No participant for id: ".concat(n))
                        }
                    }, {
                        key: "onTrackRtcUnmuted",
                        value: function(e) {
                            var t = e.getParticipantId();
                            v.debug("Detector track RTC unmuted: ".concat(t), Date.now()), this.clearTimeout(t), this.clearRtcMutedTimestamp(t), this.figureOutConnectionStatus(t)
                        }
                    }, {
                        key: "onSignallingMuteChanged",
                        value: function(e) {
                            var t = e.getParticipantId();
                            v.debug("Detector on track signalling mute changed: ".concat(t), e.isMuted()), this.figureOutConnectionStatus(t)
                        }
                    }, {
                        key: "onTrackVideoTypeChanged",
                        value: function(e, t) {
                            var n = e.getParticipantId(),
                                r = Date.now();
                            this.maybeSendParticipantConnectionStatusEvent(n, r), this.connectionStatusMap[n] = p({}, this.connectionStatusMap[n] || {}, {
                                videoType: t,
                                startedMs: r
                            })
                        }
                    }]), e
                }()
        }).call(this, "modules/connectivity/ParticipantConnectionStatus.js")
    }, function(e, t, n) {
        "use strict";
        t.a = {
            getFocusRecordingUpdate: function(e) {
                var t = e && e.getElementsByTagName("jibri-recording-status")[0];
                if (t) return {
                    error: t.getAttribute("failure_reason"),
                    initiator: t.getAttribute("initiator"),
                    recordingMode: t.getAttribute("recording_mode"),
                    sessionID: t.getAttribute("session_id"),
                    status: t.getAttribute("status")
                }
            },
            getHiddenDomainUpdate: function(e) {
                var t = e.getElementsByTagName("live-stream-view-url")[0],
                    n = t && t.textContent,
                    r = e.getElementsByTagName("mode")[0],
                    i = r && r.textContent && r.textContent.toLowerCase(),
                    o = e.getElementsByTagName("session_id")[0];
                return {
                    liveStreamViewURL: n,
                    mode: i,
                    sessionID: o && o.textContent
                }
            },
            getSessionIdFromIq: function(e) {
                var t = e && e.getElementsByTagName("jibri")[0];
                return t && t.getAttribute("session_id")
            },
            getSessionId: function(e) {
                var t = e.getElementsByTagName("session_id")[0];
                return t && t.textContent
            },
            isFromFocus: function(e) {
                return e.getAttribute("from").includes("focus")
            }
        }
    }, function(e, t) {
        function n(e) {
            return (n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                return typeof e
            } : function(e) {
                return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
            })(e)
        }
        var r;
        r = function() {
            return this
        }();
        try {
            r = r || new Function("return this")()
        } catch (e) {
            "object" === ("undefined" == typeof window ? "undefined" : n(window)) && (r = window)
        }
        e.exports = r
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return k
            }));
            var r = n(7),
                i = n(4),
                o = n(1),
                a = n(82),
                s = n(83),
                c = n(30),
                u = n(18),
                l = n(47),
                d = n(6),
                p = n(84),
                h = n(8),
                f = n.n(h),
                m = n(5),
                v = n(0),
                y = n.n(v),
                g = n(86),
                _ = n(11),
                S = n.n(_);

            function b(e) {
                return (b = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                    return typeof e
                } : function(e) {
                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                })(e)
            }

            function E(e, t) {
                return !t || "object" !== b(t) && "function" != typeof t ? function(e) {
                    if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return e
                }(e) : t
            }

            function T(e) {
                return (T = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
                    return e.__proto__ || Object.getPrototypeOf(e)
                })(e)
            }

            function C(e, t) {
                for (var n = 0; n < t.length; n++) {
                    var r = t[n];
                    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                }
            }

            function R(e, t, n) {
                return t && C(e.prototype, t), n && C(e, n), e
            }

            function A(e, t) {
                return (A = Object.setPrototypeOf || function(e, t) {
                    return e.__proto__ = t, e
                })(e, t)
            }
            var w = Object(i.getLogger)(e),
                k = function(e) {
                    function t(e, n, r, i, o, a, s, c) {
                        var u;
                        return function(e, t) {
                            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                        }(this, t), (u = E(this, T(t).call(this, e, n, r, i, o, a, c)))._bridgeSessionId = null, u._iceCheckingStartedTimestamp = null, u._gatheringStartedTimestamp = null, u._localVideoActive = !0, u._remoteVideoActive = !0, u._gatheringReported = !1, u.lasticecandidate = !1, u.closed = !1, u.isP2P = s, u.signalingLayer = new p.a, u.modificationQueue = new g.a, u.wasConnected = !1, u.establishmentDuration = void 0, u
                    }
                    return function(e, t) {
                        if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
                        e.prototype = Object.create(t && t.prototype, {
                            constructor: {
                                value: e,
                                writable: !0,
                                configurable: !0
                            }
                        }), t && A(e, t)
                    }(t, e), R(t, null, [{
                        key: "parseVideoSenders",
                        value: function(e) {
                            var t = e.find('>content[name="video"]');
                            if (t.length) {
                                var n = t[0].getAttribute("senders");
                                if ("both" === n || "initiator" === n || "responder" === n || "none" === n) return n
                            }
                            return null
                        }
                    }]), R(t, [{
                        key: "_assertNotEnded",
                        value: function() {
                            return this.state !== c.b
                        }
                    }, {
                        key: "doInitialize",
                        value: function(e) {
                            var t = this;
                            this.failICE = Boolean(e.failICE), this.lasticecandidate = !1, this.options = e, this.isReconnect = !1, this.wasstable = !1, this.webrtcIceUdpDisable = Boolean(e.webrtcIceUdpDisable), this.webrtcIceTcpDisable = Boolean(e.webrtcIceTcpDisable);
                            var n = {
                                disableRtx: e.disableRtx
                            };
                            if (e.gatherStats && (n.maxstats = 300), n.capScreenshareBitrate = !1, this.isP2P) {
                                n.disableSimulcast = !0, n.disableH264 = e.p2p && e.p2p.disableH264, n.preferH264 = e.p2p && e.p2p.preferH264;
                                var i = this._abtestSuspendVideoEnabled(e);
                                void 0 !== i && (n.abtestSuspendVideo = i)
                            } else n.disableSimulcast = e.disableSimulcast || e.preferH264 && !e.disableH264, n.preferH264 = e.preferH264, n.enableFirefoxSimulcast = e.testing && e.testing.enableFirefoxSimulcast, n.enableLayerSuspension = e.enableLayerSuspension, e.testing && e.testing.capScreenshareBitrate && "number" == typeof e.testing.capScreenshareBitrate && (n.capScreenshareBitrate = Math.random() < e.testing.capScreenshareBitrate, m.a.analytics.addPermanentProperties({
                                capScreenshareBitrate: n.capScreenshareBitrate
                            }));
                            e.startSilent && (n.startSilent = !0), this.peerconnection = this.rtc.createPeerConnection(this.signalingLayer, this.iceConfig, this.isP2P, n), this.peerconnection.onicecandidate = function(e) {
                                if (e) {
                                    var n = e.candidate,
                                        i = window.performance.now();
                                    if (n) {
                                        null === t._gatheringStartedTimestamp && (t._gatheringStartedTimestamp = i);
                                        var o = n.protocol;
                                        if ("string" == typeof o)
                                            if ("tcp" === (o = o.toLowerCase()) || "ssltcp" === o) {
                                                if (t.webrtcIceTcpDisable) return
                                            } else if ("udp" === o && t.webrtcIceUdpDisable) return
                                    } else t._gatheringReported || (m.a.sendAnalytics(r.o, {
                                        phase: "gathering",
                                        value: i - t._gatheringStartedTimestamp,
                                        p2p: t.isP2P,
                                        initiator: t.isInitiator
                                    }), t._gatheringReported = !0);
                                    t.sendIceCandidate(n)
                                }
                            }, this.peerconnection.onsignalingstatechange = function() {
                                "stable" === t.peerconnection.signalingState ? t.wasstable = !0 : "closed" !== t.peerconnection.signalingState && "closed" !== t.peerconnection.connectionState || t.room.eventEmitter.emit(y.a.SUSPEND_DETECTED, t)
                            }, this.peerconnection.oniceconnectionstatechange = function() {
                                var e = window.performance.now();
                                switch (t.isP2P || (t.room.connectionTimes["ice.state.".concat(t.peerconnection.iceConnectionState)] = e), w.log("(TIME) ICE ".concat(t.peerconnection.iceConnectionState) + " P2P? ".concat(t.isP2P, ":\t"), e), m.a.sendAnalytics(r.q, {
                                    p2p: t.isP2P,
                                    state: t.peerconnection.iceConnectionState,
                                    signaling_state: t.peerconnection.signalingState,
                                    reconnect: t.isReconnect,
                                    value: e
                                }), t.room.eventEmitter.emit(y.a.ICE_CONNECTION_STATE_CHANGED, t, t.peerconnection.iceConnectionState), t.peerconnection.iceConnectionState) {
                                    case "checking":
                                        t._iceCheckingStartedTimestamp = e;
                                        break;
                                    case "connected":
                                        if ("stable" === t.peerconnection.signalingState && t.isReconnect && t.room.eventEmitter.emit(y.a.CONNECTION_RESTORED, t), !t.wasConnected && t.wasstable) {
                                            m.a.sendAnalytics(r.o, {
                                                phase: "checking",
                                                value: e - t._iceCheckingStartedTimestamp,
                                                p2p: t.isP2P,
                                                initiator: t.isInitiator
                                            });
                                            var n = Math.min(t._iceCheckingStartedTimestamp, t._gatheringStartedTimestamp);
                                            t.establishmentDuration = e - n, m.a.sendAnalytics(r.o, {
                                                phase: "establishment",
                                                value: t.establishmentDuration,
                                                p2p: t.isP2P,
                                                initiator: t.isInitiator
                                            }), t.wasConnected = !0, t.room.eventEmitter.emit(y.a.CONNECTION_ESTABLISHED, t)
                                        }
                                        t.isReconnect = !1;
                                        break;
                                    case "disconnected":
                                        t.isReconnect = !0, t.wasstable && t.room.eventEmitter.emit(y.a.CONNECTION_INTERRUPTED, t);
                                        break;
                                    case "failed":
                                        t.room.eventEmitter.emit(y.a.CONNECTION_ICE_FAILED, t)
                                }
                            }, this.peerconnection.onnegotiationneeded = function() {
                                t.room.eventEmitter.emit(y.a.PEERCONNECTION_READY, t)
                            }, this.signalingLayer.setChatRoom(this.room), !this.isP2P && e.enableLayerSuspension && this.rtc.addListener(f.a.IS_SELECTED_CHANGED, (function(e) {
                                t.peerconnection.setIsSelected(e), w.info("Doing local O/A due to IS_SELECTED_CHANGED event"), t.modificationQueue.push((function(e) {
                                    t._renegotiate().then(e).catch(e)
                                }))
                            }))
                        }
                    }, {
                        key: "sendIceCandidate",
                        value: function(e) {
                            var t = this,
                                n = new u.a(this.peerconnection.localDescription.sdp);
                            if (e && !this.lasticecandidate) {
                                var r = d.a.iceparams(n.media[e.sdpMLineIndex], n.session),
                                    i = d.a.candidateToJingle(e.candidate);
                                if (!r || !i) {
                                    return S.a.callErrorHandler(new Error("failed to get ice && jcand")), void w.error("failed to get ice && jcand")
                                }
                                r.xmlns = "urn:xmpp:jingle:transports:ice-udp:1", this.usedrip ? (0 === this.dripContainer.length && setTimeout((function() {
                                    0 !== t.dripContainer.length && (t.sendIceCandidates(t.dripContainer), t.dripContainer = [])
                                }), 20), this.dripContainer.push(e)) : this.sendIceCandidates([e])
                            } else w.log("sendIceCandidate: last candidate."), this.lasticecandidate = !0
                        }
                    }, {
                        key: "sendIceCandidates",
                        value: function(e) {
                            var t = this;
                            if (this._assertNotEnded("sendIceCandidates")) {
                                w.log("sendIceCandidates", e);
                                for (var n = Object(o.$iq)({
                                        to: this.remoteJid,
                                        type: "set"
                                    }).c("jingle", {
                                        xmlns: "urn:xmpp:jingle:1",
                                        action: "transport-info",
                                        initiator: this.initiatorJid,
                                        sid: this.sid
                                    }), r = new u.a(this.peerconnection.localDescription.sdp), i = function(i) {
                                        var o = e.filter((function(e) {
                                                return e.sdpMLineIndex === i
                                            })),
                                            a = d.a.parseMLine(r.media[i].split("\r\n")[0]);
                                        if (o.length > 0) {
                                            var s = d.a.iceparams(r.media[i], r.session);
                                            s.xmlns = "urn:xmpp:jingle:transports:ice-udp:1", n.c("content", {
                                                creator: t.initiatorJid === t.localJid ? "initiator" : "responder",
                                                name: o[0].sdpMid ? o[0].sdpMid : a.media
                                            }).c("transport", s);
                                            for (var c = 0; c < o.length; c++) {
                                                var u = d.a.candidateToJingle(o[c].candidate);
                                                t.failICE && (u.ip = "1.1.1.1"), n.c("candidate", u).up()
                                            }
                                            var l = d.a.findLine(r.media[i], "a=fingerprint:", r.session);
                                            if (l) {
                                                var p = d.a.parseFingerprint(l);
                                                p.required = !0, n.c("fingerprint", {
                                                    xmlns: "urn:xmpp:jingle:apps:dtls:0"
                                                }).t(p.fingerprint), delete p.fingerprint, n.attrs(p), n.up()
                                            }
                                            n.up(), n.up()
                                        }
                                    }, a = 0; a < r.media.length; a++) i(a);
                                this.connection.sendIQ(n, null, this.newJingleErrorHandler(n), 1e4)
                            }
                        }
                    }, {
                        key: "sendIceFailedNotification",
                        value: function() {
                            var e = Object(o.$iq)({
                                to: this.remoteJid,
                                type: "set"
                            }).c("jingle", {
                                xmlns: "urn:xmpp:jingle:1",
                                action: "session-info",
                                initiator: this.initiatorJid,
                                sid: this.sid
                            }).c("ice-state", {
                                xmlns: "http://jitsi.org/protocol/focus"
                            }).t("failed").up();
                            this._bridgeSessionId && e.c("bridge-session", {
                                xmlns: "http://jitsi.org/protocol/focus",
                                id: this._bridgeSessionId
                            }), this.connection.sendIQ(e, null, this.newJingleErrorHandler(e), 65)
                        }
                    }, {
                        key: "addIceCandidates",
                        value: function(e) {
                            var t = this;
                            if ("closed" !== this.peerconnection.signalingState) {
                                var n = [];
                                if (e.find(">content>transport>candidate").each((function(e, t) {
                                        var r = d.a.candidateFromJingle(t);
                                        r = r.replace("\r\n", "").replace("a=", "");
                                        var i = new RTCIceCandidate({
                                            sdpMLineIndex: 0,
                                            sdpMid: "",
                                            candidate: r
                                        });
                                        n.push(i)
                                    })), n.length) {
                                    w.debug("Queued add (".concat(n.length, ") ICE candidates task...")), this.modificationQueue.push((function(e) {
                                        for (var r = 0; r < n.length; r++) {
                                            var i = n[r];
                                            t.peerconnection.addIceCandidate(i).then((function() {
                                                return w.debug("addIceCandidate ok!")
                                            }), (function(e) {
                                                return w.error("addIceCandidate failed!", e)
                                            }))
                                        }
                                        e()
                                    }))
                                } else w.error("No ICE candidates to add ?", e[0] && e[0].outerHTML)
                            } else w.warn("Ignored add ICE candidate when in closed state")
                        }
                    }, {
                        key: "readSsrcInfo",
                        value: function(e) {
                            var t = this;
                            $(e).find('>description>source[xmlns="urn:xmpp:jingle:apps:rtp:ssma:0"]').each((function(e, n) {
                                var r = Number(n.getAttribute("ssrc"));
                                t.isP2P ? t.signalingLayer.setSSRCOwner(r, o.Strophe.getResourceFromJid(t.remoteJid)) : $(n).find('>ssrc-info[xmlns="http://jitsi.org/jitmeet"]').each((function(e, n) {
                                    var i = n.getAttribute("owner");
                                    i && i.length && (isNaN(r) || r < 0 ? w.warn("Invalid SSRC ".concat(r, " value received") + " for ".concat(i)) : t.signalingLayer.setSSRCOwner(r, o.Strophe.getResourceFromJid(i)))
                                }))
                            }))
                        }
                    }, {
                        key: "generateRecvonlySsrc",
                        value: function() {
                            this.peerconnection ? this.peerconnection.generateRecvonlySsrc() : w.error("Unable to generate recvonly SSRC - no peerconnection")
                        }
                    }, {
                        key: "acceptOffer",
                        value: function(e, t, n, r) {
                            var i = this;
                            this.setOfferAnswerCycle(e, (function() {
                                i.sendSessionAccept(t, n)
                            }), n, r)
                        }
                    }, {
                        key: "invite",
                        value: function(e) {
                            var t = this;
                            if (!this.isInitiator) throw new Error("Trying to invite from the responder session");
                            this.modificationQueue.push((function(n) {
                                var r = !0,
                                    i = !1,
                                    o = void 0;
                                try {
                                    for (var a, s = e[Symbol.iterator](); !(r = (a = s.next()).done); r = !0) {
                                        var c = a.value;
                                        t.peerconnection.addTrack(c)
                                    }
                                } catch (e) {
                                    i = !0, o = e
                                } finally {
                                    try {
                                        r || null == s.return || s.return()
                                    } finally {
                                        if (i) throw o
                                    }
                                }
                                t.peerconnection.createOffer(t.mediaConstraints).then((function(e) {
                                    t.peerconnection.setLocalDescription(e).then((function() {
                                        t.sendSessionInitiate(t.peerconnection.localDescription.sdp), n()
                                    }), (function(t) {
                                        w.error("Failed to set local SDP", t, e), n(t)
                                    }))
                                }), (function(e) {
                                    w.error("Failed to create an offer", e, t.mediaConstraints), n(e)
                                }))
                            }), (function(e) {
                                e ? w.error("invite error", e) : w.debug("invite executed - OK")
                            }))
                        }
                    }, {
                        key: "sendSessionInitiate",
                        value: function(e) {
                            var t = Object(o.$iq)({
                                to: this.remoteJid,
                                type: "set"
                            }).c("jingle", {
                                xmlns: "urn:xmpp:jingle:1",
                                action: "session-initiate",
                                initiator: this.initiatorJid,
                                sid: this.sid
                            });
                            new u.a(e).toJingle(t, this.isInitiator ? "initiator" : "responder"), t = t.tree(), w.info("Session-initiate: ", t), this.connection.sendIQ(t, (function() {
                                w.info('Got RESULT for "session-initiate"')
                            }), (function(e) {
                                w.error('"session-initiate" error', e)
                            }), 1e4)
                        }
                    }, {
                        key: "setAnswer",
                        value: function(e) {
                            if (!this.isInitiator) throw new Error("Trying to set an answer on the responder session");
                            this.setOfferAnswerCycle(e, (function() {
                                w.info("setAnswer - succeeded")
                            }), (function(e) {
                                w.error("setAnswer failed: ", e)
                            }))
                        }
                    }, {
                        key: "setOfferAnswerCycle",
                        value: function(e, t, n, r) {
                            var i = this;
                            this.modificationQueue.push((function(t) {
                                if (r) {
                                    var n = !0,
                                        o = !1,
                                        a = void 0;
                                    try {
                                        for (var s, l = r[Symbol.iterator](); !(n = (s = l.next()).done); n = !0) {
                                            var d = s.value;
                                            i.peerconnection.addTrack(d)
                                        }
                                    } catch (e) {
                                        o = !0, a = e
                                    } finally {
                                        try {
                                            n || null == l.return || l.return()
                                        } finally {
                                            if (o) throw a
                                        }
                                    }
                                }
                                var p = i._processNewJingleOfferIq(e),
                                    h = i.peerconnection.localDescription.sdp,
                                    f = $(e).find('>bridge-session[xmlns="http://jitsi.org/protocol/focus"]').attr("id");
                                f !== i._bridgeSessionId && (i._bridgeSessionId = f), i._renegotiate(p.raw).then((function() {
                                    if (i.state === c.c && (i.state = c.a, i.isP2P && !i._localVideoActive && i.sendContentModify(i._localVideoActive)), h) {
                                        var e = new u.a(i.peerconnection.localDescription.sdp);
                                        i.notifyMySSRCUpdate(new u.a(h), e)
                                    }
                                    t()
                                }), (function(e) {
                                    w.error("Error renegotiating after setting new remote ".concat(i.isInitiator ? "answer: " : "offer: ").concat(e), p), t(e)
                                }))
                            }), (function(e) {
                                e ? n(e) : t()
                            }))
                        }
                    }, {
                        key: "replaceTransport",
                        value: function(e, t, n) {
                            var r = this;
                            this.room.eventEmitter.emit(y.a.ICE_RESTARTING, this);
                            var i = e.clone();
                            e.find(">content[name='data']").attr("senders", "rejected"), e.find(">content>description>source").remove(), e.find(">content>description>ssrc-group").remove();
                            var o = e.find(">content>transport>fingerprint");
                            o.attr("hash", "sha-1"), o.text("00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00"), this.setOfferAnswerCycle(e, (function() {
                                r.setOfferAnswerCycle(i, (function() {
                                    var e = new u.a(r.peerconnection.localDescription.sdp);
                                    r.sendTransportAccept(e, t, n), r.room.eventEmitter.emit(y.a.ICE_RESTART_SUCCESS, r, i)
                                }), n)
                            }), n)
                        }
                    }, {
                        key: "sendSessionAccept",
                        value: function(e, t) {
                            var n = this,
                                r = new u.a(this.peerconnection.localDescription.sdp),
                                i = Object(o.$iq)({
                                    to: this.remoteJid,
                                    type: "set"
                                }).c("jingle", {
                                    xmlns: "urn:xmpp:jingle:1",
                                    action: "session-accept",
                                    initiator: this.initiatorJid,
                                    responder: this.responderJid,
                                    sid: this.sid
                                });
                            this.webrtcIceTcpDisable && (r.removeTcpCandidates = !0), this.webrtcIceUdpDisable && (r.removeUdpCandidates = !0), this.failICE && (r.failICE = !0), r.toJingle(i, this.initiatorJid === this.localJid ? "initiator" : "responder", null), i = i.tree(), w.info("Sending session-accept", i), this.connection.sendIQ(i, e, this.newJingleErrorHandler(i, (function(e) {
                                t(e), n.room.eventEmitter.emit(y.a.SESSION_ACCEPT_TIMEOUT, n)
                            })), 1e4)
                        }
                    }, {
                        key: "sendContentModify",
                        value: function(e) {
                            var t = e ? "both" : "none",
                                n = Object(o.$iq)({
                                    to: this.remoteJid,
                                    type: "set"
                                }).c("jingle", {
                                    xmlns: "urn:xmpp:jingle:1",
                                    action: "content-modify",
                                    initiator: this.initiatorJid,
                                    sid: this.sid
                                }).c("content", {
                                    name: "video",
                                    senders: t
                                });
                            w.info("Sending content-modify, video senders: ".concat(t)), this.connection.sendIQ(n, null, this.newJingleErrorHandler(n), 1e4)
                        }
                    }, {
                        key: "sendTransportAccept",
                        value: function(e, t, n) {
                            var r = this,
                                i = Object(o.$iq)({
                                    to: this.remoteJid,
                                    type: "set"
                                }).c("jingle", {
                                    xmlns: "urn:xmpp:jingle:1",
                                    action: "transport-accept",
                                    initiator: this.initiatorJid,
                                    sid: this.sid
                                });
                            e.media.forEach((function(t, n) {
                                var o = d.a.parseMLine(t.split("\r\n")[0]);
                                i.c("content", {
                                    creator: r.initiatorJid === r.localJid ? "initiator" : "responder",
                                    name: o.media
                                }), e.transportToJingle(n, i), i.up()
                            })), i = i.tree(), w.info("Sending transport-accept: ", i), this.connection.sendIQ(i, t, this.newJingleErrorHandler(i, n), 1e4)
                        }
                    }, {
                        key: "sendTransportReject",
                        value: function(e, t) {
                            var n = Object(o.$iq)({
                                to: this.remoteJid,
                                type: "set"
                            }).c("jingle", {
                                xmlns: "urn:xmpp:jingle:1",
                                action: "transport-reject",
                                initiator: this.initiatorJid,
                                sid: this.sid
                            });
                            n = n.tree(), w.info("Sending 'transport-reject", n), this.connection.sendIQ(n, e, this.newJingleErrorHandler(n, t), 1e4)
                        }
                    }, {
                        key: "terminate",
                        value: function(e, t, n) {
                            if (this.state !== c.b) {
                                if (!n || Boolean(n.sendSessionTerminate)) {
                                    var r = Object(o.$iq)({
                                        to: this.remoteJid,
                                        type: "set"
                                    }).c("jingle", {
                                        xmlns: "urn:xmpp:jingle:1",
                                        action: "session-terminate",
                                        initiator: this.initiatorJid,
                                        sid: this.sid
                                    }).c("reason").c(n && n.reason || "success");
                                    n && n.reasonDescription && r.up().c("text").t(n.reasonDescription), r = r.tree(), w.info("Sending session-terminate", r), this.connection.sendIQ(r, e, this.newJingleErrorHandler(r, t), 1e4)
                                } else w.info("Skipped sending session-terminate for ".concat(this));
                                this.connection.jingle.terminate(this.sid)
                            }
                        }
                    }, {
                        key: "onTerminated",
                        value: function(e, t) {
                            w.info("Session terminated ".concat(this), e, t), this.close()
                        }
                    }, {
                        key: "_parseSsrcInfoFromSourceAdd",
                        value: function(e, t) {
                            var n = [];
                            return $(e).each((function(e, r) {
                                var i = $(r).attr("name"),
                                    o = "";
                                $(r).find('ssrc-group[xmlns="urn:xmpp:jingle:apps:rtp:ssma:0"]').each((function() {
                                    var e = this.getAttribute("semantics"),
                                        t = $(this).find(">source").map((function() {
                                            return this.getAttribute("ssrc")
                                        })).get();
                                    t.length && (o += "a=ssrc-group:".concat(e, " ").concat(t.join(" "), "\r\n"))
                                })), $(r).find('source[xmlns="urn:xmpp:jingle:apps:rtp:ssma:0"]').each((function() {
                                    var e = $(this).attr("ssrc");
                                    t.containsSSRC(e) ? w.warn("Source-add request for existing SSRC: ".concat(e)) : $(this).find(">parameter").each((function() {
                                        o += "a=ssrc:".concat(e, " ").concat($(this).attr("name")), $(this).attr("value") && $(this).attr("value").length && (o += ":".concat($(this).attr("value"))), o += "\r\n"
                                    }))
                                })), t.media.forEach((function(e, t) {
                                    d.a.findLine(e, "a=mid:".concat(i)) && (n[t] || (n[t] = ""), n[t] += o)
                                }))
                            })), n
                        }
                    }, {
                        key: "addRemoteStream",
                        value: function(e) {
                            this._addOrRemoveRemoteStream(!0, e)
                        }
                    }, {
                        key: "removeRemoteStream",
                        value: function(e) {
                            this._addOrRemoveRemoteStream(!1, e)
                        }
                    }, {
                        key: "_addOrRemoveRemoteStream",
                        value: function(e, t) {
                            var n = this,
                                r = e ? "addRemoteStream" : "removeRemoteStream";
                            e && this.readSsrcInfo(t);
                            this.modificationQueue.push((function(i) {
                                if (!n.peerconnection.localDescription || !n.peerconnection.localDescription.sdp) {
                                    var o = "".concat(r, " - localDescription not ready yet");
                                    return w.error(o), void i(o)
                                }
                                w.log("Processing ".concat(r)), w.log("ICE connection state: ", n.peerconnection.iceConnectionState);
                                var a = new u.a(n.peerconnection.localDescription.sdp),
                                    s = new u.a(n.peerconnection.remoteDescription.sdp),
                                    c = e ? n._parseSsrcInfoFromSourceAdd(t, s) : n._parseSsrcInfoFromSourceRemove(t, s),
                                    l = e ? n._processRemoteAddSource(c) : n._processRemoteRemoveSource(c);
                                n._renegotiate(l.raw).then((function() {
                                    var e = new u.a(n.peerconnection.localDescription.sdp);
                                    w.log("".concat(r, " - OK, SDPs: "), a, e), n.notifyMySSRCUpdate(a, e), i()
                                }), (function(e) {
                                    w.error("".concat(r, " failed:"), e), i(e)
                                }))
                            }))
                        }
                    }, {
                        key: "_processNewJingleOfferIq",
                        value: function(e) {
                            var t = new u.a("");
                            return this.webrtcIceTcpDisable && (t.removeTcpCandidates = !0), this.webrtcIceUdpDisable && (t.removeUdpCandidates = !0), this.failICE && (t.failICE = !0), t.fromJingle(e), this.readSsrcInfo($(e).find(">content")), t
                        }
                    }, {
                        key: "_processRemoteRemoveSource",
                        value: function(e) {
                            var t = new u.a(this.peerconnection.remoteDescription.sdp);
                            return e.forEach((function(e, n) {
                                (e = e.split("\r\n")).pop(), e.forEach((function(e) {
                                    t.media[n] = t.media[n].replace("".concat(e, "\r\n"), "")
                                }))
                            })), t.raw = t.session + t.media.join(""), t
                        }
                    }, {
                        key: "_processRemoteAddSource",
                        value: function(e) {
                            var t = new u.a(this.peerconnection.remoteDescription.sdp);
                            return e.forEach((function(e, n) {
                                t.media[n] += e
                            })), t.raw = t.session + t.media.join(""), t
                        }
                    }, {
                        key: "_renegotiate",
                        value: function(e) {
                            if ("closed" === this.peerconnection.signalingState) {
                                var t = new Error("Attempted to renegotiate in state closed");
                                return this.room.eventEmitter.emit(y.a.RENEGOTIATION_FAILED, t, this), Promise.reject(t)
                            }
                            var n = e || this.peerconnection.remoteDescription.sdp;
                            if (!n) {
                                var r = new Error("Can not renegotiate without remote description, current state: ".concat(this.state));
                                return this.room.eventEmitter.emit(y.a.RENEGOTIATION_FAILED, r, this), Promise.reject(r)
                            }
                            var i = new RTCSessionDescription({
                                type: this.isInitiator ? "answer" : "offer",
                                sdp: n
                            });
                            return this.isInitiator ? this._initiatorRenegotiate(i) : this._responderRenegotiate(i)
                        }
                    }, {
                        key: "_responderRenegotiate",
                        value: function(e) {
                            var t = this;
                            return w.debug("Renegotiate: setting remote description"), this.peerconnection.setRemoteDescription(e).then((function() {
                                return w.debug("Renegotiate: creating answer"), t.peerconnection.createAnswer(t.mediaConstraints).then((function(e) {
                                    return w.debug("Renegotiate: setting local description"), t.peerconnection.setLocalDescription(e)
                                }))
                            }))
                        }
                    }, {
                        key: "_initiatorRenegotiate",
                        value: function(e) {
                            var t = this;
                            return "have-local-offer" === this.peerconnection.signalingState ? (w.debug("Renegotiate: setting remote description"), this.peerconnection.setRemoteDescription(e).then((function() {
                                return t._initiatorRenegotiate(e)
                            }))) : (w.debug("Renegotiate: creating offer"), this.peerconnection.createOffer(this.mediaConstraints).then((function(n) {
                                return w.debug("Renegotiate: setting local description"), t.peerconnection.setLocalDescription(n).then((function() {
                                    return w.debug("Renegotiate: setting remote description"), t.peerconnection.setRemoteDescription(e)
                                }))
                            })))
                        }
                    }, {
                        key: "replaceTrack",
                        value: function(e, t) {
                            var n = this,
                                r = function(r) {
                                    var i = n.peerconnection.localDescription.sdp;
                                    n.peerconnection.options.capScreenshareBitrate && e && t && t.isVideoTrack() && n.peerconnection.clearRecvonlySsrc(), !e && t && t.isVideoTrack() ? n.peerconnection.clearRecvonlySsrc() : e && e.isVideoTrack() && !t && (n.peerconnection.clearRecvonlySsrc(), n.peerconnection.generateRecvonlySsrc()), n.peerconnection.replaceTrack(e, t).then((function(o) {
                                        o && (e || t) && n.state === c.a ? n._renegotiate().then((function() {
                                            var e = new u.a(n.peerconnection.localDescription.sdp);
                                            n.notifyMySSRCUpdate(new u.a(i), e), t && !n.isP2P && n.peerconnection.setMaxBitRate(t), r()
                                        }), r) : r()
                                    }))
                                };
                            return new Promise((function(e, t) {
                                n.modificationQueue.push(r, (function(n) {
                                    n ? (w.error("Replace track error:", n), t(n)) : (w.info("Replace track done!"), e())
                                }))
                            }))
                        }
                    }, {
                        key: "_parseSsrcInfoFromSourceRemove",
                        value: function(e, t) {
                            var n = [];
                            return $(e).each((function(e, r) {
                                var i = $(r).attr("name"),
                                    o = "";
                                $(r).find('ssrc-group[xmlns="urn:xmpp:jingle:apps:rtp:ssma:0"]').each((function() {
                                    var e = this.getAttribute("semantics"),
                                        t = $(this).find(">source").map((function() {
                                            return this.getAttribute("ssrc")
                                        })).get();
                                    t.length && (o += "a=ssrc-group:".concat(e, " ").concat(t.join(" "), "\r\n"))
                                }));
                                var a = [];
                                $(r).find('source[xmlns="urn:xmpp:jingle:apps:rtp:ssma:0"]').each((function() {
                                    var e = $(this).attr("ssrc");
                                    a.push(e)
                                })), t.media.forEach((function(e, t) {
                                    d.a.findLine(e, "a=mid:".concat(i)) && (n[t] || (n[t] = ""), a.forEach((function(r) {
                                        var i = d.a.findLines(e, "a=ssrc:".concat(r));
                                        i.length && (n[t] += "".concat(i.join("\r\n"), "\r\n"))
                                    })), n[t] += o)
                                }))
                            })), n
                        }
                    }, {
                        key: "_verifyNoSSRCChanged",
                        value: function(e, t) {
                            var n = new u.a(this.peerconnection.localDescription.sdp),
                                r = new l.a(t, n),
                                i = r.getNewMedia();
                            if (Object.keys(i).length) return w.error("".concat(this, " - some SSRC were added on ").concat(e), i), !1;
                            var o = (r = new l.a(n, t)).getNewMedia();
                            return !Object.keys(o).length || (w.error("".concat(this, " - some SSRCs were removed on ").concat(e), o), !1)
                        }
                    }, {
                        key: "addTrackAsUnmute",
                        value: function(e) {
                            return this._addRemoveTrackAsMuteUnmute(!1, e)
                        }
                    }, {
                        key: "removeTrackAsMute",
                        value: function(e) {
                            return this._addRemoveTrackAsMuteUnmute(!0, e)
                        }
                    }, {
                        key: "_addRemoveTrackAsMuteUnmute",
                        value: function(e, t) {
                            var n = this;
                            if (!t) return Promise.reject('invalid "track" argument value');
                            var r = e ? "removeTrackMute" : "addTrackUnmute",
                                i = function(i) {
                                    var o = n.peerconnection;
                                    if (o) {
                                        var a = o.localDescription.sdp;
                                        (e ? o.removeTrackMute.bind(o, t) : o.addTrackUnmute.bind(o, t))() ? a && o.remoteDescription.sdp ? n._renegotiate().then((function() {
                                            n._verifyNoSSRCChanged(r, new u.a(a)), i()
                                        }), i) : i(): i("".concat(r, " failed!"))
                                    } else i("Error:  tried ".concat(r, " track with no active peer") + "connection")
                                };
                            return new Promise((function(e, t) {
                                n.modificationQueue.push(i, (function(n) {
                                    n ? t(n) : e()
                                }))
                            }))
                        }
                    }, {
                        key: "setMediaTransferActive",
                        value: function(e, t) {
                            var n = this;
                            if (!this.peerconnection) return Promise.reject('Can not modify transfer active state, before "initialize" is called');
                            var r = e ? "audio active" : "audio inactive",
                                i = t ? "video active" : "video inactive";
                            w.info("Queued make ".concat(i, ", ").concat(r, " task..."));
                            var o = function(r) {
                                var i = n.state === c.a,
                                    o = n.peerconnection.setAudioTransferActive(e);
                                n._localVideoActive !== t && (n._localVideoActive = t, n.isP2P && i && n.sendContentModify(t));
                                var a = n.peerconnection.setVideoTransferActive(n._localVideoActive && n._remoteVideoActive);
                                i && (o || a) ? n._renegotiate().then(r, r) : r()
                            };
                            return new Promise((function(e, t) {
                                n.modificationQueue.push(o, (function(n) {
                                    n ? t(n) : e()
                                }))
                            }))
                        }
                    }, {
                        key: "modifyContents",
                        value: function(e) {
                            var n = this,
                                r = t.parseVideoSenders(e);
                            if (null !== r) {
                                w.debug("".concat(this, ' queued "content-modify" task') + '(video senders="'.concat(r, '")')), this.modificationQueue.push((function(e) {
                                    n._assertNotEnded("content-modify") && n._modifyRemoteVideoActive(r) ? n._renegotiate().then(e, e) : e()
                                }), (function(e) {
                                    e && w.error('"content-modify" failed', e)
                                }))
                            } else w.error("".concat(this, ' - failed to parse video "senders" attribute in') + '"content-modify" action')
                        }
                    }, {
                        key: "_modifyRemoteVideoActive",
                        value: function(e) {
                            var t = "both" === e || "initiator" === e && this.isInitiator || "responder" === e && !this.isInitiator;
                            return t !== this._remoteVideoActive && (w.debug("".concat(this, " new remote video active: ").concat(t)), this._remoteVideoActive = t), this.peerconnection.setVideoTransferActive(this._localVideoActive && this._remoteVideoActive)
                        }
                    }, {
                        key: "notifyMySSRCUpdate",
                        value: function(e, t) {
                            if (this.state === c.a) {
                                var n = new l.a(t, e),
                                    r = Object(o.$iq)({
                                        to: this.remoteJid,
                                        type: "set"
                                    }).c("jingle", {
                                        xmlns: "urn:xmpp:jingle:1",
                                        action: "source-remove",
                                        initiator: this.initiatorJid,
                                        sid: this.sid
                                    });
                                n.toJingle(r) ? (w.info("Sending source-remove", r.tree()), this.connection.sendIQ(r, null, this.newJingleErrorHandler(r), 1e4)) : w.log("removal not necessary"), n = new l.a(e, t);
                                var i = Object(o.$iq)({
                                    to: this.remoteJid,
                                    type: "set"
                                }).c("jingle", {
                                    xmlns: "urn:xmpp:jingle:1",
                                    action: "source-add",
                                    initiator: this.initiatorJid,
                                    sid: this.sid
                                });
                                n.toJingle(i) ? (w.info("Sending source-add", i.tree()), this.connection.sendIQ(i, null, this.newJingleErrorHandler(i), 1e4)) : w.log("addition not necessary")
                            } else w.warn("Skipping SSRC update in '".concat(this.state, " ' state."))
                        }
                    }, {
                        key: "newJingleErrorHandler",
                        value: function(e, t) {
                            var n = this;
                            return function(e) {
                                var r = {},
                                    i = $(e).find("error");
                                if (i.length) {
                                    r.code = i.attr("code");
                                    var o = $(e).find("error :first");
                                    o.length && (r.reason = o[0].tagName);
                                    var a = i.find(">text");
                                    a.length && (r.msg = a.text())
                                }
                                e || (r.reason = "timeout"), r.session = n.toString(), t ? t(r) : n.state === c.b && "item-not-found" === r.reason ? w.debug("Jingle error: ".concat(JSON.stringify(r))) : S.a.callErrorHandler(new Error("Jingle error: ".concat(JSON.stringify(r))))
                            }
                        }
                    }, {
                        key: "getIceConnectionState",
                        value: function() {
                            return this.peerconnection.iceConnectionState
                        }
                    }, {
                        key: "close",
                        value: function() {
                            var e = this;
                            this.state = c.b, this.establishmentDuration = void 0, this.peerconnection && (this.peerconnection.onicecandidate = null, this.peerconnection.oniceconnectionstatechange = null, this.peerconnection.onnegotiationneeded = null, this.peerconnection.onsignalingstatechange = null), this.modificationQueue.clear(), this.modificationQueue.push((function(t) {
                                e.signalingLayer.setChatRoom(null), e.peerconnection && e.peerconnection.close(), t()
                            })), this.modificationQueue.shutdown()
                        }
                    }, {
                        key: "toString",
                        value: function() {
                            return "JingleSessionPC[p2p=".concat(this.isP2P, ",") + "initiator=".concat(this.isInitiator, ",sid=").concat(this.sid, "]")
                        }
                    }, {
                        key: "_abtestSuspendVideoEnabled",
                        value: function(e) {
                            var t = e.abTesting;
                            if (t && t.enableSuspendVideoTest) {
                                var n = this._getInitiatorJid();
                                return Object(a.integerHash)(n) % 2 == 0
                            }
                        }
                    }]), t
                }(s.a)
        }).call(this, "modules/xmpp/JingleSessionPC.js")
    }, function(e, t, n) {
        "use strict";
        n.r(t), n.d(t, "DEVICE_LIST_CHANGED", (function() {
            return r
        })), n.d(t, "PERMISSION_PROMPT_IS_SHOWN", (function() {
            return i
        }));
        var r = "mediaDevices.devicechange",
            i = "mediaDevices.permissionPromptIsShown"
    }, function(e, t, n) {
        var r;
        r = function() {
            var e = !0;

            function t(t) {
                function n(e) {
                    var n = t.match(e);
                    return n && n.length > 1 && n[1] || ""
                }

                function r(e) {
                    var n = t.match(e);
                    return n && n.length > 1 && n[2] || ""
                }
                var i, o = n(/(ipod|iphone|ipad)/i).toLowerCase(),
                    a = !/like android/i.test(t) && /android/i.test(t),
                    s = /nexus\s*[0-6]\s*/i.test(t),
                    c = !s && /nexus\s*[0-9]+/i.test(t),
                    u = /CrOS/.test(t),
                    l = /silk/i.test(t),
                    d = /sailfish/i.test(t),
                    p = /tizen/i.test(t),
                    h = /(web|hpw)os/i.test(t),
                    f = /windows phone/i.test(t),
                    m = (/SamsungBrowser/i.test(t), !f && /windows/i.test(t)),
                    v = !o && !l && /macintosh/i.test(t),
                    y = !a && !d && !p && !h && /linux/i.test(t),
                    g = r(/edg([ea]|ios)\/(\d+(\.\d+)?)/i),
                    _ = n(/version\/(\d+(\.\d+)?)/i),
                    S = /tablet/i.test(t) && !/tablet pc/i.test(t),
                    b = !S && /[^-]mobi/i.test(t),
                    E = /xbox/i.test(t);
                /opera/i.test(t) ? i = {
                    name: "Opera",
                    opera: e,
                    version: _ || n(/(?:opera|opr|opios)[\s\/](\d+(\.\d+)?)/i)
                } : /opr\/|opios/i.test(t) ? i = {
                    name: "Opera",
                    opera: e,
                    version: n(/(?:opr|opios)[\s\/](\d+(\.\d+)?)/i) || _
                } : /SamsungBrowser/i.test(t) ? i = {
                    name: "Samsung Internet for Android",
                    samsungBrowser: e,
                    version: _ || n(/(?:SamsungBrowser)[\s\/](\d+(\.\d+)?)/i)
                } : /coast/i.test(t) ? i = {
                    name: "Opera Coast",
                    coast: e,
                    version: _ || n(/(?:coast)[\s\/](\d+(\.\d+)?)/i)
                } : /yabrowser/i.test(t) ? i = {
                    name: "Yandex Browser",
                    yandexbrowser: e,
                    version: _ || n(/(?:yabrowser)[\s\/](\d+(\.\d+)?)/i)
                } : /ucbrowser/i.test(t) ? i = {
                    name: "UC Browser",
                    ucbrowser: e,
                    version: n(/(?:ucbrowser)[\s\/](\d+(?:\.\d+)+)/i)
                } : /mxios/i.test(t) ? i = {
                    name: "Maxthon",
                    maxthon: e,
                    version: n(/(?:mxios)[\s\/](\d+(?:\.\d+)+)/i)
                } : /epiphany/i.test(t) ? i = {
                    name: "Epiphany",
                    epiphany: e,
                    version: n(/(?:epiphany)[\s\/](\d+(?:\.\d+)+)/i)
                } : /puffin/i.test(t) ? i = {
                    name: "Puffin",
                    puffin: e,
                    version: n(/(?:puffin)[\s\/](\d+(?:\.\d+)?)/i)
                } : /sleipnir/i.test(t) ? i = {
                    name: "Sleipnir",
                    sleipnir: e,
                    version: n(/(?:sleipnir)[\s\/](\d+(?:\.\d+)+)/i)
                } : /k-meleon/i.test(t) ? i = {
                    name: "K-Meleon",
                    kMeleon: e,
                    version: n(/(?:k-meleon)[\s\/](\d+(?:\.\d+)+)/i)
                } : f ? (i = {
                    name: "Windows Phone",
                    osname: "Windows Phone",
                    windowsphone: e
                }, g ? (i.msedge = e, i.version = g) : (i.msie = e, i.version = n(/iemobile\/(\d+(\.\d+)?)/i))) : /msie|trident/i.test(t) ? i = {
                    name: "Internet Explorer",
                    msie: e,
                    version: n(/(?:msie |rv:)(\d+(\.\d+)?)/i)
                } : u ? i = {
                    name: "Chrome",
                    osname: "Chrome OS",
                    chromeos: e,
                    chromeBook: e,
                    chrome: e,
                    version: n(/(?:chrome|crios|crmo)\/(\d+(\.\d+)?)/i)
                } : /edg([ea]|ios)/i.test(t) ? i = {
                    name: "Microsoft Edge",
                    msedge: e,
                    version: g
                } : /vivaldi/i.test(t) ? i = {
                    name: "Vivaldi",
                    vivaldi: e,
                    version: n(/vivaldi\/(\d+(\.\d+)?)/i) || _
                } : d ? i = {
                    name: "Sailfish",
                    osname: "Sailfish OS",
                    sailfish: e,
                    version: n(/sailfish\s?browser\/(\d+(\.\d+)?)/i)
                } : /seamonkey\//i.test(t) ? i = {
                    name: "SeaMonkey",
                    seamonkey: e,
                    version: n(/seamonkey\/(\d+(\.\d+)?)/i)
                } : /firefox|iceweasel|fxios/i.test(t) ? (i = {
                    name: "Firefox",
                    firefox: e,
                    version: n(/(?:firefox|iceweasel|fxios)[ \/](\d+(\.\d+)?)/i)
                }, /\((mobile|tablet);[^\)]*rv:[\d\.]+\)/i.test(t) && (i.firefoxos = e, i.osname = "Firefox OS")) : l ? i = {
                    name: "Amazon Silk",
                    silk: e,
                    version: n(/silk\/(\d+(\.\d+)?)/i)
                } : /phantom/i.test(t) ? i = {
                    name: "PhantomJS",
                    phantom: e,
                    version: n(/phantomjs\/(\d+(\.\d+)?)/i)
                } : /slimerjs/i.test(t) ? i = {
                    name: "SlimerJS",
                    slimer: e,
                    version: n(/slimerjs\/(\d+(\.\d+)?)/i)
                } : /blackberry|\bbb\d+/i.test(t) || /rim\stablet/i.test(t) ? i = {
                    name: "BlackBerry",
                    osname: "BlackBerry OS",
                    blackberry: e,
                    version: _ || n(/blackberry[\d]+\/(\d+(\.\d+)?)/i)
                } : h ? (i = {
                    name: "WebOS",
                    osname: "WebOS",
                    webos: e,
                    version: _ || n(/w(?:eb)?osbrowser\/(\d+(\.\d+)?)/i)
                }, /touchpad\//i.test(t) && (i.touchpad = e)) : /bada/i.test(t) ? i = {
                    name: "Bada",
                    osname: "Bada",
                    bada: e,
                    version: n(/dolfin\/(\d+(\.\d+)?)/i)
                } : p ? i = {
                    name: "Tizen",
                    osname: "Tizen",
                    tizen: e,
                    version: n(/(?:tizen\s?)?browser\/(\d+(\.\d+)?)/i) || _
                } : /qupzilla/i.test(t) ? i = {
                    name: "QupZilla",
                    qupzilla: e,
                    version: n(/(?:qupzilla)[\s\/](\d+(?:\.\d+)+)/i) || _
                } : /chromium/i.test(t) ? i = {
                    name: "Chromium",
                    chromium: e,
                    version: n(/(?:chromium)[\s\/](\d+(?:\.\d+)?)/i) || _
                } : /chrome|crios|crmo/i.test(t) ? i = {
                    name: "Chrome",
                    chrome: e,
                    version: n(/(?:chrome|crios|crmo)\/(\d+(\.\d+)?)/i)
                } : a ? i = {
                    name: "Android",
                    version: _
                } : /safari|applewebkit/i.test(t) ? (i = {
                    name: "Safari",
                    safari: e
                }, _ && (i.version = _)) : o ? (i = {
                    name: "iphone" == o ? "iPhone" : "ipad" == o ? "iPad" : "iPod"
                }, _ && (i.version = _)) : i = /googlebot/i.test(t) ? {
                    name: "Googlebot",
                    googlebot: e,
                    version: n(/googlebot\/(\d+(\.\d+))/i) || _
                } : {
                    name: n(/^(.*)\/(.*) /),
                    version: r(/^(.*)\/(.*) /)
                }, !i.msedge && /(apple)?webkit/i.test(t) ? (/(apple)?webkit\/537\.36/i.test(t) ? (i.name = i.name || "Blink", i.blink = e) : (i.name = i.name || "Webkit", i.webkit = e), !i.version && _ && (i.version = _)) : !i.opera && /gecko\//i.test(t) && (i.name = i.name || "Gecko", i.gecko = e, i.version = i.version || n(/gecko\/(\d+(\.\d+)?)/i)), i.windowsphone || !a && !i.silk ? !i.windowsphone && o ? (i[o] = e, i.ios = e, i.osname = "iOS") : v ? (i.mac = e, i.osname = "macOS") : E ? (i.xbox = e, i.osname = "Xbox") : m ? (i.windows = e, i.osname = "Windows") : y && (i.linux = e, i.osname = "Linux") : (i.android = e, i.osname = "Android");
                var T = "";
                i.windows ? T = function(e) {
                    switch (e) {
                        case "NT":
                            return "NT";
                        case "XP":
                            return "XP";
                        case "NT 5.0":
                            return "2000";
                        case "NT 5.1":
                            return "XP";
                        case "NT 5.2":
                            return "2003";
                        case "NT 6.0":
                            return "Vista";
                        case "NT 6.1":
                            return "7";
                        case "NT 6.2":
                            return "8";
                        case "NT 6.3":
                            return "8.1";
                        case "NT 10.0":
                            return "10";
                        default:
                            return
                    }
                }(n(/Windows ((NT|XP)( \d\d?.\d)?)/i)) : i.windowsphone ? T = n(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i) : i.mac ? T = (T = n(/Mac OS X (\d+([_\.\s]\d+)*)/i)).replace(/[_\s]/g, ".") : o ? T = (T = n(/os (\d+([_\s]\d+)*) like mac os x/i)).replace(/[_\s]/g, ".") : a ? T = n(/android[ \/-](\d+(\.\d+)*)/i) : i.webos ? T = n(/(?:web|hpw)os\/(\d+(\.\d+)*)/i) : i.blackberry ? T = n(/rim\stablet\sos\s(\d+(\.\d+)*)/i) : i.bada ? T = n(/bada\/(\d+(\.\d+)*)/i) : i.tizen && (T = n(/tizen[\/\s](\d+(\.\d+)*)/i)), T && (i.osversion = T);
                var C = !i.windows && T.split(".")[0];
                return S || c || "ipad" == o || a && (3 == C || C >= 4 && !b) || i.silk ? i.tablet = e : (b || "iphone" == o || "ipod" == o || a || s || i.blackberry || i.webos || i.bada) && (i.mobile = e), i.msedge || i.msie && i.version >= 10 || i.yandexbrowser && i.version >= 15 || i.vivaldi && i.version >= 1 || i.chrome && i.version >= 20 || i.samsungBrowser && i.version >= 4 || i.firefox && i.version >= 20 || i.safari && i.version >= 6 || i.opera && i.version >= 10 || i.ios && i.osversion && i.osversion.split(".")[0] >= 6 || i.blackberry && i.version >= 10.1 || i.chromium && i.version >= 20 ? i.a = e : i.msie && i.version < 10 || i.chrome && i.version < 20 || i.firefox && i.version < 20 || i.safari && i.version < 6 || i.opera && i.version < 10 || i.ios && i.osversion && i.osversion.split(".")[0] < 6 || i.chromium && i.version < 20 ? i.c = e : i.x = e, i
            }
            var n = t("undefined" != typeof navigator && navigator.userAgent || "");

            function r(e) {
                return e.split(".").length
            }

            function i(e, t) {
                var n, r = [];
                if (Array.prototype.map) return Array.prototype.map.call(e, t);
                for (n = 0; n < e.length; n++) r.push(t(e[n]));
                return r
            }

            function o(e) {
                for (var t = Math.max(r(e[0]), r(e[1])), n = i(e, (function(e) {
                        var n = t - r(e);
                        return i((e += new Array(n + 1).join(".0")).split("."), (function(e) {
                            return new Array(20 - e.length).join("0") + e
                        })).reverse()
                    })); --t >= 0;) {
                    if (n[0][t] > n[1][t]) return 1;
                    if (n[0][t] !== n[1][t]) return -1;
                    if (0 === t) return 0
                }
            }

            function a(e, r, i) {
                var a = n;
                "string" == typeof r && (i = r, r = void 0), void 0 === r && (r = !1), i && (a = t(i));
                var s = "" + a.version;
                for (var c in e)
                    if (e.hasOwnProperty(c) && a[c]) {
                        if ("string" != typeof e[c]) throw new Error("Browser version in the minVersion map should be a string: " + c + ": " + String(e));
                        return o([s, e[c]]) < 0
                    } return r
            }
            return n.test = function(e) {
                for (var t = 0; t < e.length; ++t) {
                    var r = e[t];
                    if ("string" == typeof r && r in n) return !0
                }
                return !1
            }, n.isUnsupportedBrowser = a, n.compareVersions = o, n.check = function(e, t, n) {
                return !a(e, t, n)
            }, n._detect = t, n.detect = t, n
        }, e.exports ? e.exports = r() : n(121)("bowser", r)
    }, function(e, t, n) {
        "use strict";
        n.d(t, "a", (function() {
            return o
        }));
        var r = n(6);

        function i(e, t) {
            if (!t) return !1;
            if (e.length !== t.length) return !1;
            for (var n = 0, r = e.length; n < r; n++)
                if (e[n] instanceof Array && t[n] instanceof Array) {
                    if (!e[n].equals(t[n])) return !1
                } else if (e[n] !== t[n]) return !1;
            return !0
        }

        function o(e, t) {
            if (this.mySDP = e, this.otherSDP = t, !e) throw new Error('"mySDP" is undefined!');
            if (!t) throw new Error('"otherSDP" is undefined!')
        }
        o.prototype.getNewMedia = function() {
            var e = this.mySDP.getMediaSsrcMap(),
                t = this.otherSDP.getMediaSsrcMap(),
                n = {};
            return Object.keys(t).forEach((function(r) {
                var o = e[r],
                    a = t[r];
                o || !a ? (Object.keys(a.ssrcs).forEach((function(e) {
                    if (-1 === Object.keys(o.ssrcs).indexOf(e)) n[r] || (n[r] = {
                        mediaindex: a.mediaindex,
                        mid: a.mid,
                        ssrcs: {},
                        ssrcGroups: []
                    }), n[r].ssrcs[e] = a.ssrcs[e];
                    else if (a.ssrcs[e].lines && o.ssrcs[e].lines) {
                        void 0 !== o.ssrcs[e].lines.find((function(e) {
                            return -1 !== e.indexOf("msid")
                        })) !== (void 0 !== a.ssrcs[e].lines.find((function(e) {
                            return -1 !== e.indexOf("msid")
                        }))) && (n[r] || (n[r] = {
                            mediaindex: a.mediaindex,
                            mid: a.mid,
                            ssrcs: {},
                            ssrcGroups: []
                        }), n[r].ssrcs[e] = a.ssrcs[e])
                    }
                })), a.ssrcGroups.forEach((function(e) {
                    for (var t = !1, s = 0; s < o.ssrcGroups.length; s++) {
                        var c = o.ssrcGroups[s];
                        if (e.semantics === c.semantics && i(e.ssrcs, c.ssrcs)) {
                            t = !0;
                            break
                        }
                    }
                    t || (n[r] || (n[r] = {
                        mediaindex: a.mediaindex,
                        mid: a.mid,
                        ssrcs: {},
                        ssrcGroups: []
                    }), n[r].ssrcGroups.push(e))
                }))) : n[r] = a
            })), n
        }, o.prototype.toJingle = function(e) {
            var t = this.getNewMedia(),
                n = !1;
            return Object.keys(t).forEach((function(i) {
                n = !0;
                var o = t[i];
                e.c("content", {
                    name: o.mid
                }), e.c("description", {
                    xmlns: "urn:xmpp:jingle:apps:rtp:1",
                    media: o.mid
                }), Object.keys(o.ssrcs).forEach((function(t) {
                    var n = o.ssrcs[t];
                    e.c("source", {
                        xmlns: "urn:xmpp:jingle:apps:rtp:ssma:0"
                    }), e.attrs({
                        ssrc: n.ssrc
                    }), n.lines.forEach((function(t) {
                        var n = t.indexOf(" "),
                            i = t.substr(n + 1);
                        if (e.c("parameter"), -1 === i.indexOf(":")) e.attrs({
                            name: i
                        });
                        else {
                            var o = i.split(":", 2),
                                a = o[0],
                                s = r.a.filterSpecialChars(o[1]);
                            e.attrs({
                                name: a
                            }), e.attrs({
                                value: s
                            })
                        }
                        e.up()
                    })), e.up()
                })), o.ssrcGroups.forEach((function(t) {
                    t.ssrcs.length && (e.c("ssrc-group", {
                        semantics: t.semantics,
                        xmlns: "urn:xmpp:jingle:apps:rtp:ssma:0"
                    }), t.ssrcs.forEach((function(t) {
                        e.c("source", {
                            ssrc: t
                        }).up()
                    })), e.up())
                })), e.up(), e.up()
            })), n
        }
    }, function(e, t) {
        var n, r, i = e.exports = {};

        function o() {
            throw new Error("setTimeout has not been defined")
        }

        function a() {
            throw new Error("clearTimeout has not been defined")
        }

        function s(e) {
            if (n === setTimeout) return setTimeout(e, 0);
            if ((n === o || !n) && setTimeout) return n = setTimeout, setTimeout(e, 0);
            try {
                return n(e, 0)
            } catch (t) {
                try {
                    return n.call(null, e, 0)
                } catch (t) {
                    return n.call(this, e, 0)
                }
            }
        }! function() {
            try {
                n = "function" == typeof setTimeout ? setTimeout : o
            } catch (e) {
                n = o
            }
            try {
                r = "function" == typeof clearTimeout ? clearTimeout : a
            } catch (e) {
                r = a
            }
        }();
        var c, u = [],
            l = !1,
            d = -1;

        function p() {
            l && c && (l = !1, c.length ? u = c.concat(u) : d = -1, u.length && h())
        }

        function h() {
            if (!l) {
                var e = s(p);
                l = !0;
                for (var t = u.length; t;) {
                    for (c = u, u = []; ++d < t;) c && c[d].run();
                    d = -1, t = u.length
                }
                c = null, l = !1,
                    function(e) {
                        if (r === clearTimeout) return clearTimeout(e);
                        if ((r === a || !r) && clearTimeout) return r = clearTimeout, clearTimeout(e);
                        try {
                            r(e)
                        } catch (t) {
                            try {
                                return r.call(null, e)
                            } catch (t) {
                                return r.call(this, e)
                            }
                        }
                    }(e)
            }
        }

        function f(e, t) {
            this.fun = e, this.array = t
        }

        function m() {}
        i.nextTick = function(e) {
            var t = new Array(arguments.length - 1);
            if (arguments.length > 1)
                for (var n = 1; n < arguments.length; n++) t[n - 1] = arguments[n];
            u.push(new f(e, t)), 1 !== u.length || l || s(h)
        }, f.prototype.run = function() {
            this.fun.apply(null, this.array)
        }, i.title = "browser", i.browser = !0, i.env = {}, i.argv = [], i.version = "", i.versions = {}, i.on = m, i.addListener = m, i.once = m, i.off = m, i.removeListener = m, i.removeAllListeners = m, i.emit = m, i.prependListener = m, i.prependOnceListener = m, i.listeners = function(e) {
            return []
        }, i.binding = function(e) {
            throw new Error("process.binding is not supported")
        }, i.cwd = function() {
            return "/"
        }, i.chdir = function(e) {
            throw new Error("process.chdir is not supported")
        }, i.umask = function() {
            return 0
        }
    }, function(e, t, n) {
        "use strict";
        n.r(t), n.d(t, "E2E_RTT_CHANGED", (function() {
            return r
        }));
        var r = "e2eping.e2e_rtt_changed"
    }, function(e, t, n) {
        "use strict";
        n.d(t, "a", (function() {
            return i
        }));
        window.AudioContext = window.AudioContext || window.webkitAudioContext;
        var r = null;

        function i(e, t, n) {
            this.stream = e, this.intervalId = null, this.intervalMilis = t, this.audioLevel = 0, this.callback = n
        }
        window.AudioContext && (r = new AudioContext).suspend && r.suspend(), i.prototype.start = function() {
            if (i.isLocalStatsSupported()) {
                r.resume();
                var e = r.createAnalyser();
                e.smoothingTimeConstant = .8, e.fftSize = 2048, r.createMediaStreamSource(this.stream).connect(e);
                var t = this;
                this.intervalId = setInterval((function() {
                    var n = new Uint8Array(e.frequencyBinCount);
                    e.getByteTimeDomainData(n);
                    var r, i, o, a, s = function(e) {
                        for (var t = 0, n = e.length, r = 0; r < n; r++) t < e[r] && (t = e[r]);
                        return parseFloat(((t - 127) / 128).toFixed(3))
                    }(n);
                    s !== t.audioLevel && (t.audioLevel = (r = s, i = t.audioLevel, o = 0, o = (a = i - r) > .2 ? i - .2 : a < -.4 ? i + .4 : r, parseFloat(o.toFixed(3))), t.callback(t.audioLevel))
                }), this.intervalMilis)
            }
        }, i.prototype.stop = function() {
            this.intervalId && (clearInterval(this.intervalId), this.intervalId = null)
        }, i.isLocalStatsSupported = function() {
            return Boolean(r)
        }
    }, function(e, t, n) {
        var r = n(123),
            i = {
                loadScript: function(e, t, n, i, o, a) {
                    var s = document,
                        c = s.createElement("script"),
                        u = s.getElementsByTagName("script")[0];
                    if (c.async = t, i) {
                        var l = r();
                        if (l) {
                            var d = l.src,
                                p = d.substring(0, d.lastIndexOf("/") + 1);
                            d && p && (e = p + e)
                        }
                    }
                    o && (c.onload = o), a && (c.onerror = a), c.src = e, n ? u.parentNode.insertBefore(c, u) : u.parentNode.appendChild(c)
                }
            };
        e.exports = i
    }, function(e, t, n) {
        "use strict";
        n.r(t), n.d(t, "ON", (function() {
            return r
        })), n.d(t, "OFF", (function() {
            return i
        }));
        var r = "on",
            i = "off"
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return y
            }));
            var r = n(28),
                i = n.n(r),
                o = n(4),
                a = n(16),
                s = n(9),
                c = n(10);

            function u(e) {
                return (u = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                    return typeof e
                } : function(e) {
                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                })(e)
            }

            function l(e, t) {
                for (var n = 0; n < t.length; n++) {
                    var r = t[n];
                    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                }
            }

            function d(e, t) {
                return !t || "object" !== u(t) && "function" != typeof t ? function(e) {
                    if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return e
                }(e) : t
            }

            function p(e) {
                return (p = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
                    return e.__proto__ || Object.getPrototypeOf(e)
                })(e)
            }

            function h(e, t) {
                return (h = Object.setPrototypeOf || function(e, t) {
                    return e.__proto__ = t, e
                })(e, t)
            }
            var f = Object(o.getLogger)(e),
                m = {
                    track_mute: "onmute",
                    track_unmute: "onunmute",
                    track_ended: "onended"
                };

            function v(e, t) {
                e.oninactive = t
            }
            var y = function(e) {
                function t(e, n, r, i, o, a) {
                    var s;
                    return function(e, t) {
                        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                    }(this, t), (s = d(this, p(t).call(this))).addEventListener = s.addListener, s.removeEventListener = s.off = s.removeListener, s.containers = [], s.conference = e, s.audioLevel = -1, s.type = o, s.track = r, s.videoType = a, s.handlers = new Map, s.disposed = !1, s._streamInactiveHandler = i, s._setStream(n), s
                }
                var n, r, i;
                return function(e, t) {
                    if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
                    e.prototype = Object.create(t && t.prototype, {
                        constructor: {
                            value: e,
                            writable: !0,
                            configurable: !0
                        }
                    }), t && h(e, t)
                }(t, e), n = t, (r = [{
                    key: "_setHandler",
                    value: function(e, t) {
                        if (m.hasOwnProperty(e)) {
                            if (t ? this.handlers.set(e, t) : this.handlers.delete(e), this.stream) {
                                var n = !0,
                                    r = !1,
                                    i = void 0;
                                try {
                                    for (var o, a = this.stream.getTracks()[Symbol.iterator](); !(n = (o = a.next()).done); n = !0) o.value[m[e]] = t
                                } catch (e) {
                                    r = !0, i = e
                                } finally {
                                    try {
                                        n || null == a.return || a.return()
                                    } finally {
                                        if (r) throw i
                                    }
                                }
                            }
                        } else f.error("Invalid handler type ".concat(e))
                    }
                }, {
                    key: "_unregisterHandlers",
                    value: function() {
                        if (this.stream) {
                            var e = !0,
                                t = !1,
                                n = void 0;
                            try {
                                for (var r, i = this.handlers.keys()[Symbol.iterator](); !(e = (r = i.next()).done); e = !0) {
                                    var o = r.value,
                                        a = !0,
                                        s = !1,
                                        c = void 0;
                                    try {
                                        for (var u, l = this.stream.getVideoTracks()[Symbol.iterator](); !(a = (u = l.next()).done); a = !0) u.value[m[o]] = void 0
                                    } catch (e) {
                                        s = !0, c = e
                                    } finally {
                                        try {
                                            a || null == l.return || l.return()
                                        } finally {
                                            if (s) throw c
                                        }
                                    }
                                }
                            } catch (e) {
                                t = !0, n = e
                            } finally {
                                try {
                                    e || null == i.return || i.return()
                                } finally {
                                    if (t) throw n
                                }
                            }
                            this._streamInactiveHandler && v(this.stream, void 0)
                        } else f.warn("".concat(this, ": unable to unregister handlers - no stream object"))
                    }
                }, {
                    key: "_setStream",
                    value: function(e) {
                        if (this.stream !== e && (this.stream = e, this.stream)) {
                            var t = !0,
                                n = !1,
                                r = void 0;
                            try {
                                for (var i, o = this.handlers.keys()[Symbol.iterator](); !(t = (i = o.next()).done); t = !0) {
                                    var a = i.value;
                                    this._setHandler(a, this.handlers.get(a))
                                }
                            } catch (e) {
                                n = !0, r = e
                            } finally {
                                try {
                                    t || null == o.return || o.return()
                                } finally {
                                    if (n) throw r
                                }
                            }
                            this._streamInactiveHandler && v(this.stream, this._streamInactiveHandler)
                        }
                    }
                }, {
                    key: "getType",
                    value: function() {
                        return this.type
                    }
                }, {
                    key: "isAudioTrack",
                    value: function() {
                        return this.getType() === s.a
                    }
                }, {
                    key: "isWebRTCTrackMuted",
                    value: function() {
                        return this.track && this.track.muted
                    }
                }, {
                    key: "isVideoTrack",
                    value: function() {
                        return this.getType() === s.b
                    }
                }, {
                    key: "isLocal",
                    value: function() {
                        throw new Error("Not implemented by subclass")
                    }
                }, {
                    key: "getOriginalStream",
                    value: function() {
                        return this.stream
                    }
                }, {
                    key: "getStreamId",
                    value: function() {
                        return this.stream ? this.stream.id : null
                    }
                }, {
                    key: "getTrack",
                    value: function() {
                        return this.track
                    }
                }, {
                    key: "getTrackId",
                    value: function() {
                        return this.track ? this.track.id : null
                    }
                }, {
                    key: "getUsageLabel",
                    value: function() {
                        return this.isAudioTrack() ? "mic" : this.videoType ? this.videoType : "default"
                    }
                }, {
                    key: "_maybeFireTrackAttached",
                    value: function(e) {
                        this.conference && e && this.conference._onTrackAttach(this, e)
                    }
                }, {
                    key: "attach",
                    value: function(e) {
                        this.stream && (this._onTrackAttach(e), c.a.attachMediaStream(e, this.stream)), this.containers.push(e), this._maybeFireTrackAttached(e), this._attachTTFMTracker(e)
                    }
                }, {
                    key: "detach",
                    value: function(e) {
                        for (var t = this.containers, n = t.length - 1; n >= 0; --n) {
                            var r = t[n];
                            e || (this._onTrackDetach(r), c.a.attachMediaStream(r, null)), e && r !== e || t.splice(n, 1)
                        }
                        e && (this._onTrackDetach(e), c.a.attachMediaStream(e, null))
                    }
                }, {
                    key: "_onTrackAttach",
                    value: function(e) {}
                }, {
                    key: "_onTrackDetach",
                    value: function(e) {}
                }, {
                    key: "_attachTTFMTracker",
                    value: function(e) {}
                }, {
                    key: "dispose",
                    value: function() {
                        return this.removeAllListeners(), this.disposed = !0, Promise.resolve()
                    }
                }, {
                    key: "isScreenSharing",
                    value: function() {}
                }, {
                    key: "getId",
                    value: function() {
                        return this.stream ? c.a.getStreamID(this.stream) : null
                    }
                }, {
                    key: "isActive",
                    value: function() {
                        return void 0 === this.stream.active || this.stream.active
                    }
                }, {
                    key: "setAudioLevel",
                    value: function(e, t) {
                        this.audioLevel !== e && (this.audioLevel = e, this.emit(a.TRACK_AUDIO_LEVEL_CHANGED, e, t))
                    }
                }, {
                    key: "getMSID",
                    value: function() {
                        var e = this.getStreamId(),
                            t = this.getTrackId();
                        return e && t ? "".concat(e, " ").concat(t) : null
                    }
                }, {
                    key: "setAudioOutput",
                    value: function(e) {
                        var t = this;
                        return c.a.isDeviceChangeAvailable("output") ? this.isVideoTrack() ? Promise.resolve() : Promise.all(this.containers.map((function(t) {
                            return t.setSinkId(e).catch((function(e) {
                                throw f.warn("Failed to change audio output device on element. Default or previously set audio output device will be used.", t, e), e
                            }))
                        }))).then((function() {
                            t.emit(a.TRACK_AUDIO_OUTPUT_CHANGED, e)
                        })) : Promise.reject(new Error("Audio output device change is not supported"))
                    }
                }]) && l(n.prototype, r), i && l(n, i), t
            }(i.a)
        }).call(this, "modules/RTC/JitsiTrack.js")
    }, function(e, t, n) {
        "use strict";

        function r(e) {
            var t = e;
            return e >= Number.MAX_SAFE_INTEGER && (t = 0), t + 1
        }
        n.d(t, "a", (function() {
            return r
        }))
    }, function(e, t) {
        function n(e, t) {
            for (var n = 0; n < t.length; n++) {
                var r = t[n];
                r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
            }
        }
        var r = function() {
            function e(t, n, r) {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this._userId = t, this.setDisplayName(n), this._isLocalStats = r || !1, this.setDominantSpeaker(!1), this.totalDominantSpeakerTime = 0, this._dominantSpeakerStart = 0, this._hasLeft = !1
            }
            var t, r, i;
            return t = e, (r = [{
                key: "getUserId",
                value: function() {
                    return this._userId
                }
            }, {
                key: "getDisplayName",
                value: function() {
                    return this.displayName
                }
            }, {
                key: "setDisplayName",
                value: function(e) {
                    this.displayName = e
                }
            }, {
                key: "isLocalStats",
                value: function() {
                    return this._isLocalStats
                }
            }, {
                key: "isDominantSpeaker",
                value: function() {
                    return this._dominantSpeakerStart > 0
                }
            }, {
                key: "setDominantSpeaker",
                value: function(e) {
                    if (!this.isDominantSpeaker() && e) this._dominantSpeakerStart = Date.now();
                    else if (this.isDominantSpeaker() && !e) {
                        var t = Date.now() - this._dominantSpeakerStart;
                        this.totalDominantSpeakerTime += t, this._dominantSpeakerStart = 0
                    }
                }
            }, {
                key: "getTotalDominantSpeakerTime",
                value: function() {
                    var e = this.totalDominantSpeakerTime;
                    return this.isDominantSpeaker() && (e += Date.now() - this._dominantSpeakerStart), e
                }
            }, {
                key: "hasLeft",
                value: function() {
                    return this._hasLeft
                }
            }, {
                key: "markAsHasLeft",
                value: function() {
                    this._hasLeft = !0, this.setDominantSpeaker(!1)
                }
            }]) && n(t.prototype, r), i && n(t, i), e
        }();
        e.exports = r
    }, function(e, t) {
        e.exports = {
            IDENTITY_UPDATED: "authentication.identity_updated"
        }
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return A
            }));
            var r = n(4),
                i = n(53),
                o = n(15),
                a = n(12),
                s = n(16),
                c = n(3),
                u = n(10),
                l = n(39),
                d = n.n(l),
                p = n(9),
                h = n(8),
                f = n.n(h),
                m = n(14),
                v = n.n(m),
                y = n(7),
                g = n(5);

            function _(e) {
                return (_ = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                    return typeof e
                } : function(e) {
                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                })(e)
            }

            function S(e, t) {
                for (var n = 0; n < t.length; n++) {
                    var r = t[n];
                    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                }
            }

            function b(e, t, n) {
                return (b = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function(e, t, n) {
                    var r = function(e, t) {
                        for (; !Object.prototype.hasOwnProperty.call(e, t) && null !== (e = E(e)););
                        return e
                    }(e, t);
                    if (r) {
                        var i = Object.getOwnPropertyDescriptor(r, t);
                        return i.get ? i.get.call(n) : i.value
                    }
                })(e, t, n || e)
            }

            function E(e) {
                return (E = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
                    return e.__proto__ || Object.getPrototypeOf(e)
                })(e)
            }

            function T(e, t) {
                return (T = Object.setPrototypeOf || function(e, t) {
                    return e.__proto__ = t, e
                })(e, t)
            }

            function C(e) {
                if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return e
            }
            var R = Object(r.getLogger)(e),
                A = function(e) {
                    function t(e) {
                        var n, r = e.deviceId,
                            i = e.facingMode,
                            o = e.mediaType,
                            a = e.resolution,
                            l = e.rtcId,
                            d = e.sourceId,
                            p = e.sourceType,
                            h = e.stream,
                            m = e.track,
                            v = e.videoType,
                            y = e.effects,
                            g = void 0 === y ? [] : y;
                        ! function(e, t) {
                            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                        }(this, t), (n = function(e, t) {
                            return !t || "object" !== _(t) && "function" != typeof t ? C(e) : t
                        }(this, E(t).call(this, null, h, m, (function() {
                            return n.emit(s.LOCAL_TRACK_STOPPED)
                        }), o, v)))._setEffectInProgress = !1;
                        var S = g.find((function(e) {
                            return e.isEnabled(C(C(n)))
                        }));
                        return S && n._startStreamEffect(S), n.rtcId = l, n.sourceId = d, n.sourceType = p, c.a.usesNewGumFlow() ? (n.resolution = m.getSettings().height, n._constraints = m.getConstraints()) : n.resolution = c.a.isFirefox() ? null : a, n.deviceId = r, n._prevSetMuted = Promise.resolve(), n._facingMode = i, n._trackEnded = !1, n._hasSentData = !1, n._testDataSent = !0, n._realDeviceId = "" === n.deviceId ? void 0 : n.deviceId, n._trackMutedTS = 0, n._onDeviceListWillChange = function(e) {
                            var t = n._realDeviceId;
                            n._setRealDeviceIdFromDeviceList(e), (void 0 === n.getTrack().readyState && void 0 !== n._realDeviceId && !e.find((function(e) {
                                return e.deviceId === n._realDeviceId
                            })) || void 0 !== t && void 0 === n._realDeviceId) && (n._trackEnded = !0)
                        }, n.isAudioTrack() && u.a.isDeviceChangeAvailable("output") && (n._onAudioOutputDeviceChanged = n.setAudioOutput.bind(C(C(n))), u.a.addListener(f.a.AUDIO_OUTPUT_DEVICE_CHANGED, n._onAudioOutputDeviceChanged)), u.a.addListener(f.a.DEVICE_LIST_WILL_CHANGE, n._onDeviceListWillChange), n._initNoDataFromSourceHandlers(), n
                    }
                    var n, r, i;
                    return function(e, t) {
                        if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
                        e.prototype = Object.create(t && t.prototype, {
                            constructor: {
                                value: e,
                                writable: !0,
                                configurable: !0
                            }
                        }), t && T(e, t)
                    }(t, e), n = t, (r = [{
                        key: "isEnded",
                        value: function() {
                            return this.isVideoTrack() && this.isMuted() ? this._trackEnded : "ended" === this.getTrack().readyState || this._trackEnded
                        }
                    }, {
                        key: "_initNoDataFromSourceHandlers",
                        value: function() {
                            var e = this;
                            this._isNoDataFromSourceEventsEnabled() && (this._setHandler("track_mute", (function() {
                                e._trackMutedTS = window.performance.now(), e._fireNoDataFromSourceEvent()
                            })), this._setHandler("track_unmute", (function() {
                                e._fireNoDataFromSourceEvent(), g.a.sendAnalyticsAndLog(y.s, {
                                    media_type: e.getType(),
                                    track_type: "local",
                                    value: window.performance.now() - e._trackMutedTS
                                })
                            })), this.isVideoTrack() && this.videoType === v.a.CAMERA && this._setHandler("track_ended", (function() {
                                e.isReceivingData() || e._fireNoDataFromSourceEvent()
                            })))
                        }
                    }, {
                        key: "_isNoDataFromSourceEventsEnabled",
                        value: function() {
                            return !this.isVideoTrack() || this.videoType !== v.a.DESKTOP
                        }
                    }, {
                        key: "_fireNoDataFromSourceEvent",
                        value: function() {
                            var e = !this.isReceivingData();
                            this.emit(s.NO_DATA_FROM_SOURCE, e), g.a.sendAnalytics(Object(y.G)(this.getType(), e)), g.a.sendLog(JSON.stringify({
                                name: s.NO_DATA_FROM_SOURCE,
                                log: e
                            }))
                        }
                    }, {
                        key: "_setRealDeviceIdFromDeviceList",
                        value: function(e) {
                            var t = this.getTrack(),
                                n = "".concat(t.kind, "input"),
                                r = e.find((function(e) {
                                    return e.kind === n && e.label === t.label
                                }));
                            if (!r && "default" === this._realDeviceId) {
                                var i = (t.label || "").replace("Default - ", "");
                                r = e.find((function(e) {
                                    return e.kind === n && e.label === i
                                }))
                            }
                            this._realDeviceId = r ? r.deviceId : void 0
                        }
                    }, {
                        key: "_setStream",
                        value: function(e) {
                            b(E(t.prototype), "_setStream", this).call(this, e), e ? (this.storedMSID = this.getMSID(), R.debug("Setting new MSID: ".concat(this.storedMSID, " on ").concat(this))) : R.debug("Setting 'null' stream on ".concat(this))
                        }
                    }, {
                        key: "_startStreamEffect",
                        value: function(e) {
                            this._streamEffect = e, this._originalStream = this.stream, this._setStream(this._streamEffect.startEffect(this._originalStream))
                        }
                    }, {
                        key: "_stopStreamEffect",
                        value: function() {
                            this._streamEffect && (this._streamEffect.stopEffect(), this._setStream(this._originalStream), this._originalStream = void 0)
                        }
                    }, {
                        key: "_switchStreamEffect",
                        value: function(e) {
                            this._streamEffect && (this._stopStreamEffect(), this._streamEffect = void 0), e && this._startStreamEffect(e)
                        }
                    }, {
                        key: "setEffect",
                        value: function(e) {
                            var t = this;
                            if (void 0 === this._streamEffect && void 0 === e) return Promise.resolve();
                            if (void 0 !== e && !e.isEnabled(this)) return Promise.reject(new Error("Incompatible effect instance!"));
                            if (!0 === this._setEffectInProgress) return Promise.reject(new Error("setEffect already in progress!"));
                            if (this.isMuted()) return this._streamEffect = e, Promise.resolve();
                            var n = this.conference;
                            return n ? (this._setEffectInProgress = !0, n.removeTrack(this).then((function() {
                                return t._switchStreamEffect(e), t.isVideoTrack() && t.containers.forEach((function(e) {
                                    return u.a.attachMediaStream(e, t.stream)
                                })), n.addTrack(t)
                            })).then((function() {
                                t._setEffectInProgress = !1
                            })).catch((function(e) {
                                throw t._setEffectInProgress = !1, t._switchStreamEffect(), R.error("Failed to switch to the new stream!", e), e
                            }))) : (this._switchStreamEffect(e), Promise.resolve())
                        }
                    }, {
                        key: "mute",
                        value: function() {
                            return this._queueSetMuted(!0)
                        }
                    }, {
                        key: "unmute",
                        value: function() {
                            return this._queueSetMuted(!1)
                        }
                    }, {
                        key: "_queueSetMuted",
                        value: function(e) {
                            var t = this._setMuted.bind(this, e);
                            return this._prevSetMuted = this._prevSetMuted.then(t, t), this._prevSetMuted
                        }
                    }, {
                        key: "_setMuted",
                        value: function(e) {
                            var t = this;
                            if (this.isMuted() === e) return Promise.resolve();
                            if (this.disposed) return Promise.reject(new o.a(a.TRACK_IS_DISPOSED));
                            var n = Promise.resolve(),
                                r = function() {
                                    return R.info("Mute ".concat(t, ": ").concat(e))
                                };
                            if (this.isAudioTrack() || this.videoType === v.a.DESKTOP || !c.a.doesVideoMuteByStreamRemove()) r(), this.track && (this.track.enabled = !e);
                            else if (e) n = new Promise((function(e, n) {
                                r(), t._removeStreamFromConferenceAsMute((function() {
                                    t._streamEffect && t._stopStreamEffect(), t._unregisterHandlers(), t.stopStream(), t._setStream(null), e()
                                }), n)
                            }));
                            else {
                                r();
                                var i = {
                                    cameraDeviceId: this.getDeviceId(),
                                    devices: [p.b],
                                    effects: this._streamEffect ? [this._streamEffect] : [],
                                    facingMode: this.getCameraFacingMode()
                                };
                                c.a.usesNewGumFlow() ? n = u.a.newObtainAudioAndVideoPermissions(Object.assign({}, i, {
                                    constraints: {
                                        video: this._constraints
                                    }
                                })) : (this.resolution && (i.resolution = this.resolution), n = u.a.obtainAudioAndVideoPermissions(i)), n.then((function(e) {
                                    var n = t.getType(),
                                        r = c.a.usesNewGumFlow() ? e.find((function(e) {
                                            return e.track.kind === n
                                        })) : e.find((function(e) {
                                            return e.mediaType === n
                                        }));
                                    if (!r) throw new o.a(a.TRACK_NO_STREAM_FOUND);
                                    return t._setStream(r.stream), t.track = r.track, t.videoType !== r.videoType && (R.warn("".concat(t, ": video type has changed after unmute!"), t.videoType, r.videoType), t.videoType = r.videoType), t._streamEffect && t._startStreamEffect(t._streamEffect), t.containers.map((function(e) {
                                        return u.a.attachMediaStream(e, t.stream)
                                    })), t._addStreamToConferenceAsUnmute()
                                }))
                            }
                            return n.then((function() {
                                return t._sendMuteStatus(e)
                            })).then((function() {
                                return t.emit(s.TRACK_MUTE_CHANGED, t)
                            }))
                        }
                    }, {
                        key: "_addStreamToConferenceAsUnmute",
                        value: function() {
                            var e = this;
                            return this.conference ? new Promise((function(t, n) {
                                e.conference._addLocalTrackAsUnmute(e).then(t, (function(e) {
                                    return n(new Error(e))
                                }))
                            })) : Promise.resolve()
                        }
                    }, {
                        key: "_removeStreamFromConferenceAsMute",
                        value: function(e, t) {
                            this.conference ? this.conference._removeLocalTrackAsMute(this).then(e, (function(e) {
                                return t(new Error(e))
                            })) : e()
                        }
                    }, {
                        key: "_sendMuteStatus",
                        value: function(e) {
                            var t = this;
                            return this.conference && this.conference.room ? new Promise((function(n) {
                                t.conference.room[t.isAudioTrack() ? "setAudioMute" : "setVideoMute"](e, n)
                            })) : Promise.resolve()
                        }
                    }, {
                        key: "dispose",
                        value: function() {
                            var e = this;
                            this._switchStreamEffect();
                            var n = Promise.resolve();
                            return this.conference && (n = this.conference.removeTrack(this)), this.stream && (this.stopStream(), this.detach()), u.a.removeListener(f.a.DEVICE_LIST_WILL_CHANGE, this._onDeviceListWillChange), this._onAudioOutputDeviceChanged && u.a.removeListener(f.a.AUDIO_OUTPUT_DEVICE_CHANGED, this._onAudioOutputDeviceChanged), n.then((function() {
                                return b(E(t.prototype), "dispose", e).call(e)
                            }))
                        }
                    }, {
                        key: "isMuted",
                        value: function() {
                            return !(this.stream && (!this.isVideoTrack() || this.isActive()) && this.track && this.track.enabled)
                        }
                    }, {
                        key: "_setConference",
                        value: function(e) {
                            this.conference = e;
                            for (var t = 0; t < this.containers.length; t++) this._maybeFireTrackAttached(this.containers[t])
                        }
                    }, {
                        key: "isLocal",
                        value: function() {
                            return !0
                        }
                    }, {
                        key: "getDeviceId",
                        value: function() {
                            return this._realDeviceId || this.deviceId
                        }
                    }, {
                        key: "getParticipantId",
                        value: function() {
                            return this.conference && this.conference.myUserId()
                        }
                    }, {
                        key: "_onByteSentStatsReceived",
                        value: function(e, t) {
                            var n = this;
                            t > 0 && (this._hasSentData = !0);
                            var r = e.getConnectionState();
                            this._testDataSent && "connected" === r && (setTimeout((function() {
                                n._hasSentData || (R.warn("".concat(n, " 'bytes sent' <= 0:                         ").concat(t)), g.a.analytics.sendEvent(y.r, {
                                    media_type: n.getType()
                                }))
                            }), 3e3), this._testDataSent = !1)
                        }
                    }, {
                        key: "getCameraFacingMode",
                        value: function() {
                            if (this.isVideoTrack() && this.videoType === v.a.CAMERA) {
                                var e;
                                try {
                                    e = this.track.getSettings()
                                } catch (e) {}
                                return e && "facingMode" in e ? e.facingMode : void 0 !== this._facingMode ? this._facingMode : d.a.USER
                            }
                        }
                    }, {
                        key: "stopStream",
                        value: function() {
                            this._stopStreamInProgress = !0;
                            try {
                                u.a.stopMediaStream(this.stream)
                            } finally {
                                this._stopStreamInProgress = !1
                            }
                        }
                    }, {
                        key: "_switchCamera",
                        value: function() {
                            this.isVideoTrack() && this.videoType === v.a.CAMERA && "function" == typeof this.track._switchCamera && (this.track._switchCamera(), this._facingMode = this._facingMode === d.a.ENVIRONMENT ? d.a.USER : d.a.ENVIRONMENT)
                        }
                    }, {
                        key: "isReceivingData",
                        value: function() {
                            return !(!this.isVideoTrack() || !this.isMuted() && !this._stopStreamInProgress && this.videoType !== v.a.DESKTOP) || !!this.stream && (this._effectEnabled ? this._originalStream : this.stream).getTracks().some((function(e) {
                                return !("readyState" in e && "live" !== e.readyState || "muted" in e && !0 === e.muted)
                            }))
                        }
                    }, {
                        key: "toString",
                        value: function() {
                            return "LocalTrack[".concat(this.rtcId, ",").concat(this.getType(), "]")
                        }
                    }]) && S(n.prototype, r), i && S(n, i), t
                }(i.a)
        }).call(this, "modules/RTC/JitsiLocalTrack.js")
    }, function(e, t, n) {
        "use strict";
        n.d(t, "a", (function() {
            return a
        }));
        var r = n(1),
            i = n(42);

        function o(e, t) {
            for (var n = 0; n < t.length; n++) {
                var r = t[n];
                r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
            }
        }
        var a = function() {
            function e() {
                var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this._connection = t.connection, this._mode = t.mode, this._setSessionID(t.sessionID), this.setStatus(t.status)
            }
            var t, n, a;
            return t = e, (n = [{
                key: "getError",
                value: function() {
                    return this._error
                }
            }, {
                key: "getID",
                value: function() {
                    return this._sessionID
                }
            }, {
                key: "getInitiator",
                value: function() {
                    return this._initiator
                }
            }, {
                key: "getLiveStreamViewURL",
                value: function() {
                    return this._liveStreamViewURL
                }
            }, {
                key: "getStatus",
                value: function() {
                    return this._status
                }
            }, {
                key: "getTerminator",
                value: function() {
                    return this._terminator
                }
            }, {
                key: "getMode",
                value: function() {
                    return this._mode
                }
            }, {
                key: "setError",
                value: function(e) {
                    this._error = e
                }
            }, {
                key: "setLiveStreamViewURL",
                value: function(e) {
                    this._liveStreamViewURL = e
                }
            }, {
                key: "setStatus",
                value: function(e) {
                    this._status = e
                }
            }, {
                key: "setInitiator",
                value: function(e) {
                    this._initiator = e
                }
            }, {
                key: "setTerminator",
                value: function(e) {
                    this._terminator = e
                }
            }, {
                key: "start",
                value: function(e) {
                    var t = this,
                        n = e.appData,
                        r = e.broadcastId,
                        o = e.focusMucJid,
                        a = e.streamId;
                    return new Promise((function(e, s) {
                        t._connection.sendIQ(t._createIQ({
                            action: "start",
                            appData: n,
                            focusMucJid: o,
                            broadcastId: r,
                            streamId: a
                        }), (function(n) {
                            t.setStatus("pending"), t._setSessionID(i.a.getSessionIdFromIq(n)), e()
                        }), (function(e) {
                            t._setErrorFromIq(e), s(e)
                        }))
                    }))
                }
            }, {
                key: "stop",
                value: function(e) {
                    var t = this,
                        n = e.focusMucJid;
                    return new Promise((function(e, r) {
                        t._connection.sendIQ(t._createIQ({
                            action: "stop",
                            focusMucJid: n
                        }), e, r)
                    }))
                }
            }, {
                key: "_createIQ",
                value: function(e) {
                    var t = e.action,
                        n = e.appData,
                        i = e.broadcastId,
                        o = e.focusMucJid,
                        a = e.streamId;
                    return Object(r.$iq)({
                        to: o,
                        type: "set"
                    }).c("jibri", {
                        xmlns: "http://jitsi.org/protocol/jibri",
                        action: t,
                        app_data: n,
                        recording_mode: this._mode,
                        streamid: a,
                        you_tube_broadcast_id: i
                    }).up()
                }
            }, {
                key: "_setErrorFromIq",
                value: function(e) {
                    var t = e.getElementsByTagName("error")[0];
                    this.setError(t.children[0].tagName)
                }
            }, {
                key: "_setSessionID",
                value: function(e) {
                    this._sessionID = e
                }
            }]) && o(t.prototype, n), a && o(t, a), e
        }()
    }, function(e, t, n) {
        "use strict";
        var r = n(28),
            i = n.n(r),
            o = n(9),
            a = n(3),
            s = n(13),
            c = n(8),
            u = n.n(c),
            l = n(5),
            d = n(45);

        function p(e, t, n) {
            return t in e ? Object.defineProperty(e, t, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : e[t] = n, e
        }

        function h(e, t) {
            for (var n = 0; n < t.length; n++) {
                var r = t[n];
                r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
            }
        }
        var f = "camera",
            m = function() {
                function e() {
                    var t = this;
                    ! function(e, t) {
                        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                    }(this, e), this._eventEmitter = new i.a, this._grantedPermissions = {}, s.a.addListener(u.a.DEVICE_LIST_CHANGED, (function(e) {
                        return t._eventEmitter.emit(d.DEVICE_LIST_CHANGED, e)
                    })), s.a.addListener(u.a.DEVICE_LIST_AVAILABLE, (function(e) {
                        return t._logOutputDevice(t.getAudioOutputDevice(), e)
                    })), s.a.addListener(u.a.GRANTED_PERMISSIONS, (function(e) {
                        return t._handleGrantedPermissions(e)
                    })), this._permissionsApiSupported = new Promise((function(e) {
                        navigator.permissions ? navigator.permissions.query({
                            name: f
                        }).then((function() {
                            return e(!0)
                        }), (function() {
                            return e(!1)
                        })) : e(!1)
                    }))
                }
                var t, n, r;
                return t = e, (n = [{
                    key: "_handleGrantedPermissions",
                    value: function(e) {
                        this._grantedPermissions = function(e) {
                            for (var t = 1; t < arguments.length; t++) {
                                var n = null != arguments[t] ? arguments[t] : {},
                                    r = Object.keys(n);
                                "function" == typeof Object.getOwnPropertySymbols && (r = r.concat(Object.getOwnPropertySymbols(n).filter((function(e) {
                                    return Object.getOwnPropertyDescriptor(n, e).enumerable
                                })))), r.forEach((function(t) {
                                    p(e, t, n[t])
                                }))
                            }
                            return e
                        }({}, this._grantedPermissions, e)
                    }
                }, {
                    key: "_logOutputDevice",
                    value: function(e, t) {
                        var n = t.find((function(t) {
                            return "audiooutput" === t.kind && t.deviceId === e
                        }));
                        n && l.a.sendActiveDeviceListEvent(s.a.getEventDataForActiveDevice(n))
                    }
                }, {
                    key: "enumerateDevices",
                    value: function(e) {
                        s.a.enumerateDevices(e)
                    }
                }, {
                    key: "isDeviceListAvailable",
                    value: function() {
                        return s.a.isDeviceListAvailable()
                    }
                }, {
                    key: "isDeviceChangeAvailable",
                    value: function(e) {
                        return s.a.isDeviceChangeAvailable(e)
                    }
                }, {
                    key: "isDevicePermissionGranted",
                    value: function(e) {
                        var t = this;
                        return new Promise((function(n) {
                            e in t._grantedPermissions ? n(t._grantedPermissions[e]) : t._permissionsApiSupported.then((function(t) {
                                if (t) {
                                    var r = [];
                                    switch (e) {
                                        case o.b:
                                            r.push(navigator.permissions.query({
                                                name: f
                                            }));
                                            break;
                                        case o.a:
                                            r.push(navigator.permissions.query({
                                                name: "microphone"
                                            }));
                                            break;
                                        default:
                                            r.push(navigator.permissions.query({
                                                name: f
                                            })), r.push(navigator.permissions.query({
                                                name: "microphone"
                                            }))
                                    }
                                    Promise.all(r).then((function(e) {
                                        return n(e.every((function(e) {
                                            return "granted" === (e.state || e.status)
                                        })))
                                    }), (function() {
                                        return n(!1)
                                    }))
                                } else n(!1)
                            }))
                        }))
                    }
                }, {
                    key: "isMultipleAudioInputSupported",
                    value: function() {
                        return !a.a.isFirefox()
                    }
                }, {
                    key: "getAudioOutputDevice",
                    value: function() {
                        return s.a.getAudioOutputDevice()
                    }
                }, {
                    key: "setAudioOutputDevice",
                    value: function(e) {
                        var t = s.a.getCurrentlyAvailableMediaDevices();
                        return t && t.length > 0 && this._logOutputDevice(e, s.a.getCurrentlyAvailableMediaDevices()), s.a.setAudioOutputDevice(e)
                    }
                }, {
                    key: "addEventListener",
                    value: function(e, t) {
                        this._eventEmitter.addListener(e, t)
                    }
                }, {
                    key: "removeEventListener",
                    value: function(e, t) {
                        this._eventEmitter.removeListener(e, t)
                    }
                }, {
                    key: "emitEvent",
                    value: function(e) {
                        for (var t, n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++) r[i - 1] = arguments[i];
                        (t = this._eventEmitter).emit.apply(t, [e].concat(r))
                    }
                }, {
                    key: "supportsVideo",
                    value: function() {
                        return a.a.supportsVideo()
                    }
                }]) && h(t.prototype, n), r && h(t, r), e
            }();
        t.a = new m
    }, function(e, t) {
        var n = {
            trace: 0,
            debug: 1,
            info: 2,
            log: 3,
            warn: 4,
            error: 5
        };
        a.consoleTransport = console;
        var r = [a.consoleTransport];
        a.addGlobalTransport = function(e) {
            -1 === r.indexOf(e) && r.push(e)
        }, a.removeGlobalTransport = function(e) {
            var t = r.indexOf(e); - 1 !== t && r.splice(t, 1)
        };
        var i = {};

        function o() {
            var e = arguments[0],
                t = arguments[1],
                o = Array.prototype.slice.call(arguments, 2);
            if (!(n[t] < e.level))
                for (var a = !(e.options.disableCallerInfo || i.disableCallerInfo) && function() {
                        var e = {
                                methodName: "",
                                fileLocation: "",
                                line: null,
                                column: null
                            },
                            t = new Error,
                            n = t.stack ? t.stack.split("\n") : [];
                        if (!n || n.length < 1) return e;
                        var r = null;
                        return n[3] && (r = n[3].match(/\s*at\s*(.+?)\s*\((\S*)\s*:(\d*)\s*:(\d*)\)/)), !r || r.length <= 4 ? (0 === n[2].indexOf("log@") ? e.methodName = n[3].substr(0, n[3].indexOf("@")) : e.methodName = n[2].substr(0, n[2].indexOf("@")), e) : (e.methodName = r[1], e.fileLocation = r[2], e.line = r[3], e.column = r[4], e)
                    }(), s = r.concat(e.transports), c = 0; c < s.length; c++) {
                    var u = s[c],
                        l = u[t];
                    if (l && "function" == typeof l) {
                        var d = [];
                        d.push((new Date).toISOString()), e.id && d.push("[" + e.id + "]"), a && a.methodName.length > 1 && d.push("<" + a.methodName + ">: ");
                        var p = d.concat(o);
                        l.bind(u).apply(u, p)
                    }
                }
        }

        function a(e, t, r, i) {
            this.id = t, this.options = i || {}, this.transports = r, this.transports || (this.transports = []), this.level = n[e];
            for (var a = Object.keys(n), s = 0; s < a.length; s++) this[a[s]] = o.bind(null, this, a[s])
        }
        a.setGlobalOptions = function(e) {
            i = e || {}
        }, a.prototype.setLevel = function(e) {
            this.level = n[e]
        }, e.exports = a, a.levels = {
            TRACE: "trace",
            DEBUG: "debug",
            INFO: "info",
            LOG: "log",
            WARN: "warn",
            ERROR: "error"
        }
    }, function(e, t) {
        e.exports = function(e) {
            return e.webpackPolyfill || (e.deprecate = function() {}, e.paths = [], e.children || (e.children = []), Object.defineProperty(e, "loaded", {
                enumerable: !0,
                get: function() {
                    return e.l
                }
            }), Object.defineProperty(e, "id", {
                enumerable: !0,
                get: function() {
                    return e.i
                }
            }), e.webpackPolyfill = 1), e
        }
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            function t(e) {
                return (t = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                    return typeof e
                } : function(e) {
                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                })(e)
            }
            var n = {
                generateIdentifier: function() {
                    return Math.random().toString(36).substr(2, 10)
                }
            };
            n.localCName = n.generateIdentifier(), n.splitLines = function(e) {
                return e.trim().split("\n").map((function(e) {
                    return e.trim()
                }))
            }, n.splitSections = function(e) {
                return e.split("\nm=").map((function(e, t) {
                    return (t > 0 ? "m=" + e : e).trim() + "\r\n"
                }))
            }, n.getDescription = function(e) {
                var t = n.splitSections(e);
                return t && t[0]
            }, n.getMediaSections = function(e) {
                var t = n.splitSections(e);
                return t.shift(), t
            }, n.matchPrefix = function(e, t) {
                return n.splitLines(e).filter((function(e) {
                    return 0 === e.indexOf(t)
                }))
            }, n.parseCandidate = function(e) {
                for (var t, n = {
                        foundation: (t = 0 === e.indexOf("a=candidate:") ? e.substring(12).split(" ") : e.substring(10).split(" "))[0],
                        component: parseInt(t[1], 10),
                        protocol: t[2].toLowerCase(),
                        priority: parseInt(t[3], 10),
                        ip: t[4],
                        address: t[4],
                        port: parseInt(t[5], 10),
                        type: t[7]
                    }, r = 8; r < t.length; r += 2) switch (t[r]) {
                    case "raddr":
                        n.relatedAddress = t[r + 1];
                        break;
                    case "rport":
                        n.relatedPort = parseInt(t[r + 1], 10);
                        break;
                    case "tcptype":
                        n.tcpType = t[r + 1];
                        break;
                    case "ufrag":
                        n.ufrag = t[r + 1], n.usernameFragment = t[r + 1];
                        break;
                    default:
                        n[t[r]] = t[r + 1]
                }
                return n
            }, n.writeCandidate = function(e) {
                var t = [];
                t.push(e.foundation), t.push(e.component), t.push(e.protocol.toUpperCase()), t.push(e.priority), t.push(e.address || e.ip), t.push(e.port);
                var n = e.type;
                return t.push("typ"), t.push(n), "host" !== n && e.relatedAddress && e.relatedPort && (t.push("raddr"), t.push(e.relatedAddress), t.push("rport"), t.push(e.relatedPort)), e.tcpType && "tcp" === e.protocol.toLowerCase() && (t.push("tcptype"), t.push(e.tcpType)), (e.usernameFragment || e.ufrag) && (t.push("ufrag"), t.push(e.usernameFragment || e.ufrag)), "candidate:" + t.join(" ")
            }, n.parseIceOptions = function(e) {
                return e.substr(14).split(" ")
            }, n.parseRtpMap = function(e) {
                var t = e.substr(9).split(" "),
                    n = {
                        payloadType: parseInt(t.shift(), 10)
                    };
                return t = t[0].split("/"), n.name = t[0], n.clockRate = parseInt(t[1], 10), n.channels = 3 === t.length ? parseInt(t[2], 10) : 1, n.numChannels = n.channels, n
            }, n.writeRtpMap = function(e) {
                var t = e.payloadType;
                void 0 !== e.preferredPayloadType && (t = e.preferredPayloadType);
                var n = e.channels || e.numChannels || 1;
                return "a=rtpmap:" + t + " " + e.name + "/" + e.clockRate + (1 !== n ? "/" + n : "") + "\r\n"
            }, n.parseExtmap = function(e) {
                var t = e.substr(9).split(" ");
                return {
                    id: parseInt(t[0], 10),
                    direction: t[0].indexOf("/") > 0 ? t[0].split("/")[1] : "sendrecv",
                    uri: t[1]
                }
            }, n.writeExtmap = function(e) {
                return "a=extmap:" + (e.id || e.preferredId) + (e.direction && "sendrecv" !== e.direction ? "/" + e.direction : "") + " " + e.uri + "\r\n"
            }, n.parseFmtp = function(e) {
                for (var t, n = {}, r = e.substr(e.indexOf(" ") + 1).split(";"), i = 0; i < r.length; i++) n[(t = r[i].trim().split("="))[0].trim()] = t[1];
                return n
            }, n.writeFmtp = function(e) {
                var t = "",
                    n = e.payloadType;
                if (void 0 !== e.preferredPayloadType && (n = e.preferredPayloadType), e.parameters && Object.keys(e.parameters).length) {
                    var r = [];
                    Object.keys(e.parameters).forEach((function(t) {
                        e.parameters[t] ? r.push(t + "=" + e.parameters[t]) : r.push(t)
                    })), t += "a=fmtp:" + n + " " + r.join(";") + "\r\n"
                }
                return t
            }, n.parseRtcpFb = function(e) {
                var t = e.substr(e.indexOf(" ") + 1).split(" ");
                return {
                    type: t.shift(),
                    parameter: t.join(" ")
                }
            }, n.writeRtcpFb = function(e) {
                var t = "",
                    n = e.payloadType;
                return void 0 !== e.preferredPayloadType && (n = e.preferredPayloadType), e.rtcpFeedback && e.rtcpFeedback.length && e.rtcpFeedback.forEach((function(e) {
                    t += "a=rtcp-fb:" + n + " " + e.type + (e.parameter && e.parameter.length ? " " + e.parameter : "") + "\r\n"
                })), t
            }, n.parseSsrcMedia = function(e) {
                var t = e.indexOf(" "),
                    n = {
                        ssrc: parseInt(e.substr(7, t - 7), 10)
                    },
                    r = e.indexOf(":", t);
                return r > -1 ? (n.attribute = e.substr(t + 1, r - t - 1), n.value = e.substr(r + 1)) : n.attribute = e.substr(t + 1), n
            }, n.parseSsrcGroup = function(e) {
                var t = e.substr(13).split(" ");
                return {
                    semantics: t.shift(),
                    ssrcs: t.map((function(e) {
                        return parseInt(e, 10)
                    }))
                }
            }, n.getMid = function(e) {
                var t = n.matchPrefix(e, "a=mid:")[0];
                if (t) return t.substr(6)
            }, n.parseFingerprint = function(e) {
                var t = e.substr(14).split(" ");
                return {
                    algorithm: t[0].toLowerCase(),
                    value: t[1]
                }
            }, n.getDtlsParameters = function(e, t) {
                return {
                    role: "auto",
                    fingerprints: n.matchPrefix(e + t, "a=fingerprint:").map(n.parseFingerprint)
                }
            }, n.writeDtlsParameters = function(e, t) {
                var n = "a=setup:" + t + "\r\n";
                return e.fingerprints.forEach((function(e) {
                    n += "a=fingerprint:" + e.algorithm + " " + e.value + "\r\n"
                })), n
            }, n.getIceParameters = function(e, t) {
                var r = n.splitLines(e);
                return {
                    usernameFragment: (r = r.concat(n.splitLines(t))).filter((function(e) {
                        return 0 === e.indexOf("a=ice-ufrag:")
                    }))[0].substr(12),
                    password: r.filter((function(e) {
                        return 0 === e.indexOf("a=ice-pwd:")
                    }))[0].substr(10)
                }
            }, n.writeIceParameters = function(e) {
                return "a=ice-ufrag:" + e.usernameFragment + "\r\na=ice-pwd:" + e.password + "\r\n"
            }, n.parseRtpParameters = function(e) {
                for (var t = {
                        codecs: [],
                        headerExtensions: [],
                        fecMechanisms: [],
                        rtcp: []
                    }, r = n.splitLines(e)[0].split(" "), i = 3; i < r.length; i++) {
                    var o = r[i],
                        a = n.matchPrefix(e, "a=rtpmap:" + o + " ")[0];
                    if (a) {
                        var s = n.parseRtpMap(a),
                            c = n.matchPrefix(e, "a=fmtp:" + o + " ");
                        switch (s.parameters = c.length ? n.parseFmtp(c[0]) : {}, s.rtcpFeedback = n.matchPrefix(e, "a=rtcp-fb:" + o + " ").map(n.parseRtcpFb), t.codecs.push(s), s.name.toUpperCase()) {
                            case "RED":
                            case "ULPFEC":
                                t.fecMechanisms.push(s.name.toUpperCase())
                        }
                    }
                }
                return n.matchPrefix(e, "a=extmap:").forEach((function(e) {
                    t.headerExtensions.push(n.parseExtmap(e))
                })), t
            }, n.writeRtpDescription = function(e, t) {
                var r = "";
                r += "m=" + e + " ", r += t.codecs.length > 0 ? "9" : "0", r += " UDP/TLS/RTP/SAVPF ", r += t.codecs.map((function(e) {
                    return void 0 !== e.preferredPayloadType ? e.preferredPayloadType : e.payloadType
                })).join(" ") + "\r\n", r += "c=IN IP4 0.0.0.0\r\n", r += "a=rtcp:9 IN IP4 0.0.0.0\r\n", t.codecs.forEach((function(e) {
                    r += n.writeRtpMap(e), r += n.writeFmtp(e), r += n.writeRtcpFb(e)
                }));
                var i = 0;
                return t.codecs.forEach((function(e) {
                    e.maxptime > i && (i = e.maxptime)
                })), i > 0 && (r += "a=maxptime:" + i + "\r\n"), r += "a=rtcp-mux\r\n", t.headerExtensions && t.headerExtensions.forEach((function(e) {
                    r += n.writeExtmap(e)
                })), r
            }, n.parseRtpEncodingParameters = function(e) {
                var t, r = [],
                    i = n.parseRtpParameters(e),
                    o = -1 !== i.fecMechanisms.indexOf("RED"),
                    a = -1 !== i.fecMechanisms.indexOf("ULPFEC"),
                    s = n.matchPrefix(e, "a=ssrc:").map((function(e) {
                        return n.parseSsrcMedia(e)
                    })).filter((function(e) {
                        return "cname" === e.attribute
                    })),
                    c = s.length > 0 && s[0].ssrc,
                    u = n.matchPrefix(e, "a=ssrc-group:FID").map((function(e) {
                        return e.substr(17).split(" ").map((function(e) {
                            return parseInt(e, 10)
                        }))
                    }));
                u.length > 0 && u[0].length > 1 && u[0][0] === c && (t = u[0][1]), i.codecs.forEach((function(e) {
                    if ("RTX" === e.name.toUpperCase() && e.parameters.apt) {
                        var n = {
                            ssrc: c,
                            codecPayloadType: parseInt(e.parameters.apt, 10)
                        };
                        c && t && (n.rtx = {
                            ssrc: t
                        }), r.push(n), o && ((n = JSON.parse(JSON.stringify(n))).fec = {
                            ssrc: c,
                            mechanism: a ? "red+ulpfec" : "red"
                        }, r.push(n))
                    }
                })), 0 === r.length && c && r.push({
                    ssrc: c
                });
                var l = n.matchPrefix(e, "b=");
                return l.length && (l = 0 === l[0].indexOf("b=TIAS:") ? parseInt(l[0].substr(7), 10) : 0 === l[0].indexOf("b=AS:") ? 1e3 * parseInt(l[0].substr(5), 10) * .95 - 16e3 : void 0, r.forEach((function(e) {
                    e.maxBitrate = l
                }))), r
            }, n.parseRtcpParameters = function(e) {
                var t = {},
                    r = n.matchPrefix(e, "a=ssrc:").map((function(e) {
                        return n.parseSsrcMedia(e)
                    })).filter((function(e) {
                        return "cname" === e.attribute
                    }))[0];
                r && (t.cname = r.value, t.ssrc = r.ssrc);
                var i = n.matchPrefix(e, "a=rtcp-rsize");
                t.reducedSize = i.length > 0, t.compound = 0 === i.length;
                var o = n.matchPrefix(e, "a=rtcp-mux");
                return t.mux = o.length > 0, t
            }, n.parseMsid = function(e) {
                var t, r = n.matchPrefix(e, "a=msid:");
                if (1 === r.length) return {
                    stream: (t = r[0].substr(7).split(" "))[0],
                    track: t[1]
                };
                var i = n.matchPrefix(e, "a=ssrc:").map((function(e) {
                    return n.parseSsrcMedia(e)
                })).filter((function(e) {
                    return "msid" === e.attribute
                }));
                return i.length > 0 ? {
                    stream: (t = i[0].value.split(" "))[0],
                    track: t[1]
                } : void 0
            }, n.parseSctpDescription = function(e) {
                var t, r = n.parseMLine(e),
                    i = n.matchPrefix(e, "a=max-message-size:");
                i.length > 0 && (t = parseInt(i[0].substr(19), 10)), isNaN(t) && (t = 65536);
                var o = n.matchPrefix(e, "a=sctp-port:");
                if (o.length > 0) return {
                    port: parseInt(o[0].substr(12), 10),
                    protocol: r.fmt,
                    maxMessageSize: t
                };
                if (n.matchPrefix(e, "a=sctpmap:").length > 0) {
                    var a = n.matchPrefix(e, "a=sctpmap:")[0].substr(10).split(" ");
                    return {
                        port: parseInt(a[0], 10),
                        protocol: a[1],
                        maxMessageSize: t
                    }
                }
            }, n.writeSctpDescription = function(e, t) {
                var n = [];
                return n = "DTLS/SCTP" !== e.protocol ? ["m=" + e.kind + " 9 " + e.protocol + " " + t.protocol + "\r\n", "c=IN IP4 0.0.0.0\r\n", "a=sctp-port:" + t.port + "\r\n"] : ["m=" + e.kind + " 9 " + e.protocol + " " + t.port + "\r\n", "c=IN IP4 0.0.0.0\r\n", "a=sctpmap:" + t.port + " " + t.protocol + " 65535\r\n"], void 0 !== t.maxMessageSize && n.push("a=max-message-size:" + t.maxMessageSize + "\r\n"), n.join("")
            }, n.generateSessionId = function() {
                return Math.random().toString().substr(2, 21)
            }, n.writeSessionBoilerplate = function(e, t, r) {
                var i = void 0 !== t ? t : 2;
                return "v=0\r\no=" + (r || "thisisadapterortc") + " " + (e || n.generateSessionId()) + " " + i + " IN IP4 127.0.0.1\r\ns=-\r\nt=0 0\r\n"
            }, n.writeMediaSection = function(e, t, r, i) {
                var o = n.writeRtpDescription(e.kind, t);
                if (o += n.writeIceParameters(e.iceGatherer.getLocalParameters()), o += n.writeDtlsParameters(e.dtlsTransport.getLocalParameters(), "offer" === r ? "actpass" : "active"), o += "a=mid:" + e.mid + "\r\n", e.direction ? o += "a=" + e.direction + "\r\n" : e.rtpSender && e.rtpReceiver ? o += "a=sendrecv\r\n" : e.rtpSender ? o += "a=sendonly\r\n" : e.rtpReceiver ? o += "a=recvonly\r\n" : o += "a=inactive\r\n", e.rtpSender) {
                    var a = "msid:" + i.id + " " + e.rtpSender.track.id + "\r\n";
                    o += "a=" + a, o += "a=ssrc:" + e.sendEncodingParameters[0].ssrc + " " + a, e.sendEncodingParameters[0].rtx && (o += "a=ssrc:" + e.sendEncodingParameters[0].rtx.ssrc + " " + a, o += "a=ssrc-group:FID " + e.sendEncodingParameters[0].ssrc + " " + e.sendEncodingParameters[0].rtx.ssrc + "\r\n")
                }
                return o += "a=ssrc:" + e.sendEncodingParameters[0].ssrc + " cname:" + n.localCName + "\r\n", e.rtpSender && e.sendEncodingParameters[0].rtx && (o += "a=ssrc:" + e.sendEncodingParameters[0].rtx.ssrc + " cname:" + n.localCName + "\r\n"), o
            }, n.getDirection = function(e, t) {
                for (var r = n.splitLines(e), i = 0; i < r.length; i++) switch (r[i]) {
                    case "a=sendrecv":
                    case "a=sendonly":
                    case "a=recvonly":
                    case "a=inactive":
                        return r[i].substr(2)
                }
                return t ? n.getDirection(t) : "sendrecv"
            }, n.getKind = function(e) {
                return n.splitLines(e)[0].split(" ")[0].substr(2)
            }, n.isRejected = function(e) {
                return "0" === e.split(" ", 2)[1]
            }, n.parseMLine = function(e) {
                var t = n.splitLines(e)[0].substr(2).split(" ");
                return {
                    kind: t[0],
                    port: parseInt(t[1], 10),
                    protocol: t[2],
                    fmt: t.slice(3).join(" ")
                }
            }, n.parseOLine = function(e) {
                var t = n.matchPrefix(e, "o=")[0].substr(2).split(" ");
                return {
                    username: t[0],
                    sessionId: t[1],
                    sessionVersion: parseInt(t[2], 10),
                    netType: t[3],
                    addressType: t[4],
                    address: t[5]
                }
            }, n.isValidSDP = function(e) {
                if ("string" != typeof e || 0 === e.length) return !1;
                for (var t = n.splitLines(e), r = 0; r < t.length; r++)
                    if (t[r].length < 2 || "=" !== t[r].charAt(1)) return !1;
                return !0
            }, "object" === t(e) && (e.exports = n)
        }).call(this, n(61)(e))
    }, function(e, t) {
        var n = e.exports = {
            v: [{
                name: "version",
                reg: /^(\d*)$/
            }],
            o: [{
                name: "origin",
                reg: /^(\S*) (\d*) (\d*) (\S*) IP(\d) (\S*)/,
                names: ["username", "sessionId", "sessionVersion", "netType", "ipVer", "address"],
                format: "%s %s %d %s IP%d %s"
            }],
            s: [{
                name: "name"
            }],
            i: [{
                name: "description"
            }],
            u: [{
                name: "uri"
            }],
            e: [{
                name: "email"
            }],
            p: [{
                name: "phone"
            }],
            z: [{
                name: "timezones"
            }],
            r: [{
                name: "repeats"
            }],
            t: [{
                name: "timing",
                reg: /^(\d*) (\d*)/,
                names: ["start", "stop"],
                format: "%d %d"
            }],
            c: [{
                name: "connection",
                reg: /^IN IP(\d) (\S*)/,
                names: ["version", "ip"],
                format: "IN IP%d %s"
            }],
            b: [{
                push: "bandwidth",
                reg: /^(TIAS|AS|CT|RR|RS):(\d*)/,
                names: ["type", "limit"],
                format: "%s:%s"
            }],
            m: [{
                reg: /^(\w*) (\d*) ([\w\/]*)(?: (.*))?/,
                names: ["type", "port", "protocol", "payloads"],
                format: "%s %d %s %s"
            }],
            a: [{
                push: "rtp",
                reg: /^rtpmap:(\d*) ([\w\-\.]*)(?:\s*\/(\d*)(?:\s*\/(\S*))?)?/,
                names: ["payload", "codec", "rate", "encoding"],
                format: function(e) {
                    return e.encoding ? "rtpmap:%d %s/%s/%s" : e.rate ? "rtpmap:%d %s/%s" : "rtpmap:%d %s"
                }
            }, {
                push: "fmtp",
                reg: /^fmtp:(\d*) ([\S| ]*)/,
                names: ["payload", "config"],
                format: "fmtp:%d %s"
            }, {
                name: "control",
                reg: /^control:(.*)/,
                format: "control:%s"
            }, {
                name: "rtcp",
                reg: /^rtcp:(\d*)(?: (\S*) IP(\d) (\S*))?/,
                names: ["port", "netType", "ipVer", "address"],
                format: function(e) {
                    return null != e.address ? "rtcp:%d %s IP%d %s" : "rtcp:%d"
                }
            }, {
                push: "rtcpFbTrrInt",
                reg: /^rtcp-fb:(\*|\d*) trr-int (\d*)/,
                names: ["payload", "value"],
                format: "rtcp-fb:%d trr-int %d"
            }, {
                push: "rtcpFb",
                reg: /^rtcp-fb:(\*|\d*) ([\w-_]*)(?: ([\w-_]*))?/,
                names: ["payload", "type", "subtype"],
                format: function(e) {
                    return null != e.subtype ? "rtcp-fb:%s %s %s" : "rtcp-fb:%s %s"
                }
            }, {
                push: "ext",
                reg: /^extmap:(\d+)(?:\/(\w+))? (\S*)(?: (\S*))?/,
                names: ["value", "direction", "uri", "config"],
                format: function(e) {
                    return "extmap:%d" + (e.direction ? "/%s" : "%v") + " %s" + (e.config ? " %s" : "")
                }
            }, {
                push: "crypto",
                reg: /^crypto:(\d*) ([\w_]*) (\S*)(?: (\S*))?/,
                names: ["id", "suite", "config", "sessionConfig"],
                format: function(e) {
                    return null != e.sessionConfig ? "crypto:%d %s %s %s" : "crypto:%d %s %s"
                }
            }, {
                name: "setup",
                reg: /^setup:(\w*)/,
                format: "setup:%s"
            }, {
                name: "mid",
                reg: /^mid:([^\s]*)/,
                format: "mid:%s"
            }, {
                name: "msid",
                reg: /^msid:(.*)/,
                format: "msid:%s"
            }, {
                name: "ptime",
                reg: /^ptime:(\d*)/,
                format: "ptime:%d"
            }, {
                name: "maxptime",
                reg: /^maxptime:(\d*)/,
                format: "maxptime:%d"
            }, {
                name: "direction",
                reg: /^(sendrecv|recvonly|sendonly|inactive)/
            }, {
                name: "icelite",
                reg: /^(ice-lite)/
            }, {
                name: "iceUfrag",
                reg: /^ice-ufrag:(\S*)/,
                format: "ice-ufrag:%s"
            }, {
                name: "icePwd",
                reg: /^ice-pwd:(\S*)/,
                format: "ice-pwd:%s"
            }, {
                name: "fingerprint",
                reg: /^fingerprint:(\S*) (\S*)/,
                names: ["type", "hash"],
                format: "fingerprint:%s %s"
            }, {
                push: "candidates",
                reg: /^candidate:(\S*) (\d*) (\S*) (\d*) (\S*) (\d*) typ (\S*)(?: raddr (\S*) rport (\d*))?(?: tcptype (\S*))?(?: generation (\d*))?(?: network-id (\d*))?(?: network-cost (\d*))?/,
                names: ["foundation", "component", "transport", "priority", "ip", "port", "type", "raddr", "rport", "tcptype", "generation", "network-id", "network-cost"],
                format: function(e) {
                    var t = "candidate:%s %d %s %d %s %d typ %s";
                    return t += null != e.raddr ? " raddr %s rport %d" : "%v%v", t += null != e.tcptype ? " tcptype %s" : "%v", null != e.generation && (t += " generation %d"), t += null != e["network-id"] ? " network-id %d" : "%v", t += null != e["network-cost"] ? " network-cost %d" : "%v"
                }
            }, {
                name: "endOfCandidates",
                reg: /^(end-of-candidates)/
            }, {
                name: "remoteCandidates",
                reg: /^remote-candidates:(.*)/,
                format: "remote-candidates:%s"
            }, {
                name: "iceOptions",
                reg: /^ice-options:(\S*)/,
                format: "ice-options:%s"
            }, {
                push: "ssrcs",
                reg: /^ssrc:(\d*) ([\w_]*)(?::(.*))?/,
                names: ["id", "attribute", "value"],
                format: function(e) {
                    var t = "ssrc:%d";
                    return null != e.attribute && (t += " %s", null != e.value && (t += ":%s")), t
                }
            }, {
                push: "ssrcGroups",
                reg: /^ssrc-group:([\x21\x23\x24\x25\x26\x27\x2A\x2B\x2D\x2E\w]*) (.*)/,
                names: ["semantics", "ssrcs"],
                format: "ssrc-group:%s %s"
            }, {
                name: "msidSemantic",
                reg: /^msid-semantic:\s?(\w*) (\S*)/,
                names: ["semantic", "token"],
                format: "msid-semantic: %s %s"
            }, {
                push: "groups",
                reg: /^group:(\w*) (.*)/,
                names: ["type", "mids"],
                format: "group:%s %s"
            }, {
                name: "rtcpMux",
                reg: /^(rtcp-mux)/
            }, {
                name: "rtcpRsize",
                reg: /^(rtcp-rsize)/
            }, {
                name: "sctpmap",
                reg: /^sctpmap:([\w_\/]*) (\S*)(?: (\S*))?/,
                names: ["sctpmapNumber", "app", "maxMessageSize"],
                format: function(e) {
                    return null != e.maxMessageSize ? "sctpmap:%s %s %s" : "sctpmap:%s %s"
                }
            }, {
                name: "xGoogleFlag",
                reg: /^x-google-flag:([^\s]*)/,
                format: "x-google-flag:%s"
            }, {
                push: "rids",
                reg: /^rid:([\d\w]+) (\w+)(?: ([\S| ]*))?/,
                names: ["id", "direction", "params"],
                format: function(e) {
                    return e.params ? "rid:%s %s %s" : "rid:%s %s"
                }
            }, {
                push: "imageattrs",
                reg: new RegExp("^imageattr:(\\d+|\\*)[\\s\\t]+(send|recv)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*)(?:[\\s\\t]+(recv|send)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*))?"),
                names: ["pt", "dir1", "attrs1", "dir2", "attrs2"],
                format: function(e) {
                    return "imageattr:%s %s %s" + (e.dir2 ? " %s %s" : "")
                }
            }, {
                name: "simulcast",
                reg: new RegExp("^simulcast:(send|recv) ([a-zA-Z0-9\\-_~;,]+)(?:\\s?(send|recv) ([a-zA-Z0-9\\-_~;,]+))?$"),
                names: ["dir1", "list1", "dir2", "list2"],
                format: function(e) {
                    return "simulcast:%s %s" + (e.dir2 ? " %s %s" : "")
                }
            }, {
                name: "simulcast_03",
                reg: /^simulcast:[\s\t]+([\S+\s\t]+)$/,
                names: ["value"],
                format: "simulcast: %s"
            }, {
                name: "framerate",
                reg: /^framerate:(\d+(?:$|\.\d+))/,
                format: "framerate:%s"
            }, {
                push: "invalid",
                names: ["value"]
            }]
        };
        Object.keys(n).forEach((function(e) {
            n[e].forEach((function(e) {
                e.reg || (e.reg = /(.*)/), e.format || (e.format = "%s")
            }))
        }))
    }, function(e, t, n) {
        var r = n(147),
            i = "audio/webm",
            o = "audio/ogg",
            a = function(e) {
                this.track = e, this.recorder = null, this.data = null, this.name = null, this.startTime = null
            };

        function s(e) {
            if (void 0 === e.recorder) throw new Error("Passed an object to startRecorder which is not a TrackRecorder object");
            e.recorder.start(), e.startTime = new Date
        }

        function c(e) {
            if (void 0 === e.recorder) throw new Error("Passed an object to stopRecorder which is not a TrackRecorder object");
            e.recorder.stop()
        }

        function u() {
            if (MediaRecorder.isTypeSupported(i)) return i;
            if (MediaRecorder.isTypeSupported(o)) return o;
            throw new Error("unable to create a MediaRecorder with the right mimetype!")
        }

        function l(e) {
            this.recorders = [], this.fileType = u(), this.isRecording = !1, this.jitsiConference = e
        }
        l.determineCorrectFileType = u, l.prototype.addTrack = function(e) {
            if (e.isAudioTrack()) {
                var t = this.instantiateTrackRecorder(e);
                this.recorders.push(t), this.updateNames(), this.isRecording && s(t)
            }
        }, l.prototype.instantiateTrackRecorder = function(e) {
            var t = new a(e),
                n = t.track.getOriginalStream(),
                r = function() {
                    if ("undefined" != typeof MediaStream) return new MediaStream;
                    throw new Error("cannot create a clean mediaStream")
                }();
            return n.getAudioTracks().forEach((function(e) {
                return r.addTrack(e)
            })), t.recorder = new MediaRecorder(r, {
                mimeType: this.fileType
            }), t.data = [], t.recorder.ondataavailable = function(e) {
                e.data.size > 0 && t.data.push(e.data)
            }, t
        }, l.prototype.removeTrack = function(e) {
            if (!e.isVideoTrack()) {
                var t, n = this.recorders;
                for (t = 0; t < n.length; t++)
                    if (n[t].track.getParticipantId() === e.getParticipantId()) {
                        var r = n[t];
                        this.isRecording ? c(r) : n.splice(t, 1)
                    } this.updateNames()
            }
        }, l.prototype.updateNames = function() {
            var e = this.jitsiConference;
            this.recorders.forEach((function(t) {
                if (t.track.isLocal()) t.name = "the transcriber";
                else {
                    var n = t.track.getParticipantId(),
                        r = e.getParticipantById(n).getDisplayName();
                    "undefined" !== r && (t.name = r)
                }
            }))
        }, l.prototype.start = function() {
            if (this.isRecording) throw new Error("audiorecorder is already recording");
            this.isRecording = !0, this.recorders.forEach((function(e) {
                return s(e)
            })), console.debug("Started the recording of the audio. There are currently ".concat(this.recorders.length, " recorders active."))
        }, l.prototype.stop = function() {
            this.isRecording = !1, this.recorders.forEach((function(e) {
                return c(e)
            })), console.debug("stopped recording")
        }, l.prototype.download = function() {
            var e = this;
            this.recorders.forEach((function(t) {
                var n = new Blob(t.data, {
                        type: e.fileType
                    }),
                    r = URL.createObjectURL(n),
                    i = document.createElement("a");
                document.body.appendChild(i), i.style = "display: none", i.href = r, i.download = "test.".concat(e.fileType.split("/")[1]), i.click(), window.URL.revokeObjectURL(r)
            }))
        }, l.prototype.getRecordingResults = function() {
            var e = this;
            if (this.isRecording) throw new Error("cannot get blobs because the AudioRecorder is still recording!");
            this.updateNames();
            var t = [];
            return this.recorders.forEach((function(n) {
                return t.push(new r(new Blob(n.data, {
                    type: e.fileType
                }), n.name, n.startTime))
            })), t
        }, l.prototype.getFileType = function() {
            return this.fileType
        }, e.exports = l
    }, function(e, t) {
        e.exports = {
            getTokenAuthUrl: function(e, t, n) {
                return "string" != typeof e ? null : e.replace("{room}", t).replace("{roleUpgrade}", !0 === n)
            }
        }
    }, function(e, t, n) {
        "use strict";
        n.d(t, "a", (function() {
            return c
        }));
        var r = n(7),
            i = n(67),
            o = n(21),
            a = n(5),
            s = n(35);

        function c(e, t, n) {
            this.appID = e, this.token = t, this.options = n, this.xmpp = new s.c(n, t), this.addEventListener(o.CONNECTION_FAILED, (function(e, t, n, i) {
                a.a.sendAnalyticsAndLog(Object(r.A)(e, t, i))
            })), this.addEventListener(o.CONNECTION_DISCONNECTED, (function(e) {
                e && a.a.sendAnalytics(r.m, {
                    message: e
                }), a.a.sendLog(JSON.stringify({
                    id: r.m,
                    msg: e
                }))
            }))
        }
        c.prototype.connect = function() {
            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            this.xmpp.connect(e.id, e.password)
        }, c.prototype.attach = function(e) {
            this.xmpp.attach(e)
        }, c.prototype.disconnect = function() {
            var e;
            return (e = this.xmpp).disconnect.apply(e, arguments)
        }, c.prototype.getJid = function() {
            return this.xmpp.getJid()
        }, c.prototype.setToken = function(e) {
            this.token = e
        }, c.prototype.initJitsiConference = function(e, t) {
            return new i.a({
                name: e,
                config: t,
                connection: this
            })
        }, c.prototype.addEventListener = function(e, t) {
            this.xmpp.addListener(e, t)
        }, c.prototype.removeEventListener = function(e, t) {
            this.xmpp.removeListener(e, t)
        }, c.prototype.getConnectionTimes = function() {
            return this.xmpp.connectionTimes
        }, c.prototype.addFeature = function(e) {
            var t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
            return this.xmpp.caps.addFeature(e, t)
        }, c.prototype.removeFeature = function(e) {
            var t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
            return this.xmpp.caps.removeFeature(e, t)
        }
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return ee
            }));
            var r = n(1),
                i = n(28),
                o = n.n(i),
                a = n(4),
                s = n(68),
                c = n.n(s),
                u = n(17),
                l = n(69),
                d = n(2),
                p = n(75),
                h = n(15),
                f = n(12),
                m = n(16),
                v = n(76),
                y = n(94),
                g = n(13),
                _ = n(101),
                S = n(3),
                b = n(102),
                E = n(103),
                T = n(41),
                C = n(104),
                R = n(105),
                A = n(106),
                w = n(107),
                k = n(32),
                O = n(108),
                I = n(109),
                P = n(110),
                D = n(5),
                N = n(111),
                L = n.n(N),
                M = n(11),
                x = n.n(M),
                j = n(33),
                F = n.n(j),
                U = n(112),
                H = n(113),
                J = n(20),
                G = n(35),
                B = n(9),
                V = n(8),
                q = n(14),
                K = n.n(q),
                W = n(7),
                z = n(0);

            function X(e) {
                return (X = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                    return typeof e
                } : function(e) {
                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                })(e)
            }

            function Q(e) {
                for (var t = 1; t < arguments.length; t++) {
                    var n = null != arguments[t] ? arguments[t] : {},
                        r = Object.keys(n);
                    "function" == typeof Object.getOwnPropertySymbols && (r = r.concat(Object.getOwnPropertySymbols(n).filter((function(e) {
                        return Object.getOwnPropertyDescriptor(n, e).enumerable
                    })))), r.forEach((function(t) {
                        Y(e, t, n[t])
                    }))
                }
                return e
            }

            function Y(e, t, n) {
                return t in e ? Object.defineProperty(e, t, {
                    value: n,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : e[t] = n, e
            }
            var Z = Object(a.getLogger)(e);

            function ee(e) {
                if (!e.name || e.name.toLowerCase() !== e.name) {
                    var t = "Invalid conference name (no conference name passed or it contains invalid characters like capital letters)!";
                    throw Z.error(t), new Error(t)
                }
                this.eventEmitter = new o.a, this.options = e, this.eventManager = new l.a(this), this.participants = {}, this._init(e), this.componentsVersions = new U.a(this), this.jvbJingleSession = null, this.lastDominantSpeaker = null, this.dtmfManager = null, this.somebodySupportsDTMF = !1, this.authEnabled = !1, this.startAudioMuted = !1, this.startVideoMuted = !1, this.startMutedPolicy = {
                    audio: !1,
                    video: !1
                }, this.isMutedByFocus = !1, this.mutedByFocusActor = null, this.wasStopped = !1, this.properties = {}, this.connectionQuality = new b.a(this, this.eventEmitter, e), this.avgRtpStatsReporter = new O.a(this, e.config.avgRtpStatsN || 15), this._audioOutputProblemDetector = new I.a(this), this.isJvbConnectionInterrupted = !1, this.speakerStatsCollector = new P.a(this), this.deferredStartP2PTask = null;
                var n = parseInt(e.config.p2p && e.config.p2p.backToP2PDelay, 10);
                this.backToP2PDelay = isNaN(n) ? 5 : n, Z.info("backToP2PDelay: ".concat(this.backToP2PDelay)), this.isP2PConnectionInterrupted = !1, this.p2p = !1, this.p2pJingleSession = null, this.videoSIPGWHandler = new H.a(this.room), this.recordingManager = new A.a(this.room)
            }
            ee.prototype.constructor = ee, ee.resourceCreator = function(e, t) {
                var n;
                if (t) n = F.a.randomHexString(8).toLowerCase();
                else {
                    n = r.Strophe.getNodeFromJid(e).substr(0, 8).toLowerCase();
                    /[0-9a-f]{8}/g.test(n) || (n = F.a.randomHexString(8).toLowerCase())
                }
                return n
            }, ee.prototype._init = function() {
                var e = this,
                    t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                t.connection && (this.connection = t.connection, this.xmpp = this.connection.xmpp, this.eventManager.setupXMPPListeners());
                var n = this.options.config,
                    r = n.statisticsId ? n.statisticsId : k.a.callStatsUserName;
                this.room = this.xmpp.createRoom(this.options.name, Q({}, n, {
                    statsId: r
                }), ee.resourceCreator), this._onIceConnectionInterrupted = this._onIceConnectionInterrupted.bind(this), this.room.addListener(z.CONNECTION_INTERRUPTED, this._onIceConnectionInterrupted), this._onIceConnectionRestored = this._onIceConnectionRestored.bind(this), this.room.addListener(z.CONNECTION_RESTORED, this._onIceConnectionRestored), this._onIceConnectionEstablished = this._onIceConnectionEstablished.bind(this), this.room.addListener(z.CONNECTION_ESTABLISHED, this._onIceConnectionEstablished), this._updateProperties = this._updateProperties.bind(this), this.room.addListener(z.CONFERENCE_PROPERTIES_CHANGED, this._updateProperties), this.rttMonitor = new w.a(n.rttMonitor || {}), this.e2eping = new C.a(this, n, (function(t, n) {
                    try {
                        e.sendMessage(t, n, !0)
                    } catch (e) {
                        Z.warn("Failed to send a ping request or response.")
                    }
                })), this.rtc || (this.rtc = new g.a(this, t), this.eventManager.setupRTCListeners()), this.participantConnectionStatus = new T.b(this.rtc, this, {
                    rtcMuteTimeout: n._peerConnStatusRtcMuteTimeout,
                    outOfLastNTimeout: n._peerConnStatusOutOfLastNTimeout
                }), this.participantConnectionStatus.init(), this.statistics || (this.statistics = new D.a(this.xmpp, {
                    aliasName: r,
                    userName: n.statisticsDisplayName ? n.statisticsDisplayName : this.myUserId(),
                    callStatsConfIDNamespace: this.connection.options.hosts.domain,
                    confID: n.confID || "".concat(this.connection.options.hosts.domain, "/").concat(this.options.name),
                    customScriptUrl: n.callStatsCustomScriptUrl,
                    callStatsID: n.callStatsID,
                    callStatsSecret: n.callStatsSecret,
                    roomName: this.options.name,
                    applicationName: n.applicationName,
                    getWiFiStatsMethod: n.getWiFiStatsMethod
                }), D.a.analytics.addPermanentProperties({
                    callstats_name: r
                })), this.eventManager.setupChatRoomListeners(), this.eventManager.setupStatisticsListeners(), n.enableTalkWhileMuted && new _.a(this, (function() {
                    return e.eventEmitter.emit(d.TALK_WHILE_MUTED)
                })), "channelLastN" in n && this.setLastN(n.channelLastN), this.jvb121Status = new R.a(this), this.p2pDominantSpeakerDetection = new y.a(this), n && n.deploymentInfo && n.deploymentInfo.userRegion && this.setLocalParticipantProperty("region", n.deploymentInfo.userRegion)
            }, ee.prototype.join = function(e) {
                var t = this;
                this.room && this.room.join(e).then((function() {
                    return t._maybeSetSITimeout()
                }))
            }, ee.prototype.authenticateAndUpgradeRole = function(e) {
                return v.a.call(this, Q({}, e, {
                    onCreateResource: ee.resourceCreator
                }))
            }, ee.prototype.isJoined = function() {
                return this.room && this.room.joined
            }, ee.prototype.isP2PEnabled = function() {
                return Boolean(this.options.config.p2p && this.options.config.p2p.enabled) || void 0 === this.options.config.p2p
            }, ee.prototype.isP2PTestModeEnabled = function() {
                return Boolean(this.options.config.testing && this.options.config.testing.p2pTestMode)
            }, ee.prototype.leave = function() {
                var e = this;
                if (this.participantConnectionStatus && (this.participantConnectionStatus.dispose(), this.participantConnectionStatus = null), this.avgRtpStatsReporter && (this.avgRtpStatsReporter.dispose(), this.avgRtpStatsReporter = null), this._audioOutputProblemDetector && (this._audioOutputProblemDetector.dispose(), this._audioOutputProblemDetector = null), this.rttMonitor && (this.rttMonitor.stop(), this.rttMonitor = null), this.e2eping && (this.e2eping.stop(), this.e2eping = null), this.getLocalTracks().forEach((function(t) {
                        return e.onLocalTrackRemoved(t)
                    })), this.rtc.closeBridgeChannel(), this.statistics && this.statistics.dispose(), this._delayedIceFailed && this._delayedIceFailed.cancel(), this.jvbJingleSession && (this.jvbJingleSession.close(), this.jvbJingleSession = null), this.p2pJingleSession && (this.p2pJingleSession.close(), this.p2pJingleSession = null), this.room) {
                    var t = this.room;
                    return t.removeListener(z.CONNECTION_INTERRUPTED, this._onIceConnectionInterrupted), t.removeListener(z.CONNECTION_RESTORED, this._onIceConnectionRestored), t.removeListener(z.CONNECTION_ESTABLISHED, this._onIceConnectionEstablished), t.removeListener(z.CONFERENCE_PROPERTIES_CHANGED, this._updateProperties), this.eventManager.removeXMPPListeners(), this.room = null, t.leave().then((function() {
                        e.rtc && e.rtc.destroy()
                    })).catch((function(t) {
                        throw e.getParticipants().forEach((function(t) {
                            return e.onMemberLeft(t.getJid())
                        })), t
                    }))
                }
                return Promise.reject(new Error("The conference is has been already left"))
            }, ee.prototype.getName = function() {
                return this.options.name
            }, ee.prototype.getConnection = function() {
                return this.connection
            }, ee.prototype.isAuthEnabled = function() {
                return this.authEnabled
            }, ee.prototype.isLoggedIn = function() {
                return Boolean(this.authIdentity)
            }, ee.prototype.getAuthLogin = function() {
                return this.authIdentity
            }, ee.prototype.isExternalAuthEnabled = function() {
                return this.room && this.room.moderator.isExternalAuthEnabled()
            }, ee.prototype.getExternalAuthUrl = function(e) {
                var t = this;
                return new Promise((function(n, r) {
                    t.isExternalAuthEnabled() ? e ? t.room.moderator.getPopupLoginUrl(n, r) : t.room.moderator.getLoginUrl(n, r) : r()
                }))
            }, ee.prototype.getLocalTracks = function(e) {
                var t = [];
                return this.rtc && (t = this.rtc.getLocalTracks(e)), t
            }, ee.prototype.getLocalAudioTrack = function() {
                return this.rtc ? this.rtc.getLocalAudioTrack() : null
            }, ee.prototype.getLocalVideoTrack = function() {
                return this.rtc ? this.rtc.getLocalVideoTrack() : null
            }, ee.prototype.on = function(e, t) {
                this.eventEmitter && this.eventEmitter.on(e, t)
            }, ee.prototype.off = function(e, t) {
                this.eventEmitter && this.eventEmitter.removeListener(e, t)
            }, ee.prototype.addEventListener = ee.prototype.on, ee.prototype.removeEventListener = ee.prototype.off, ee.prototype.addCommandListener = function(e, t) {
                this.room && this.room.addPresenceListener(e, t)
            }, ee.prototype.removeCommandListener = function(e, t) {
                this.room && this.room.removePresenceListener(e, t)
            }, ee.prototype.sendTextMessage = function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "body";
                if (this.room) {
                    var n = (this.room.getFromPresence("nick") || {}).value;
                    this.room.sendMessage(e, t, n)
                }
            }, ee.prototype.sendPrivateTextMessage = function(e, t) {
                var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "body";
                this.room && this.room.sendPrivateMessage(e, t, n)
            }, ee.prototype.sendOfMessage = function(e, t) {       // BAO
                this.room && this.room.sendOfMessage(e, t)
            }, ee.prototype.sendOfText = function(e) {       // BAO
                this.room && this.room.sendOfText(e)
            }, ee.prototype.sendOfMeet = function(e) {       // BAO
                this.room && this.room.sendOfMeet(e)
            }, ee.prototype.sendOfUpload = function(file, cb, ecb) {       // BAO
                this.room && this.room.sendOfUpload(file, cb, ecb)
            }, ee.prototype.sendCommand = function(e, t) {
                this.room ? (this.room.addToPresence(e, t), this.room.sendPresence()) : Z.warn("Not sending a command, room not initialized.")
            }, ee.prototype.sendCommandOnce = function(e, t) {
                this.sendCommand(e, t), this.removeCommand(e)
            }, ee.prototype.removeCommand = function(e) {
                this.room && this.room.removeFromPresence(e)
            }, ee.prototype.setDisplayName = function(e) {
                this.room && (this.room.removeFromPresence("nick"), this.room.addToPresence("nick", {
                    attributes: {
                        xmlns: "http://jabber.org/protocol/nick"
                    },
                    value: e
                }), this.room.sendPresence())
            }, ee.prototype.setSubject = function(e) {
                this.room && this.isModerator() && this.room.setSubject(e)
            }, ee.prototype.getTranscriber = function() {
                if (void 0 === this.transcriber) {
                    this.transcriber = new L.a;
                    var e = this.getLocalTracks(B.a),
                        t = !0,
                        n = !1,
                        r = void 0;
                    try {
                        for (var i, o = e[Symbol.iterator](); !(t = (i = o.next()).done); t = !0) {
                            var a = i.value;
                            this.transcriber.addTrack(a)
                        }
                    } catch (e) {
                        n = !0, r = e
                    } finally {
                        try {
                            t || null == o.return || o.return()
                        } finally {
                            if (n) throw r
                        }
                    }
                    var s = this.rtc.getRemoteTracks(B.a),
                        c = !0,
                        u = !1,
                        l = void 0;
                    try {
                        for (var d, p = s[Symbol.iterator](); !(c = (d = p.next()).done); c = !0) {
                            var h = d.value;
                            this.transcriber.addTrack(h)
                        }
                    } catch (e) {
                        u = !0, l = e
                    } finally {
                        try {
                            c || null == p.return || p.return()
                        } finally {
                            if (u) throw l
                        }
                    }
                }
                return this.transcriber
            }, ee.prototype.getTranscriptionStatus = function() {
                return this.room.transcriptionStatus
            }, ee.prototype.addTrack = function(e) {
                if (e.isVideoTrack()) {
                    var t = this.rtc.getLocalVideoTrack();
                    if (t) return e === t ? Promise.resolve(e) : Promise.reject(new Error("cannot add second video track to the conference"))
                }
                return this.replaceTrack(null, e)
            }, ee.prototype._fireAudioLevelChangeEvent = function(e, t) {
                var n = this.getActivePeerConnection();
                t && n !== t || this.eventEmitter.emit(d.TRACK_AUDIO_LEVEL_CHANGED, this.myUserId(), e)
            }, ee.prototype._fireMuteChangeEvent = function(e) {
                var t;
                if (this.isMutedByFocus && e.isAudioTrack() && !e.isMuted() && (this.isMutedByFocus = !1, this.room.muteParticipant(this.room.myroomjid, !1)), this.mutedByFocusActor) {
                    var n = r.Strophe.getResourceFromJid(this.mutedByFocusActor);
                    t = this.participants[n]
                }
                this.eventEmitter.emit(d.TRACK_MUTE_CHANGED, e, t)
            }, ee.prototype.onLocalTrackRemoved = function(e) {
                e._setConference(null), this.rtc.removeLocalTrack(e), e.removeEventListener(m.TRACK_MUTE_CHANGED, e.muteHandler), e.removeEventListener(m.TRACK_AUDIO_LEVEL_CHANGED, e.audioLevelHandler), e.isVideoTrack() && e.videoType === K.a.DESKTOP && this.statistics.sendScreenSharingEvent(!1), this.eventEmitter.emit(d.TRACK_REMOVED, e)
            }, ee.prototype.removeTrack = function(e) {
                return this.replaceTrack(e, null)
            }, ee.prototype.replaceTrack = function(e, t) {
                var n = this;
                return e && e.disposed ? Promise.reject(new h.a(f.TRACK_IS_DISPOSED)) : t && t.disposed ? Promise.reject(new h.a(f.TRACK_IS_DISPOSED)) : this._doReplaceTrack(e, t).then((function() {
                    return e && n.onLocalTrackRemoved(e), t && n._setupNewTrack(t), Promise.resolve()
                }), (function(e) {
                    return Promise.reject(new Error(e))
                }))
            }, ee.prototype._doReplaceTrack = function(e, t) {
                var n = [];
                return this.jvbJingleSession ? n.push(this.jvbJingleSession.replaceTrack(e, t)) : Z.info("_doReplaceTrack - no JVB JingleSession"), this.p2pJingleSession ? n.push(this.p2pJingleSession.replaceTrack(e, t)) : Z.info("_doReplaceTrack - no P2P JingleSession"), Promise.all(n)
            }, ee.prototype._setupNewTrack = function(e) {
                if (e.isAudioTrack() || e.isVideoTrack() && e.videoType !== K.a.DESKTOP) {
                    var t = g.a.getCurrentlyAvailableMediaDevices().find((function(t) {
                        return t.kind === "".concat(e.getTrack().kind, "input") && t.label === e.getTrack().label
                    }));
                    t && D.a.sendActiveDeviceListEvent(g.a.getEventDataForActiveDevice(t))
                }
                e.isVideoTrack() && (this.removeCommand("videoType"), this.sendCommand("videoType", {
                    value: e.videoType,
                    attributes: {
                        xmlns: "http://jitsi.org/jitmeet/video"
                    }
                })), this.rtc.addLocalTrack(e), e.isAudioTrack() ? this.room.setAudioMute(e.isMuted()) : this.room.setVideoMute(e.isMuted()), e.muteHandler = this._fireMuteChangeEvent.bind(this, e), e.audioLevelHandler = this._fireAudioLevelChangeEvent.bind(this), e.addEventListener(m.TRACK_MUTE_CHANGED, e.muteHandler), e.addEventListener(m.TRACK_AUDIO_LEVEL_CHANGED, e.audioLevelHandler), e._setConference(this), this.eventEmitter.emit(d.TRACK_ADDED, e)
            }, ee.prototype._addLocalTrackAsUnmute = function(e) {
                var t = [];
                return this.jvbJingleSession ? t.push(this.jvbJingleSession.addTrackAsUnmute(e)) : Z.info("Add local MediaStream as unmute - no JVB Jingle session started yet"), this.p2pJingleSession ? t.push(this.p2pJingleSession.addTrackAsUnmute(e)) : Z.info("Add local MediaStream as unmute - no P2P Jingle session started yet"), Promise.all(t)
            }, ee.prototype._removeLocalTrackAsMute = function(e) {
                var t = [];
                return this.jvbJingleSession ? t.push(this.jvbJingleSession.removeTrackAsMute(e)) : Z.info("Remove local MediaStream - no JVB JingleSession started yet"), this.p2pJingleSession ? t.push(this.p2pJingleSession.removeTrackAsMute(e)) : Z.info("Remove local MediaStream - no P2P JingleSession started yet"), Promise.all(t)
            }, ee.prototype.getRole = function() {
                return this.room.role
            }, ee.prototype.isHidden = function() {
                return this.connection ? r.Strophe.getDomainFromJid(this.connection.getJid()) === this.options.config.hiddenDomain : null
            }, ee.prototype.isModerator = function() {
                return this.room ? this.room.isModerator() : null
            }, ee.prototype.lock = function(e) {
                var t = this;
                return this.isModerator() ? new Promise((function(n, r) {
                    t.room.lockRoom(e || "", (function() {
                        return n()
                    }), (function(e) {
                        return r(e)
                    }), (function() {
                        return r(u.PASSWORD_NOT_SUPPORTED)
                    }))
                })) : Promise.reject(new Error("You are not moderator."))
            }, ee.prototype.unlock = function() {
                return this.lock()
            }, ee.prototype.selectParticipant = function(e) {
                this.selectParticipants([e])
            }, ee.prototype.selectParticipants = function(e) {
                if (!Array.isArray(e)) throw new Error("Invalid argument; participantIds must be an array.");
                this.rtc.selectEndpoints(e)
            }, ee.prototype.pinParticipant = function(e) {
                this.rtc.pinEndpoint(e)
            }, ee.prototype.getLastN = function() {
                return this.rtc.getLastN()
            }, ee.prototype.setLastN = function(e) {
                if (!Number.isInteger(e) && !Number.parseInt(e, 10)) throw new Error("Invalid value for lastN: ".concat(e));
                var t = Number(e);
                if (t < -1) throw new RangeError("lastN cannot be smaller than -1");
                if (this.rtc.setLastN(t), this.p2pJingleSession) {
                    var n = 0 !== t;
                    this.p2pJingleSession.setMediaTransferActive(!0, n).catch((function(e) {
                        Z.error("Failed to adjust video transfer status (".concat(n, ")"), e)
                    }))
                }
            }, ee.prototype.isInLastN = function(e) {
                return this.rtc.isInLastN(e)
            }, ee.prototype.getParticipants = function() {
                return Object.keys(this.participants).map((function(e) {
                    return this.participants[e]
                }), this)
            }, ee.prototype.getParticipantCount = function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
                    t = this.getParticipants();
                return e || (t = t.filter((function(e) {
                    return !e.isHidden()
                }))), t.length + 1
            }, ee.prototype.getParticipantById = function(e) {
                return this.participants[e]
            }, ee.prototype.kickParticipant = function(e) {
                var t = this.getParticipantById(e);
                t && this.room.kick(t.getJid())
            }, ee.prototype._maybeClearSITimeout = function() {
                this._sessionInitiateTimeout && (this.jvbJingleSession || this.getParticipantCount() < 2) && (window.clearTimeout(this._sessionInitiateTimeout), this._sessionInitiateTimeout = null)
            }, ee.prototype._maybeSetSITimeout = function() {
                var e = this;
                !this.jvbJingleSession && this.getParticipantCount() >= 2 && !this._sessionInitiateTimeout && (this._sessionInitiateTimeout = window.setTimeout((function() {
                    e._sessionInitiateTimeout = null, D.a.sendAnalytics(Object(W.F)(W.d, {
                        p2p: !1,
                        value: 5e3
                    }))
                }), 5e3))
            }, ee.prototype.muteParticipant = function(e) {
                var t = this.getParticipantById(e);
                t && this.room.muteParticipant(t.getJid(), !0)
            }, ee.prototype.onMemberJoined = function(e, t, n, i, o, a, s, c) {
                var u = r.Strophe.getResourceFromJid(e);
                if ("focus" !== u && this.myUserId() !== u) {
                    var l = new p.a(e, this, t, i, o, a, s);
                    l._role = n, l._botType = c, this.participants[u] = l, this.eventEmitter.emit(d.USER_JOINED, u, l), this._updateFeatures(l), this._maybeStartOrStopP2P(), this._maybeSetSITimeout()
                }
            }, ee.prototype._updateFeatures = function(e) {
                var t = this;
                e.getFeatures().then((function(n) {
                    e._supportsDTMF = n.has("urn:xmpp:jingle:dtmf:0"), t.updateDTMFSupport(), n.has("http://jitsi.org/protocol/jigasi") && e.setProperty("features_jigasi", !0)
                })).catch((function() {
                    return !1
                }))
            }, ee.prototype._onMemberBotTypeChanged = function(e, t) {
                var n = this.getParticipants().find((function(t) {
                    return t.getJid() === e
                }));
                if (n) {
                    n._botType = t;
                    var i = r.Strophe.getResourceFromJid(e);
                    this.eventEmitter.emit(d.BOT_TYPE_CHANGED, i, t)
                }
                n._botType || this._maybeStartOrStopP2P()
            }, ee.prototype.onMemberLeft = function(e) {
                var t = this,
                    n = r.Strophe.getResourceFromJid(e);
                if ("focus" !== n && this.myUserId() !== n) {
                    var i = this.participants[n];
                    delete this.participants[n], this.rtc.removeRemoteTracks(n).forEach((function(e) {
                        return t.eventEmitter.emit(d.TRACK_REMOVED, e)
                    })), i && this.eventEmitter.emit(d.USER_LEFT, n, i), this._maybeStartOrStopP2P(!0), this._maybeClearSITimeout()
                }
            }, ee.prototype.onMemberKicked = function(e, t, n) {
                var r = this.participants[t];
                if (e) return this.eventEmitter.emit(d.KICKED, r), void this.leave();
                var i = this.participants[n];
                this.eventEmitter.emit(d.PARTICIPANT_KICKED, r, i)
            }, ee.prototype.onLocalRoleChanged = function(e) {
                this.eventEmitter.emit(d.USER_ROLE_CHANGED, this.myUserId(), e)
            }, ee.prototype.onUserRoleChanged = function(e, t) {
                var n = r.Strophe.getResourceFromJid(e),
                    i = this.getParticipantById(n);
                i && (i._role = t, this.eventEmitter.emit(d.USER_ROLE_CHANGED, n, t))
            }, ee.prototype.onDisplayNameChanged = function(e, t) {
                var n = r.Strophe.getResourceFromJid(e),
                    i = this.getParticipantById(n);
                i && i._displayName !== t && (i._displayName = t, this.eventEmitter.emit(d.DISPLAY_NAME_CHANGED, n, t))
            }, ee.prototype.onRemoteTrackAdded = function(e) {
                var t = this;
                if (!e.isP2P || this.isP2PActive())
                    if (e.isP2P || !this.isP2PActive()) {
                        var n = e.getParticipantId(),
                            r = this.getParticipantById(n);
                        if (r) {
                            r._tracks.push(e), this.transcriber && this.transcriber.addTrack(e);
                            var i = this.eventEmitter;
                            e.addEventListener(m.TRACK_MUTE_CHANGED, (function() {
                                return i.emit(d.TRACK_MUTE_CHANGED, e)
                            })), e.addEventListener(m.TRACK_AUDIO_LEVEL_CHANGED, (function(e, r) {
                                t.getActivePeerConnection() === r && i.emit(d.TRACK_AUDIO_LEVEL_CHANGED, n, e)
                            })), i.emit(d.TRACK_ADDED, e)
                        } else Z.error("No participant found for id: ".concat(n))
                    } else Z.info("Trying to add remote JVB track, when in P2P - IGNORED");
                else Z.info("Trying to add remote P2P track, when not in P2P - IGNORED")
            }, ee.prototype.onCallAccepted = function(e, t) {
                this.p2pJingleSession === e && (Z.info("P2P setAnswer"), this.p2pJingleSession.setAnswer(t))
            }, ee.prototype.onTransportInfo = function(e, t) {
                this.p2pJingleSession === e && (Z.info("P2P addIceCandidates"), this.p2pJingleSession.addIceCandidates(t))
            }, ee.prototype.onRemoteTrackRemoved = function(e) {
                var t = this;
                this.getParticipants().forEach((function(n) {
                    for (var r = n.getTracks(), i = 0; i < r.length; i++)
                        if (r[i] === e) {
                            n._tracks.splice(i, 1), t.eventEmitter.emit(d.TRACK_REMOVED, e), t.transcriber && t.transcriber.removeTrack(e);
                            break
                        }
                }), this)
            }, ee.prototype._onIncomingCallP2P = function(e, t) {
                var n;
                S.a.supportsP2P() ? this.isP2PEnabled() || this.isP2PTestModeEnabled() ? this.p2pJingleSession ? n = {
                    reason: "busy",
                    reasonDescription: "P2P already in progress",
                    errorMsg: 'Duplicated P2P "session-initiate"'
                } : this._shouldBeInP2PMode() || (n = {
                    reason: "decline",
                    reasonDescription: "P2P requirements not met",
                    errorMsg: 'Received P2P "session-initiate" when should not be in P2P mode'
                }, D.a.sendAnalytics(Object(W.F)(W.h))) : n = {
                    reason: "decline",
                    reasonDescription: "P2P disabled",
                    errorMsg: "P2P mode disabled in the configuration"
                } : n = {
                    reason: "unsupported-applications",
                    reasonDescription: "P2P not supported",
                    errorMsg: "This client does not support P2P connections"
                }, n ? this._rejectIncomingCall(e, n) : this._acceptP2PIncomingCall(e, t)
            }, ee.prototype.onIncomingCall = function(e, t, n) {
                if (e.isP2P) this._onIncomingCallP2P(e, t);
                else {
                    if (!this.room.isFocus(e.remoteJid)) {
                        var r = "Rejecting session-initiate from non-focus.";
                        return void this._rejectIncomingCall(e, {
                            reason: "security-error",
                            reasonDescription: r,
                            errorMsg: r
                        })
                    }
                    this._acceptJvbIncomingCall(e, t, n)
                }
            }, ee.prototype._acceptJvbIncomingCall = function(e, t, n) {
                var r = this;
                this.jvbJingleSession = e, this.room.connectionTimes["session.initiate"] = n, this.wasStopped && D.a.sendAnalyticsAndLog(Object(W.F)(W.a, {
                    p2p: !1
                }));
                var i = $(t).find('>bridge-session[xmlns="http://jitsi.org/protocol/focus"]').attr("region");
                this.eventEmitter.emit(d.SERVER_REGION_CHANGED, i), this._maybeClearSITimeout(), D.a.sendAnalytics(Object(W.F)(W.c, {
                    p2p: !1,
                    value: n
                }));
                try {
                    e.initialize(this.room, this.rtc, this.options.config)
                } catch (e) {
                    x.a.callErrorHandler(e)
                }
                this._setBridgeChannel(t, e.peerconnection);
                try {
                    e.acceptOffer(t, (function() {
                        r.isP2PActive() && r.jvbJingleSession && r._suspendMediaTransferForJvbConnection()
                    }), (function(e) {
                        x.a.callErrorHandler(e), Z.error("Failed to accept incoming Jingle session", e)
                    }), this.getLocalTracks()), Z.info("Starting CallStats for JVB connection..."), this.statistics.startCallStats(this.jvbJingleSession.peerconnection, "jitsi"), this.statistics.startRemoteStats(this.jvbJingleSession.peerconnection)
                } catch (e) {
                    x.a.callErrorHandler(e), Z.error(e)
                }
            }, ee.prototype._setBridgeChannel = function(e, t) {
                var n, r = null,
                    i = $(e).find(">content>transport>web-socket").first();
                switch (1 === i.length && (r = i[0].getAttribute("url")), this.options.config.openBridgeChannel) {
                    case "datachannel":
                    case !0:
                    case void 0:
                        n = "datachannel";
                        break;
                    case "websocket":
                        n = "websocket"
                }
                "datachannel" !== n || S.a.supportsDataChannels() || (n = "websocket"), "datachannel" === n ? this.rtc.initializeBridgeChannel(t, null) : "websocket" === n && r && this.rtc.initializeBridgeChannel(null, r)
            }, ee.prototype._rejectIncomingCall = function(e, t) {
                t && t.errorMsg && x.a.callErrorHandler(new Error(t.errorMsg)), e.terminate(null, (function(e) {
                    Z.warn("An error occurred while trying to terminate invalid Jingle session", e)
                }), {
                    reason: t && t.reason,
                    reasonDescription: t && t.reasonDescription,
                    sendSessionTerminate: !0
                })
            }, ee.prototype.onCallEnded = function(e, t, n) {
                Z.info("Call ended: ".concat(t, " - ").concat(n, " P2P ?").concat(e.isP2P)), e === this.jvbJingleSession ? (this.wasStopped = !0, D.a.sendAnalytics(Object(W.F)(W.e, {
                    p2p: !1
                })), this.statistics && (this.statistics.stopRemoteStats(this.jvbJingleSession.peerconnection), Z.info("Stopping JVB CallStats"), this.statistics.stopCallStats(this.jvbJingleSession.peerconnection)), this.jvbJingleSession = null, this.rtc.onCallEnded()) : e === this.p2pJingleSession ? ("decline" === t && "force JVB121" === n ? (Z.info("In forced JVB 121 mode..."), D.a.analytics.addPermanentProperties({
                    forceJvb121: !0
                })) : "connectivity-error" === t && "ICE FAILED" === n && D.a.analytics.addPermanentProperties({
                    p2pFailed: !0
                }), this._stopP2PSession()) : Z.error("Received onCallEnded for invalid session", e.sid, e.remoteJid, t, n)
            }, ee.prototype.onSuspendDetected = function(e) {
                e.isP2P || (this.leave(), this.eventEmitter.emit(d.SUSPEND_DETECTED))
            }, ee.prototype.updateDTMFSupport = function() {
                for (var e = !1, t = this.getParticipants(), n = 0; n < t.length; n += 1)
                    if (t[n].supportsDTMF()) {
                        e = !0;
                        break
                    } e !== this.somebodySupportsDTMF && (this.somebodySupportsDTMF = e, this.eventEmitter.emit(d.DTMF_SUPPORT_CHANGED, e))
            }, ee.prototype.isDTMFSupported = function() {
                return this.somebodySupportsDTMF
            }, ee.prototype.myUserId = function() {
                return this.room && this.room.myroomjid ? r.Strophe.getResourceFromJid(this.room.myroomjid) : null
            }, ee.prototype.sendTones = function(e, t, n) {
                var r = this.getActivePeerConnection();
                r ? r.sendTones(e, t, n) : Z.warn("cannot sendTones: no peer connection")
            }, ee.prototype.startRecording = function(e) {
                return this.room ? this.recordingManager.startRecording(e) : Promise.reject(new Error("The conference is not created yet!"))
            }, ee.prototype.stopRecording = function(e) {
                return this.room ? this.recordingManager.stopRecording(e) : Promise.reject(new Error("The conference is not created yet!"))
            }, ee.prototype.isSIPCallingSupported = function() {
                return !!this.room && this.room.isSIPCallingSupported()
            }, ee.prototype.dial = function(e) {
                return this.room ? this.room.dial(e) : new Promise((function(e, t) {
                    t(new Error("The conference is not created yet!"))
                }))
            }, ee.prototype.hangup = function() {
                return this.room ? this.room.hangup() : new Promise((function(e, t) {
                    t(new Error("The conference is not created yet!"))
                }))
            }, ee.prototype.startTranscriber = function() {
                return this.dial("jitsi_meet_transcribe")
            }, ee.prototype.stopTranscriber = ee.prototype.hangup, ee.prototype.getPhoneNumber = function() {
                return this.room ? this.room.getPhoneNumber() : null
            }, ee.prototype.getPhonePin = function() {
                return this.room ? this.room.getPhonePin() : null
            }, ee.prototype.getActivePeerConnection = function() {
                return this.isP2PActive() ? this.p2pJingleSession.peerconnection : this.jvbJingleSession ? this.jvbJingleSession.peerconnection : null
            }, ee.prototype.getConnectionState = function() {
                var e = this.getActivePeerConnection();
                return e ? e.getConnectionState() : null
            }, ee.prototype.setStartMutedPolicy = function(e) {
                this.isModerator() && (this.startMutedPolicy = e, this.room.removeFromPresence("startmuted"), this.room.addToPresence("startmuted", {
                    attributes: {
                        audio: e.audio,
                        video: e.video,
                        xmlns: "http://jitsi.org/jitmeet/start-muted"
                    }
                }), this.room.sendPresence())
            }, ee.prototype.getStartMutedPolicy = function() {
                return this.startMutedPolicy
            }, ee.prototype.isStartAudioMuted = function() {
                return this.startAudioMuted
            }, ee.prototype.isStartVideoMuted = function() {
                return this.startVideoMuted
            }, ee.prototype.getLogs = function() {
                var e = this.xmpp.getJingleLog(),
                    t = {};
                t.time = new Date, t.url = window.location.href, t.ua = navigator.userAgent;
                var n = this.xmpp.getXmppLog();
                return n && (t.xmpp = n), e.metadata = t, e
            }, ee.prototype.getConnectionTimes = function() {
                return this.room.connectionTimes
            }, ee.prototype.setLocalParticipantProperty = function(e, t) {
                this.sendCommand("jitsi_participant_".concat(e), {
                    value: t
                })
            }, ee.prototype.removeLocalParticipantProperty = function(e) {
                this.removeCommand("jitsi_participant_".concat(e)), this.room.sendPresence()
            }, ee.prototype.getLocalParticipantProperty = function(e) {
                var t = this.room.presMap.nodes.find((function(t) {
                    return t.tagName === "jitsi_participant_".concat(e)
                }));
                return t ? t.value : void 0
            }, ee.prototype.sendFeedback = function(e, t) {
                return this.statistics.sendFeedback(e, t)
            }, ee.prototype.isCallstatsEnabled = function() {
                return this.statistics.isCallstatsEnabled()
            }, ee.prototype._onTrackAttach = function(e, t) {
                var n = e.isLocal(),
                    r = null,
                    i = e.isP2P,
                    o = i ? e.getParticipantId() : "jitsi",
                    a = i ? this.p2pJingleSession && this.p2pJingleSession.peerconnection : this.jvbJingleSession && this.jvbJingleSession.peerconnection;
                n ? a && (r = a.getLocalSSRC(e)) : r = e.getSSRC(), t.id && r && a && this.statistics.associateStreamWithVideoTag(a, r, n, o, e.getUsageLabel(), t.id)
            }, ee.prototype.sendApplicationLog = function(e) {
                D.a.sendLog(e)
            }, ee.prototype._isFocus = function(e) {
                return this.room ? this.room.isFocus(e) : null
            }, ee.prototype._fireIncompatibleVersionsEvent = function() {
                this.eventEmitter.emit(d.CONFERENCE_FAILED, u.INCOMPATIBLE_SERVER_VERSIONS)
            }, ee.prototype.sendEndpointMessage = function(e, t) {
                this.rtc.sendChannelMessage(e, t)
            }, ee.prototype.broadcastEndpointMessage = function(e) {
                this.sendEndpointMessage("", e)
            }, ee.prototype.sendMessage = function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "",
                    n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
                    r = X(e);
                if ("object" === r || !n && "string" === r)
                    if (n) this.sendEndpointMessage(t, e);
                    else {
                        var i = e,
                            o = "body";
                        if ("object" === r) {
                            o = "json-message", i.hasOwnProperty(G.b) || (i[G.b] = "");
                            try {
                                i = JSON.stringify(i)
                            } catch (e) {
                                return void Z.error("Can not send a message, stringify failed: ", e)
                            }
                        }
                        t ? this.sendPrivateTextMessage(t, i, o) : this.sendTextMessage(i, o)
                    }
                else Z.error("Can not send a message of type ".concat(r))
            }, ee.prototype.isConnectionInterrupted = function() {
                return this.isP2PActive() ? this.isP2PConnectionInterrupted : this.isJvbConnectionInterrupted
            }, ee.prototype._onIceConnectionInterrupted = function(e) {
                e.isP2P ? this.isP2PConnectionInterrupted = !0 : this.isJvbConnectionInterrupted = !0, e.isP2P === this.isP2PActive() && this.eventEmitter.emit(d.CONNECTION_INTERRUPTED)
            }, ee.prototype._onIceConnectionFailed = function(e) {
                e.isP2P ? (D.a.analytics.addPermanentProperties({
                    p2pFailed: !0
                }), this.p2pJingleSession && D.a.sendAnalyticsAndLog(Object(W.H)(W.j, {
                    initiator: this.p2pJingleSession.isInitiator
                })), this._stopP2PSession("connectivity-error", "ICE FAILED")) : e && this.jvbJingleSession === e && (this.xmpp.isPingSupported() ? (this._delayedIceFailed = new E.a(this), this._delayedIceFailed.start(e)) : (Z.info("PING not supported - sending ICE failed immediately"), e.sendIceFailedNotification()))
            }, ee.prototype._onIceConnectionRestored = function(e) {
                e.isP2P ? this.isP2PConnectionInterrupted = !1 : (this.isJvbConnectionInterrupted = !1, this._delayedIceFailed && this._delayedIceFailed.cancel()), e.isP2P === this.isP2PActive() && this.eventEmitter.emit(d.CONNECTION_RESTORED)
            }, ee.prototype._acceptP2PIncomingCall = function(e, t) {
                this.isP2PConnectionInterrupted = !1, this.p2pJingleSession = e, this.p2pJingleSession.initialize(this.room, this.rtc, this.options.config), Z.info("Starting CallStats for P2P connection...");
                var n = r.Strophe.getResourceFromJid(this.p2pJingleSession.remoteJid),
                    i = this.participants[n];
                i && (n = i.getStatsID() || n), this.statistics.startCallStats(this.p2pJingleSession.peerconnection, n);
                var o = this.getLocalTracks();
                this.p2pJingleSession.acceptOffer(t, (function() {
                    Z.debug('Got RESULT for P2P "session-accept"')
                }), (function(e) {
                    Z.error("Failed to accept incoming P2P Jingle session", e)
                }), o)
            }, ee.prototype._addRemoteJVBTracks = function() {
                this._addRemoteTracks("JVB", this.jvbJingleSession.peerconnection.getRemoteTracks())
            }, ee.prototype._addRemoteP2PTracks = function() {
                this._addRemoteTracks("P2P", this.p2pJingleSession.peerconnection.getRemoteTracks())
            }, ee.prototype._addRemoteTracks = function(e, t) {
                var n = !0,
                    r = !1,
                    i = void 0;
                try {
                    for (var o, a = t[Symbol.iterator](); !(n = (o = a.next()).done); n = !0) {
                        var s = o.value;
                        Z.info("Adding remote ".concat(e, " track: ").concat(s)), this.rtc.eventEmitter.emit(V.REMOTE_TRACK_ADDED, s)
                    }
                } catch (e) {
                    r = !0, i = e
                } finally {
                    try {
                        n || null == a.return || a.return()
                    } finally {
                        if (r) throw i
                    }
                }
            }, ee.prototype._onIceConnectionEstablished = function(e) {
                null !== this.p2pJingleSession && (this.p2pEstablishmentDuration = this.p2pJingleSession.establishmentDuration), null !== this.jvbJingleSession && (this.jvbEstablishmentDuration = this.jvbJingleSession.establishmentDuration);
                var t = !1,
                    n = this.options.config.forceJVB121Ratio;
                if (e.isP2P ? this.p2pJingleSession !== e ? (Z.error("CONNECTION_ESTABLISHED - wrong P2P session instance ?!"), t = !0) : !e.isInitiator && "number" == typeof n && Math.random() < n && (Z.info("Forcing JVB 121 mode (ratio=".concat(n, ")...")), D.a.analytics.addPermanentProperties({
                        forceJvb121: !0
                    }), this._stopP2PSession("decline", "force JVB121"), t = !0) : t = !0, !isNaN(this.p2pEstablishmentDuration) && !isNaN(this.jvbEstablishmentDuration)) {
                    var r = this.p2pEstablishmentDuration - this.jvbEstablishmentDuration;
                    D.a.sendAnalytics(W.p, {
                        value: r
                    })
                }
                e.isP2P === this.isP2PActive() && this.eventEmitter.emit(d.CONNECTION_ESTABLISHED), t || (this._setP2PStatus(!0), this.jvbJingleSession ? this._removeRemoteJVBTracks() : Z.info("Not removing remote JVB tracks - no session yet"), this._addRemoteP2PTracks(), this.jvbJingleSession && this._suspendMediaTransferForJvbConnection(), Z.info("Starting remote stats with p2p connection"), this.statistics.startRemoteStats(this.p2pJingleSession.peerconnection), D.a.sendAnalyticsAndLog(Object(W.H)(W.i, {
                    initiator: this.p2pJingleSession.isInitiator
                })))
            }, ee.prototype._updateProperties = function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                    t = !c()(e, this.properties);
                if (this.properties = e, t) {
                    this.eventEmitter.emit(d.PROPERTIES_CHANGED, this.properties);
                    var n = ["bridge-count", "created-ms", "octo-enabled"];
                    n.forEach((function(t) {
                        void 0 !== e[t] && D.a.analytics.addPermanentProperties(Y({}, t.replace("-", "_"), e[t]))
                    }))
                }
            }, ee.prototype.getProperty = function(e) {
                return this.properties[e]
            }, ee.prototype._maybeClearDeferredStartP2P = function() {
                this.deferredStartP2PTask && (Z.info("Cleared deferred start P2P task"), clearTimeout(this.deferredStartP2PTask), this.deferredStartP2PTask = null)
            }, ee.prototype._removeRemoteJVBTracks = function() {
                this._removeRemoteTracks("JVB", this.jvbJingleSession.peerconnection.getRemoteTracks())
            }, ee.prototype._removeRemoteP2PTracks = function() {
                this._removeRemoteTracks("P2P", this.p2pJingleSession.peerconnection.getRemoteTracks())
            }, ee.prototype._removeRemoteTracks = function(e, t) {
                var n = !0,
                    r = !1,
                    i = void 0;
                try {
                    for (var o, a = t[Symbol.iterator](); !(n = (o = a.next()).done); n = !0) {
                        var s = o.value;
                        Z.info("Removing remote ".concat(e, " track: ").concat(s)), this.rtc.eventEmitter.emit(V.REMOTE_TRACK_REMOVED, s)
                    }
                } catch (e) {
                    r = !0, i = e
                } finally {
                    try {
                        n || null == a.return || a.return()
                    } finally {
                        if (r) throw i
                    }
                }
            }, ee.prototype._resumeMediaTransferForJvbConnection = function() {
                Z.info("Resuming media transfer over the JVB connection..."), this.jvbJingleSession.setMediaTransferActive(!0, !0).then((function() {
                    Z.info("Resumed media transfer over the JVB connection!")
                }), (function(e) {
                    Z.error("Failed to resume media transfer over the JVB connection:", e)
                }))
            }, ee.prototype._setP2PStatus = function(e) {
                if (this.p2p !== e) {
                    if (this.p2p = e, e) {
                        Z.info("Peer to peer connection established!"), D.a.analytics.addPermanentProperties({
                            p2pFailed: !1,
                            forceJvb121: !1
                        });
                        var t = 0 !== this.rtc.getLastN();
                        this.p2pJingleSession.setMediaTransferActive(!0, t).catch((function(e) {
                            Z.error("Failed to sync up P2P video transfer status" + "(".concat(t, ")"), e)
                        }))
                    } else Z.info("Peer to peer connection closed!");
                    this.jvbJingleSession && this.statistics.sendConnectionResumeOrHoldEvent(this.jvbJingleSession.peerconnection, !e), this.dtmfManager = null, this.eventEmitter.emit(d.P2P_STATUS, this, this.p2p), this.eventEmitter.emit(this.isConnectionInterrupted() ? d.CONNECTION_INTERRUPTED : d.CONNECTION_RESTORED)
                } else Z.debug("Called _setP2PStatus with the same status: ".concat(e))
            }, ee.prototype._startP2PSession = function(e) {
                if (this._maybeClearDeferredStartP2P(), this.p2pJingleSession) Z.error("P2P session already started!");
                else {
                    this.isP2PConnectionInterrupted = !1, this.p2pJingleSession = this.xmpp.connection.jingle.newP2PJingleSession(this.room.myroomjid, e), Z.info("Created new P2P JingleSession", this.room.myroomjid, e), this.p2pJingleSession.initialize(this.room, this.rtc, this.options.config), Z.info("Starting CallStats for P2P connection...");
                    var t = r.Strophe.getResourceFromJid(this.p2pJingleSession.remoteJid),
                        n = this.participants[t];
                    n && (t = n.getStatsID() || t), this.statistics.startCallStats(this.p2pJingleSession.peerconnection, t);
                    var i = this.getLocalTracks();
                    this.p2pJingleSession.invite(i)
                }
            }, ee.prototype._suspendMediaTransferForJvbConnection = function() {
                Z.info("Suspending media transfer over the JVB connection..."), this.jvbJingleSession.setMediaTransferActive(!1, !1).then((function() {
                    Z.info("Suspended media transfer over the JVB connection !")
                }), (function(e) {
                    Z.error("Failed to suspend media transfer over the JVB connection:", e)
                }))
            }, ee.prototype._maybeStartOrStopP2P = function(e) {
                if (S.a.supportsP2P() && this.isP2PEnabled() && !this.isP2PTestModeEnabled()) {
                    var t = this.getParticipants(),
                        n = t.length,
                        r = this._shouldBeInP2PMode();
                    if (!r && this.deferredStartP2PTask && this._maybeClearDeferredStartP2P(), !this.p2pJingleSession && r) {
                        var i = n && t[0],
                            o = this.myUserId(),
                            a = i.getId();
                        if (o > a) return void Z.debug("I'm the bigger peersId - the other peer should start P2P", o, a);
                        if (o === a) return void Z.error("The same IDs ? ", o, a);
                        var s = i.getJid();
                        if (e) {
                            if (this.deferredStartP2PTask) return void Z.error("Deferred start P2P task's been set already!");
                            Z.info("Will start P2P with: ".concat(s, " after ").concat(this.backToP2PDelay, " seconds...")), this.deferredStartP2PTask = setTimeout(this._startP2PSession.bind(this, s), 1e3 * this.backToP2PDelay)
                        } else Z.info("Will start P2P with: ".concat(s)), this._startP2PSession(s)
                    } else this.p2pJingleSession && !r && (Z.info("Will stop P2P with: ".concat(this.p2pJingleSession.remoteJid)), this.p2pJingleSession.isInitiator && n > 1 && D.a.sendAnalyticsAndLog(Object(W.H)(W.k)), this._stopP2PSession())
                } else Z.info("Auto P2P disabled")
            }, ee.prototype._shouldBeInP2PMode = function() {
                var e = this.getParticipants(),
                    t = e.length,
                    n = void 0 !== e.find((function(e) {
                        return "poltergeist" === e._botType
                    })),
                    r = 1 === t && !n;
                return Z.debug("P2P? peerCount: ".concat(t, ", hasBotPeer: ").concat(n, " => ").concat(r)), r
            }, ee.prototype._stopP2PSession = function(e, t) {
                if (this.p2pJingleSession) {
                    var n = this.isP2PActive();
                    n && (this.jvbJingleSession && this._resumeMediaTransferForJvbConnection(), this._removeRemoteP2PTracks()), Z.info("Stopping remote stats for P2P connection"), this.statistics.stopRemoteStats(this.p2pJingleSession.peerconnection), Z.info("Stopping CallStats for P2P connection"), this.statistics.stopCallStats(this.p2pJingleSession.peerconnection), this.p2pJingleSession.terminate((function() {
                        Z.info("P2P session terminate RESULT")
                    }), (function(t) {
                        e && Z.error("An error occurred while trying to terminate P2P Jingle session", t)
                    }), {
                        reason: e || "success",
                        reasonDescription: t || "Turing off P2P session",
                        sendSessionTerminate: this.room && this.getParticipantById(r.Strophe.getResourceFromJid(this.p2pJingleSession.remoteJid))
                    }), this.p2pJingleSession = null, this._setP2PStatus(!1), n && (this.jvbJingleSession ? this._addRemoteJVBTracks() : Z.info("Not adding remote JVB tracks - no session yet"))
                } else Z.error("No P2P session to be stopped!")
            }, ee.prototype.isP2PActive = function() {
                return this.p2p
            }, ee.prototype.getP2PConnectionState = function() {
                return this.isP2PActive() ? this.p2pJingleSession.peerconnection.getConnectionState() : null
            }, ee.prototype.startP2PSession = function() {
                var e = this.getParticipants();
                if (1 !== e.length) throw new Error("There must be exactly 1 participant to start the P2P session !");
                var t = e[0].getJid();
                this._startP2PSession(t)
            }, ee.prototype.stopP2PSession = function() {
                this._stopP2PSession()
            }, ee.prototype.getSpeakerStats = function() {
                return this.speakerStatsCollector.getStats()
            }, ee.prototype.setReceiverVideoConstraint = function(e) {
                this.rtc.setReceiverVideoConstraint(e)
            }, ee.prototype.createVideoSIPGWSession = function(e, t) {
                return this.room ? this.videoSIPGWHandler.createVideoSIPGWSession(e, t) : new Error(J.ERROR_NO_CONNECTION)
            }
        }).call(this, "JitsiConference.js")
    }, function(e, t, n) {
        (function(e, n) {
            function r(e) {
                return (r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                    return typeof e
                } : function(e) {
                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                })(e)
            }
            var i = 200,
                o = "__lodash_hash_undefined__",
                a = 1,
                s = 2,
                c = 9007199254740991,
                u = "[object Arguments]",
                l = "[object Array]",
                d = "[object AsyncFunction]",
                p = "[object Boolean]",
                h = "[object Date]",
                f = "[object Error]",
                m = "[object Function]",
                v = "[object GeneratorFunction]",
                y = "[object Map]",
                g = "[object Number]",
                _ = "[object Null]",
                S = "[object Object]",
                b = "[object Proxy]",
                E = "[object RegExp]",
                T = "[object Set]",
                C = "[object String]",
                R = "[object Symbol]",
                A = "[object Undefined]",
                w = "[object ArrayBuffer]",
                k = "[object DataView]",
                O = /^\[object .+?Constructor\]$/,
                I = /^(?:0|[1-9]\d*)$/,
                P = {};
            P["[object Float32Array]"] = P["[object Float64Array]"] = P["[object Int8Array]"] = P["[object Int16Array]"] = P["[object Int32Array]"] = P["[object Uint8Array]"] = P["[object Uint8ClampedArray]"] = P["[object Uint16Array]"] = P["[object Uint32Array]"] = !0, P[u] = P[l] = P[w] = P[p] = P[k] = P[h] = P[f] = P[m] = P[y] = P[g] = P[S] = P[E] = P[T] = P[C] = P["[object WeakMap]"] = !1;
            var D = "object" == (void 0 === e ? "undefined" : r(e)) && e && e.Object === Object && e,
                N = "object" == ("undefined" == typeof self ? "undefined" : r(self)) && self && self.Object === Object && self,
                L = D || N || Function("return this")(),
                M = "object" == r(t) && t && !t.nodeType && t,
                x = M && "object" == r(n) && n && !n.nodeType && n,
                j = x && x.exports === M,
                F = j && D.process,
                U = function() {
                    try {
                        return F && F.binding && F.binding("util")
                    } catch (e) {}
                }(),
                H = U && U.isTypedArray;

            function J(e, t) {
                for (var n = -1, r = null == e ? 0 : e.length; ++n < r;)
                    if (t(e[n], n, e)) return !0;
                return !1
            }

            function G(e) {
                var t = -1,
                    n = Array(e.size);
                return e.forEach((function(e, r) {
                    n[++t] = [r, e]
                })), n
            }

            function B(e) {
                var t = -1,
                    n = Array(e.size);
                return e.forEach((function(e) {
                    n[++t] = e
                })), n
            }
            var V, q, K, W = Array.prototype,
                z = Function.prototype,
                $ = Object.prototype,
                X = L["__core-js_shared__"],
                Q = z.toString,
                Y = $.hasOwnProperty,
                Z = (V = /[^.]+$/.exec(X && X.keys && X.keys.IE_PROTO || "")) ? "Symbol(src)_1." + V : "",
                ee = $.toString,
                te = RegExp("^" + Q.call(Y).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"),
                ne = j ? L.Buffer : void 0,
                re = L.Symbol,
                ie = L.Uint8Array,
                oe = $.propertyIsEnumerable,
                ae = W.splice,
                se = re ? re.toStringTag : void 0,
                ce = Object.getOwnPropertySymbols,
                ue = ne ? ne.isBuffer : void 0,
                le = (q = Object.keys, K = Object, function(e) {
                    return q(K(e))
                }),
                de = Ue(L, "DataView"),
                pe = Ue(L, "Map"),
                he = Ue(L, "Promise"),
                fe = Ue(L, "Set"),
                me = Ue(L, "WeakMap"),
                ve = Ue(Object, "create"),
                ye = Be(de),
                ge = Be(pe),
                _e = Be(he),
                Se = Be(fe),
                be = Be(me),
                Ee = re ? re.prototype : void 0,
                Te = Ee ? Ee.valueOf : void 0;

            function Ce(e) {
                var t = -1,
                    n = null == e ? 0 : e.length;
                for (this.clear(); ++t < n;) {
                    var r = e[t];
                    this.set(r[0], r[1])
                }
            }

            function Re(e) {
                var t = -1,
                    n = null == e ? 0 : e.length;
                for (this.clear(); ++t < n;) {
                    var r = e[t];
                    this.set(r[0], r[1])
                }
            }

            function Ae(e) {
                var t = -1,
                    n = null == e ? 0 : e.length;
                for (this.clear(); ++t < n;) {
                    var r = e[t];
                    this.set(r[0], r[1])
                }
            }

            function we(e) {
                var t = -1,
                    n = null == e ? 0 : e.length;
                for (this.__data__ = new Ae; ++t < n;) this.add(e[t])
            }

            function ke(e) {
                var t = this.__data__ = new Re(e);
                this.size = t.size
            }

            function Oe(e, t) {
                var n = Ke(e),
                    r = !n && qe(e),
                    i = !n && !r && We(e),
                    o = !n && !r && !i && Ye(e),
                    a = n || r || i || o,
                    s = a ? function(e, t) {
                        for (var n = -1, r = Array(e); ++n < e;) r[n] = t(n);
                        return r
                    }(e.length, String) : [],
                    c = s.length;
                for (var u in e) !t && !Y.call(e, u) || a && ("length" == u || i && ("offset" == u || "parent" == u) || o && ("buffer" == u || "byteLength" == u || "byteOffset" == u) || Ge(u, c)) || s.push(u);
                return s
            }

            function Ie(e, t) {
                for (var n = e.length; n--;)
                    if (Ve(e[n][0], t)) return n;
                return -1
            }

            function Pe(e) {
                return null == e ? void 0 === e ? A : _ : se && se in Object(e) ? function(e) {
                    var t = Y.call(e, se),
                        n = e[se];
                    try {
                        e[se] = void 0;
                        var r = !0
                    } catch (e) {}
                    var i = ee.call(e);
                    r && (t ? e[se] = n : delete e[se]);
                    return i
                }(e) : function(e) {
                    return ee.call(e)
                }(e)
            }

            function De(e) {
                return Qe(e) && Pe(e) == u
            }

            function Ne(e, t, n, r, i) {
                return e === t || (null == e || null == t || !Qe(e) && !Qe(t) ? e != e && t != t : function(e, t, n, r, i, o) {
                    var c = Ke(e),
                        d = Ke(t),
                        m = c ? l : Je(e),
                        v = d ? l : Je(t),
                        _ = (m = m == u ? S : m) == S,
                        b = (v = v == u ? S : v) == S,
                        A = m == v;
                    if (A && We(e)) {
                        if (!We(t)) return !1;
                        c = !0, _ = !1
                    }
                    if (A && !_) return o || (o = new ke), c || Ye(e) ? xe(e, t, n, r, i, o) : function(e, t, n, r, i, o, c) {
                        switch (n) {
                            case k:
                                if (e.byteLength != t.byteLength || e.byteOffset != t.byteOffset) return !1;
                                e = e.buffer, t = t.buffer;
                            case w:
                                return !(e.byteLength != t.byteLength || !o(new ie(e), new ie(t)));
                            case p:
                            case h:
                            case g:
                                return Ve(+e, +t);
                            case f:
                                return e.name == t.name && e.message == t.message;
                            case E:
                            case C:
                                return e == t + "";
                            case y:
                                var u = G;
                            case T:
                                var l = r & a;
                                if (u || (u = B), e.size != t.size && !l) return !1;
                                var d = c.get(e);
                                if (d) return d == t;
                                r |= s, c.set(e, t);
                                var m = xe(u(e), u(t), r, i, o, c);
                                return c.delete(e), m;
                            case R:
                                if (Te) return Te.call(e) == Te.call(t)
                        }
                        return !1
                    }(e, t, m, n, r, i, o);
                    if (!(n & a)) {
                        var O = _ && Y.call(e, "__wrapped__"),
                            I = b && Y.call(t, "__wrapped__");
                        if (O || I) {
                            var P = O ? e.value() : e,
                                D = I ? t.value() : t;
                            return o || (o = new ke), i(P, D, n, r, o)
                        }
                    }
                    if (!A) return !1;
                    return o || (o = new ke),
                        function(e, t, n, r, i, o) {
                            var s = n & a,
                                c = je(e),
                                u = c.length,
                                l = je(t).length;
                            if (u != l && !s) return !1;
                            var d = u;
                            for (; d--;) {
                                var p = c[d];
                                if (!(s ? p in t : Y.call(t, p))) return !1
                            }
                            var h = o.get(e);
                            if (h && o.get(t)) return h == t;
                            var f = !0;
                            o.set(e, t), o.set(t, e);
                            var m = s;
                            for (; ++d < u;) {
                                p = c[d];
                                var v = e[p],
                                    y = t[p];
                                if (r) var g = s ? r(y, v, p, t, e, o) : r(v, y, p, e, t, o);
                                if (!(void 0 === g ? v === y || i(v, y, n, r, o) : g)) {
                                    f = !1;
                                    break
                                }
                                m || (m = "constructor" == p)
                            }
                            if (f && !m) {
                                var _ = e.constructor,
                                    S = t.constructor;
                                _ != S && "constructor" in e && "constructor" in t && !("function" == typeof _ && _ instanceof _ && "function" == typeof S && S instanceof S) && (f = !1)
                            }
                            return o.delete(e), o.delete(t), f
                        }(e, t, n, r, i, o)
                }(e, t, n, r, Ne, i))
            }

            function Le(e) {
                return !(!Xe(e) || function(e) {
                    return !!Z && Z in e
                }(e)) && (ze(e) ? te : O).test(Be(e))
            }

            function Me(e) {
                if (n = (t = e) && t.constructor, r = "function" == typeof n && n.prototype || $, t !== r) return le(e);
                var t, n, r, i = [];
                for (var o in Object(e)) Y.call(e, o) && "constructor" != o && i.push(o);
                return i
            }

            function xe(e, t, n, r, i, o) {
                var c = n & a,
                    u = e.length,
                    l = t.length;
                if (u != l && !(c && l > u)) return !1;
                var d = o.get(e);
                if (d && o.get(t)) return d == t;
                var p = -1,
                    h = !0,
                    f = n & s ? new we : void 0;
                for (o.set(e, t), o.set(t, e); ++p < u;) {
                    var m = e[p],
                        v = t[p];
                    if (r) var y = c ? r(v, m, p, t, e, o) : r(m, v, p, e, t, o);
                    if (void 0 !== y) {
                        if (y) continue;
                        h = !1;
                        break
                    }
                    if (f) {
                        if (!J(t, (function(e, t) {
                                if (a = t, !f.has(a) && (m === e || i(m, e, n, r, o))) return f.push(t);
                                var a
                            }))) {
                            h = !1;
                            break
                        }
                    } else if (m !== v && !i(m, v, n, r, o)) {
                        h = !1;
                        break
                    }
                }
                return o.delete(e), o.delete(t), h
            }

            function je(e) {
                return function(e, t, n) {
                    var r = t(e);
                    return Ke(e) ? r : function(e, t) {
                        for (var n = -1, r = t.length, i = e.length; ++n < r;) e[i + n] = t[n];
                        return e
                    }(r, n(e))
                }(e, Ze, He)
            }

            function Fe(e, t) {
                var n, i, o = e.__data__;
                return ("string" == (i = r(n = t)) || "number" == i || "symbol" == i || "boolean" == i ? "__proto__" !== n : null === n) ? o["string" == typeof t ? "string" : "hash"] : o.map
            }

            function Ue(e, t) {
                var n = function(e, t) {
                    return null == e ? void 0 : e[t]
                }(e, t);
                return Le(n) ? n : void 0
            }
            Ce.prototype.clear = function() {
                this.__data__ = ve ? ve(null) : {}, this.size = 0
            }, Ce.prototype.delete = function(e) {
                var t = this.has(e) && delete this.__data__[e];
                return this.size -= t ? 1 : 0, t
            }, Ce.prototype.get = function(e) {
                var t = this.__data__;
                if (ve) {
                    var n = t[e];
                    return n === o ? void 0 : n
                }
                return Y.call(t, e) ? t[e] : void 0
            }, Ce.prototype.has = function(e) {
                var t = this.__data__;
                return ve ? void 0 !== t[e] : Y.call(t, e)
            }, Ce.prototype.set = function(e, t) {
                var n = this.__data__;
                return this.size += this.has(e) ? 0 : 1, n[e] = ve && void 0 === t ? o : t, this
            }, Re.prototype.clear = function() {
                this.__data__ = [], this.size = 0
            }, Re.prototype.delete = function(e) {
                var t = this.__data__,
                    n = Ie(t, e);
                return !(n < 0) && (n == t.length - 1 ? t.pop() : ae.call(t, n, 1), --this.size, !0)
            }, Re.prototype.get = function(e) {
                var t = this.__data__,
                    n = Ie(t, e);
                return n < 0 ? void 0 : t[n][1]
            }, Re.prototype.has = function(e) {
                return Ie(this.__data__, e) > -1
            }, Re.prototype.set = function(e, t) {
                var n = this.__data__,
                    r = Ie(n, e);
                return r < 0 ? (++this.size, n.push([e, t])) : n[r][1] = t, this
            }, Ae.prototype.clear = function() {
                this.size = 0, this.__data__ = {
                    hash: new Ce,
                    map: new(pe || Re),
                    string: new Ce
                }
            }, Ae.prototype.delete = function(e) {
                var t = Fe(this, e).delete(e);
                return this.size -= t ? 1 : 0, t
            }, Ae.prototype.get = function(e) {
                return Fe(this, e).get(e)
            }, Ae.prototype.has = function(e) {
                return Fe(this, e).has(e)
            }, Ae.prototype.set = function(e, t) {
                var n = Fe(this, e),
                    r = n.size;
                return n.set(e, t), this.size += n.size == r ? 0 : 1, this
            }, we.prototype.add = we.prototype.push = function(e) {
                return this.__data__.set(e, o), this
            }, we.prototype.has = function(e) {
                return this.__data__.has(e)
            }, ke.prototype.clear = function() {
                this.__data__ = new Re, this.size = 0
            }, ke.prototype.delete = function(e) {
                var t = this.__data__,
                    n = t.delete(e);
                return this.size = t.size, n
            }, ke.prototype.get = function(e) {
                return this.__data__.get(e)
            }, ke.prototype.has = function(e) {
                return this.__data__.has(e)
            }, ke.prototype.set = function(e, t) {
                var n = this.__data__;
                if (n instanceof Re) {
                    var r = n.__data__;
                    if (!pe || r.length < i - 1) return r.push([e, t]), this.size = ++n.size, this;
                    n = this.__data__ = new Ae(r)
                }
                return n.set(e, t), this.size = n.size, this
            };
            var He = ce ? function(e) {
                    return null == e ? [] : (e = Object(e), function(e, t) {
                        for (var n = -1, r = null == e ? 0 : e.length, i = 0, o = []; ++n < r;) {
                            var a = e[n];
                            t(a, n, e) && (o[i++] = a)
                        }
                        return o
                    }(ce(e), (function(t) {
                        return oe.call(e, t)
                    })))
                } : function() {
                    return []
                },
                Je = Pe;

            function Ge(e, t) {
                return !!(t = null == t ? c : t) && ("number" == typeof e || I.test(e)) && e > -1 && e % 1 == 0 && e < t
            }

            function Be(e) {
                if (null != e) {
                    try {
                        return Q.call(e)
                    } catch (e) {}
                    try {
                        return e + ""
                    } catch (e) {}
                }
                return ""
            }

            function Ve(e, t) {
                return e === t || e != e && t != t
            }(de && Je(new de(new ArrayBuffer(1))) != k || pe && Je(new pe) != y || he && "[object Promise]" != Je(he.resolve()) || fe && Je(new fe) != T || me && "[object WeakMap]" != Je(new me)) && (Je = function(e) {
                var t = Pe(e),
                    n = t == S ? e.constructor : void 0,
                    r = n ? Be(n) : "";
                if (r) switch (r) {
                    case ye:
                        return k;
                    case ge:
                        return y;
                    case _e:
                        return "[object Promise]";
                    case Se:
                        return T;
                    case be:
                        return "[object WeakMap]"
                }
                return t
            });
            var qe = De(function() {
                    return arguments
                }()) ? De : function(e) {
                    return Qe(e) && Y.call(e, "callee") && !oe.call(e, "callee")
                },
                Ke = Array.isArray;
            var We = ue || function() {
                return !1
            };

            function ze(e) {
                if (!Xe(e)) return !1;
                var t = Pe(e);
                return t == m || t == v || t == d || t == b
            }

            function $e(e) {
                return "number" == typeof e && e > -1 && e % 1 == 0 && e <= c
            }

            function Xe(e) {
                var t = r(e);
                return null != e && ("object" == t || "function" == t)
            }

            function Qe(e) {
                return null != e && "object" == r(e)
            }
            var Ye = H ? function(e) {
                return function(t) {
                    return e(t)
                }
            }(H) : function(e) {
                return Qe(e) && $e(e.length) && !!P[Pe(e)]
            };

            function Ze(e) {
                return null != (t = e) && $e(t.length) && !ze(t) ? Oe(e) : Me(e);
                var t
            }
            n.exports = function(e, t) {
                return Ne(e, t)
            }
        }).call(this, n(43), n(61)(e))
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return b
            }));
            var r = n(1),
                i = n(7),
                o = n(56),
                a = n.n(o),
                s = n(70),
                c = n.n(s),
                u = n(4),
                l = n(17),
                d = n(2),
                p = n(9),
                h = n(8),
                f = n.n(h),
                m = n(14),
                v = n.n(m),
                y = n(5),
                g = n(0),
                _ = n.n(g),
                S = Object(u.getLogger)(e);

            function b(e) {
                this.conference = e, this.xmppListeners = {}, e.on(d.TRACK_MUTE_CHANGED, (function(t) {
                    if (t.isLocal() && e.statistics) {
                        var n = t.isP2P ? e.p2pJingleSession : e.jvbJingleSession,
                            r = n && n.peerconnection || null;
                        e.statistics.sendMuteEvent(r, t.isMuted(), t.getType())
                    }
                }))
            }
            b.prototype.setupChatRoomListeners = function() {
                var e = this,
                    t = this.conference,
                    n = t.room;
                this.chatRoomForwarder = new c.a(n, this.conference.eventEmitter), n.addListener(_.a.ICE_RESTARTING, (function(e) {
                    e.isP2P || t.rtc.closeBridgeChannel()
                })), n.addListener(_.a.ICE_RESTART_SUCCESS, (function(e, n) {
                    !e.isP2P && t._setBridgeChannel(n, e.peerconnection)
                })), n.addListener(_.a.AUDIO_MUTED_BY_FOCUS, (function(e) {
                    y.a.sendAnalytics(Object(i.J)()), t.mutedByFocusActor = e, t.rtc.setAudioMute(!0).then((function() {
                        t.isMutedByFocus = !0, t.mutedByFocusActor = null
                    })).catch((function(e) {
                        t.mutedByFocusActor = null, S.warn("Error while audio muting due to focus request", e)
                    }))
                })), this.chatRoomForwarder.forward(_.a.SUBJECT_CHANGED, d.SUBJECT_CHANGED), this.chatRoomForwarder.forward(_.a.MUC_JOINED, d.CONFERENCE_JOINED), n.addListener(_.a.MUC_JOINED, (function() {
                    e.conference.isJvbConnectionInterrupted = !1, Object.keys(n.connectionTimes).forEach((function(e) {
                        var t = Object(i.B)("conference_".concat(e), {
                            value: n.connectionTimes[e]
                        });
                        y.a.sendAnalytics(t)
                    })), Object.keys(n.xmpp.connectionTimes).forEach((function(e) {
                        var t = Object(i.B)("xmpp_".concat(e), {
                            value: n.xmpp.connectionTimes[e]
                        });
                        y.a.sendAnalytics(t)
                    }))
                })), n.addListener(_.a.RENEGOTIATION_FAILED, (function(e, n) {
                    n.isP2P || t.eventEmitter.emit(d.CONFERENCE_FAILED, l.OFFER_ANSWER_FAILED, e)
                })), this.chatRoomForwarder.forward(_.a.ROOM_JOIN_ERROR, d.CONFERENCE_FAILED, l.CONNECTION_ERROR), this.chatRoomForwarder.forward(_.a.ROOM_CONNECT_ERROR, d.CONFERENCE_FAILED, l.CONNECTION_ERROR), this.chatRoomForwarder.forward(_.a.ROOM_CONNECT_NOT_ALLOWED_ERROR, d.CONFERENCE_FAILED, l.NOT_ALLOWED_ERROR), this.chatRoomForwarder.forward(_.a.ROOM_MAX_USERS_ERROR, d.CONFERENCE_FAILED, l.CONFERENCE_MAX_USERS), this.chatRoomForwarder.forward(_.a.PASSWORD_REQUIRED, d.CONFERENCE_FAILED, l.PASSWORD_REQUIRED), this.chatRoomForwarder.forward(_.a.AUTHENTICATION_REQUIRED, d.CONFERENCE_FAILED, l.AUTHENTICATION_REQUIRED), this.chatRoomForwarder.forward(_.a.BRIDGE_DOWN, d.CONFERENCE_FAILED, l.VIDEOBRIDGE_NOT_AVAILABLE), n.addListener(_.a.BRIDGE_DOWN, (function() {
                    return y.a.sendAnalytics(Object(i.z)())
                })), this.chatRoomForwarder.forward(_.a.RESERVATION_ERROR, d.CONFERENCE_FAILED, l.RESERVATION_ERROR), this.chatRoomForwarder.forward(_.a.GRACEFUL_SHUTDOWN, d.CONFERENCE_FAILED, l.GRACEFUL_SHUTDOWN), n.addListener(_.a.CONNECTION_ICE_FAILED, (function(e) {
                    t._onIceConnectionFailed(e)
                })), this.chatRoomForwarder.forward(_.a.MUC_DESTROYED, d.CONFERENCE_FAILED, l.CONFERENCE_DESTROYED), this.chatRoomForwarder.forward(_.a.CHAT_ERROR_RECEIVED, d.CONFERENCE_ERROR, l.CHAT_ERROR), this.chatRoomForwarder.forward(_.a.FOCUS_DISCONNECTED, d.CONFERENCE_FAILED, l.FOCUS_DISCONNECTED), n.addListener(_.a.FOCUS_LEFT, (function() {
                    y.a.sendAnalytics(Object(i.D)()), t.eventEmitter.emit(d.CONFERENCE_FAILED, l.FOCUS_LEFT)
                })), n.addListener(_.a.SESSION_ACCEPT_TIMEOUT, (function(e) {
                    y.a.sendAnalyticsAndLog(Object(i.F)(i.b, {
                        p2p: e.isP2P
                    }))
                })), n.addListener(_.a.RECORDER_STATE_CHANGED, (function(e, n) {
                    if (n) {
                        var i = t.getParticipantById(r.Strophe.getResourceFromJid(n));
                        "off" === e.getStatus() ? e.setTerminator(i) : "on" === e.getStatus() && e.setInitiator(i)
                    }
                    t.eventEmitter.emit(d.RECORDER_STATE_CHANGED, e)
                })), this.chatRoomForwarder.forward(_.a.TRANSCRIPTION_STATUS_CHANGED, d.TRANSCRIPTION_STATUS_CHANGED), this.chatRoomForwarder.forward(_.a.VIDEO_SIP_GW_AVAILABILITY_CHANGED, d.VIDEO_SIP_GW_AVAILABILITY_CHANGED), this.chatRoomForwarder.forward(_.a.VIDEO_SIP_GW_SESSION_STATE_CHANGED, d.VIDEO_SIP_GW_SESSION_STATE_CHANGED), this.chatRoomForwarder.forward(_.a.PHONE_NUMBER_CHANGED, d.PHONE_NUMBER_CHANGED), n.setParticipantPropertyListener((function(e, n) {
                    var r = t.getParticipantById(n);
                    r && r.setProperty(e.tagName.substring("jitsi_participant_".length), e.value)
                })), n.addListener(_.a.KICKED, t.onMemberKicked.bind(t)), n.addListener(_.a.SUSPEND_DETECTED, t.onSuspendDetected.bind(t)), this.chatRoomForwarder.forward(_.a.MUC_LOCK_CHANGED, d.LOCK_STATE_CHANGED), n.addListener(_.a.MUC_MEMBER_JOINED, t.onMemberJoined.bind(t)), n.addListener(_.a.MUC_MEMBER_BOT_TYPE_CHANGED, t._onMemberBotTypeChanged.bind(t)), n.addListener(_.a.MUC_MEMBER_LEFT, t.onMemberLeft.bind(t)), this.chatRoomForwarder.forward(_.a.MUC_LEFT, d.CONFERENCE_LEFT), n.addListener(_.a.DISPLAY_NAME_CHANGED, t.onDisplayNameChanged.bind(t)), n.addListener(_.a.LOCAL_ROLE_CHANGED, (function(e) {
                    t.onLocalRoleChanged(e), t.statistics && t.isModerator() && t.on(d.RECORDER_STATE_CHANGED, (function(e) {
                        var t = {
                            error: e.getError(),
                            id: "recorder_status",
                            status: e.getStatus()
                        };
                        y.a.sendLog(JSON.stringify(t))
                    }))
                })), n.addListener(_.a.MUC_ROLE_CHANGED, t.onUserRoleChanged.bind(t)), n.addListener(a.a.IDENTITY_UPDATED, (function(e, n) {
                    t.authEnabled = e, t.authIdentity = n, t.eventEmitter.emit(d.AUTH_STATUS_CHANGED, e, n)
                })), n.addListener(_.a.MESSAGE_RECEIVED, (function(e, n, i, o, a) {
                    var s = r.Strophe.getResourceFromJid(e);
                    t.eventEmitter.emit(d.MESSAGE_RECEIVED, s, i, a, n)
                })), n.addListener(_.a.PRIVATE_MESSAGE_RECEIVED, (function(e, n, i, o, a) {
                    var s = r.Strophe.getResourceFromJid(e);
                    t.eventEmitter.emit(d.PRIVATE_MESSAGE_RECEIVED, s, i, a)
                })), n.addListener(_.a.PRESENCE_STATUS, (function(e, n) {
                    var i = r.Strophe.getResourceFromJid(e),
                        o = t.getParticipantById(i);
                    o && o._status !== n && (o._status = n, t.eventEmitter.emit(d.USER_STATUS_CHANGED, i, n))
                })), n.addListener(_.a.JSON_MESSAGE_RECEIVED, (function(e, n) {
                    var i = r.Strophe.getResourceFromJid(e),
                        o = t.getParticipantById(i);
                    o ? t.eventEmitter.emit(d.ENDPOINT_MESSAGE_RECEIVED, o, n) : S.warn("Ignored XMPPEvents.JSON_MESSAGE_RECEIVED for not existing " + "participant: ".concat(e), n)
                })), n.addPresenceListener("startmuted", (function(e, n) {
                    var r = !1;
                    if (t.myUserId() === n && t.isModerator()) r = !0;
                    else {
                        var i = t.getParticipantById(n);
                        i && i.isModerator() && (r = !0)
                    }
                    if (r) {
                        var o = "true" === e.attributes.audio,
                            a = "true" === e.attributes.video,
                            s = !1;
                        o !== t.startMutedPolicy.audio && (t.startMutedPolicy.audio = o, s = !0), a !== t.startMutedPolicy.video && (t.startMutedPolicy.video = a, s = !0), s && t.eventEmitter.emit(d.START_MUTED_POLICY_CHANGED, t.startMutedPolicy)
                    }
                })), t.statistics && (n.addListener(_.a.CONNECTION_ICE_FAILED, (function(e) {
                    t.statistics.sendIceConnectionFailedEvent(e.peerconnection)
                })), n.addListener(_.a.ADD_ICE_CANDIDATE_FAILED, (function(e, n) {
                    t.statistics.sendAddIceCandidateFailed(e, n)
                })))
            }, b.prototype.setupRTCListeners = function() {
                var e = this.conference,
                    t = e.rtc;
                t.addListener(f.a.REMOTE_TRACK_ADDED, e.onRemoteTrackAdded.bind(e)), t.addListener(f.a.REMOTE_TRACK_REMOVED, e.onRemoteTrackRemoved.bind(e)), t.addListener(f.a.DOMINANT_SPEAKER_CHANGED, (function(t) {
                    e.lastDominantSpeaker !== t && e.room && (e.lastDominantSpeaker = t, e.eventEmitter.emit(d.DOMINANT_SPEAKER_CHANGED, t), e.statistics && e.myUserId() === t && e.statistics.sendDominantSpeakerEvent(e.room.roomjid))
                })), t.addListener(f.a.DATA_CHANNEL_OPEN, (function() {
                    var t = window.performance.now(),
                        n = "data.channel.opened";
                    S.log("(TIME) ".concat(n), t), e.room.connectionTimes[n] = t, y.a.sendAnalytics(Object(i.B)(n, {
                        value: t
                    })), e.eventEmitter.emit(d.DATA_CHANNEL_OPENED)
                })), t.addListener(f.a.ENDPOINT_MESSAGE_RECEIVED, (function(t, n) {
                    var r = e.getParticipantById(t);
                    r ? e.eventEmitter.emit(d.ENDPOINT_MESSAGE_RECEIVED, r, n) : S.warn("Ignored ENDPOINT_MESSAGE_RECEIVED for not existing " + "participant: ".concat(t), n)
                })), t.addListener(f.a.LOCAL_UFRAG_CHANGED, (function(e, t) {
                    e.isP2P || y.a.sendLog(JSON.stringify({
                        id: "local_ufrag",
                        value: t
                    }))
                })), t.addListener(f.a.REMOTE_UFRAG_CHANGED, (function(e, t) {
                    e.isP2P || y.a.sendLog(JSON.stringify({
                        id: "remote_ufrag",
                        value: t
                    }))
                })), t.addListener(f.a.CREATE_ANSWER_FAILED, (function(t, n) {
                    e.statistics.sendCreateAnswerFailed(t, n), n.isP2P || e.eventEmitter.emit(d.CONFERENCE_FAILED, l.OFFER_ANSWER_FAILED, t)
                })), t.addListener(f.a.CREATE_OFFER_FAILED, (function(t, n) {
                    e.statistics.sendCreateOfferFailed(t, n), n.isP2P || e.eventEmitter.emit(d.CONFERENCE_FAILED, l.OFFER_ANSWER_FAILED, t)
                })), t.addListener(f.a.SET_LOCAL_DESCRIPTION_FAILED, (function(t, n) {
                    e.statistics.sendSetLocalDescFailed(t, n), n.isP2P || e.eventEmitter.emit(d.CONFERENCE_FAILED, l.OFFER_ANSWER_FAILED, t)
                })), t.addListener(f.a.SET_REMOTE_DESCRIPTION_FAILED, (function(t, n) {
                    e.statistics.sendSetRemoteDescFailed(t, n), n.isP2P || e.eventEmitter.emit(d.CONFERENCE_FAILED, l.OFFER_ANSWER_FAILED, t)
                })), t.addListener(f.a.LOCAL_TRACK_SSRC_UPDATED, (function(t, n) {
                    t.isVideoTrack() && t.videoType === v.a.DESKTOP && e.statistics.sendScreenSharingEvent(!0, n)
                }))
            }, b.prototype.removeXMPPListeners = function() {
                var e = this,
                    t = this.conference;
                t.xmpp.caps.removeListener(_.a.PARTCIPANT_FEATURES_CHANGED, this.xmppListeners[_.a.PARTCIPANT_FEATURES_CHANGED]), delete this.xmppListeners[_.a.PARTCIPANT_FEATURES_CHANGED], Object.keys(this.xmppListeners).forEach((function(n) {
                    t.xmpp.removeListener(n, e.xmppListeners[n])
                })), this.xmppListeners = {}
            }, b.prototype.setupXMPPListeners = function() {
                var e = this.conference,
                    t = function(t) {
                        var n = e.getParticipantById(r.Strophe.getResourceFromJid(t));
                        n && e.eventEmitter.emit(d.PARTCIPANT_FEATURES_CHANGED, n)
                    };
                e.xmpp.caps.addListener(_.a.PARTCIPANT_FEATURES_CHANGED, t), this.xmppListeners[_.a.PARTCIPANT_FEATURES_CHANGED] = t, this._addConferenceXMPPListener(_.a.CALL_INCOMING, e.onIncomingCall.bind(e)), this._addConferenceXMPPListener(_.a.CALL_ACCEPTED, e.onCallAccepted.bind(e)), this._addConferenceXMPPListener(_.a.TRANSPORT_INFO, e.onTransportInfo.bind(e)), this._addConferenceXMPPListener(_.a.CALL_ENDED, e.onCallEnded.bind(e)), this._addConferenceXMPPListener(_.a.START_MUTED_FROM_FOCUS, (function(t, n) {
                    e.options.config.ignoreStartMuted || (e.startAudioMuted = t, e.startVideoMuted = n, e.getLocalTracks().forEach((function(t) {
                        switch (t.getType()) {
                            case p.a:
                                e.startAudioMuted && t.mute();
                                break;
                            case p.b:
                                e.startVideoMuted && t.mute()
                        }
                    })), e.eventEmitter.emit(d.STARTED_MUTED))
                }))
            }, b.prototype._addConferenceXMPPListener = function(e, t) {
                this.xmppListeners[e] = t, this.conference.xmpp.addListener(e, t)
            }, b.prototype.setupStatisticsListeners = function() {
                var e = this.conference;
                e.statistics && (e.statistics.addAudioLevelListener((function(t, n, r, i) {
                    e.rtc.setAudioLevel(t, n, r, i)
                })), e.statistics.addBeforeDisposedListener((function() {
                    e.eventEmitter.emit(d.BEFORE_STATISTICS_DISPOSED)
                })), e.options.config.startSilent || e.statistics.addByteSentStatsListener((function(t, n) {
                    e.getLocalTracks(p.a).forEach((function(e) {
                        var r = t.getLocalSSRC(e);
                        r && n.hasOwnProperty(r) && e._onByteSentStatsReceived(t, n[r])
                    }))
                })))
            }
        }).call(this, "JitsiConferenceEventManager.js")
    }, function(e, t) {
        function n(e, t) {
            if (!e || !t || "function" != typeof e.addListener || "function" != typeof t.emit) throw new Error("Invalid arguments passed to EventEmitterForwarder");
            this.src = e, this.dest = t
        }
        n.prototype.forward = function() {
            for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
            var r = t[0];
            t[0] = this.dest, this.src.addListener(r, Function.prototype.bind.apply(this.dest.emit, t))
        }, e.exports = n
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            var r = n(7),
                i = n(4),
                o = n(3);

            function a(e) {
                return (a = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                    return typeof e
                } : function(e) {
                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                })(e)
            }

            function s(e, t, n) {
                return t in e ? Object.defineProperty(e, t, {
                    value: n,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : e[t] = n, e
            }

            function c(e, t) {
                for (var n = 0; n < t.length; n++) {
                    var r = t[n];
                    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                }
            }
            var u = Object(i.getLogger)(e),
                l = function() {
                    function e() {
                        ! function(e, t) {
                            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                        }(this, e), this.reset()
                    }
                    var t, n, i;
                    return t = e, (n = [{
                        key: "reset",
                        value: function() {
                            this.disposed = !1, this.analyticsHandlers = new Set, this.cache = [], this.permanentProperties = {}, this.conferenceName = "", this.addPermanentProperties({
                                user_agent: navigator.userAgent,
                                browser_name: o.a.getName()
                            })
                        }
                    }, {
                        key: "dispose",
                        value: function() {
                            u.warn("Disposing of analytics adapter."), this.analyticsHandlers && this.analyticsHandlers.size > 0 && this.analyticsHandlers.forEach((function(e) {
                                "function" == typeof e.dispose && e.dispose()
                            })), this.setAnalyticsHandlers([]), this.disposed = !0
                        }
                    }, {
                        key: "setAnalyticsHandlers",
                        value: function(e) {
                            var t = this;
                            if (!this.disposed) {
                                this.analyticsHandlers = new Set(e), this._setUserProperties();
                                var n = this.cache;
                                this.cache = null, n && n.forEach((function(e) {
                                    return t._sendEvent(e)
                                }))
                            }
                        }
                    }, {
                        key: "_setUserProperties",
                        value: function() {
                            var e = this;
                            this.analyticsHandlers.forEach((function(t) {
                                try {
                                    t.setUserProperties(e.permanentProperties)
                                } catch (e) {
                                    u.warn("Error in setUserProperties method of one of the " + "analytics handlers: ".concat(e))
                                }
                            }))
                        }
                    }, {
                        key: "addPermanentProperties",
                        value: function(e) {
                            this.permanentProperties = function(e) {
                                for (var t = 1; t < arguments.length; t++) {
                                    var n = null != arguments[t] ? arguments[t] : {},
                                        r = Object.keys(n);
                                    "function" == typeof Object.getOwnPropertySymbols && (r = r.concat(Object.getOwnPropertySymbols(n).filter((function(e) {
                                        return Object.getOwnPropertyDescriptor(n, e).enumerable
                                    })))), r.forEach((function(t) {
                                        s(e, t, n[t])
                                    }))
                                }
                                return e
                            }({}, this.permanentProperties, e), this._setUserProperties()
                        }
                    }, {
                        key: "setConferenceName",
                        value: function(e) {
                            this.conferenceName = e, this.addPermanentProperties({
                                conference_name: e
                            })
                        }
                    }, {
                        key: "sendEvent",
                        value: function(e) {
                            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                            if (!this.disposed) {
                                var n = null;
                                "string" == typeof e ? n = {
                                    type: r.t,
                                    action: e,
                                    actionSubject: e,
                                    source: e,
                                    attributes: t
                                } : "object" === a(e) && (n = e), this._verifyRequiredFields(n) ? this._sendEvent(n) : u.error("Dropping a mis-formatted event: ".concat(JSON.stringify(n)))
                            }
                        }
                    }, {
                        key: "_verifyRequiredFields",
                        value: function(e) {
                            if (!e) return !1;
                            e.type || (e.type = r.t);
                            var t = e.type;
                            return t !== r.t && t !== r.u && t !== r.w && t !== r.v ? (u.error("Unknown event type: ".concat(t)), !1) : t === r.u ? Boolean(e.name) : (e.action = e.action || e.name || e.actionSubject, e.actionSubject = e.actionSubject || e.name || e.action, e.source = e.source || e.name || e.action || e.actionSubject, e.action && e.actionSubject && e.source ? !!(t !== r.v || (e.objectType = e.objectType || "generic-object-type", e.containerType = e.containerType || "conference", "conference" !== e.containerType || e.containerId || (e.containerId = this.conferenceName), e.objectType && e.objectId && e.containerType && e.containerId)) || (u.error("Required field missing (containerId, containerType, objectId or objectType)"), !1) : (u.error("Required field missing (action, actionSubject or source)"), !1))
                        }
                    }, {
                        key: "_maybeCacheEvent",
                        value: function(e) {
                            return !!this.cache && (this.cache.push(e), this.cache.length > 100 && this.cache.splice(0, 1), !0)
                        }
                    }, {
                        key: "_sendEvent",
                        value: function(e) {
                            this._maybeCacheEvent(e) || this.analyticsHandlers.forEach((function(t) {
                                try {
                                    t.sendEvent(e)
                                } catch (e) {
                                    u.warn("Error sending analytics event: ".concat(e))
                                }
                            }))
                        }
                    }]) && c(t.prototype, n), i && c(t, i), e
                }();
            t.a = new l
        }).call(this, "modules/statistics/AnalyticsAdapter.js")
    }, function(e, t, n) {
        "use strict";
        (function(e, r) {
            n.d(t, "a", (function() {
                return p
            }));
            var i = n(4),
                o = n(19);

            function a(e) {
                return (a = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                    return typeof e
                } : function(e) {
                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                })(e)
            }

            function s(e, t) {
                for (var n = 0; n < t.length; n++) {
                    var r = t[n];
                    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                }
            }

            function c(e, t) {
                return !t || "object" !== a(t) && "function" != typeof t ? function(e) {
                    if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return e
                }(e) : t
            }

            function u(e) {
                return (u = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
                    return e.__proto__ || Object.getPrototypeOf(e)
                })(e)
            }

            function l(e, t) {
                return (l = Object.setPrototypeOf || function(e, t) {
                    return e.__proto__ = t, e
                })(e, t)
            }
            var d = Object(i.getLogger)(e),
                p = function(e) {
                    function t() {
                        var e;
                        return function(e, t) {
                            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                        }(this, t), e = c(this, u(t).call(this)), d.info("This appears to be ".concat(e.getName(), ", ver: ").concat(e.getVersion())), e
                    }
                    var n, i, o;
                    return function(e, t) {
                        if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
                        e.prototype = Object.create(t && t.prototype, {
                            constructor: {
                                value: e,
                                writable: !0,
                                configurable: !0
                            }
                        }), t && l(e, t)
                    }(t, e), n = t, (i = [{
                        key: "doesVideoMuteByStreamRemove",
                        value: function() {
                            return !(this.isFirefox() || this.isEdge() || this.isReactNative() || this.isSafariWithWebrtc())
                        }
                    }, {
                        key: "supportsP2P",
                        value: function() {
                            return !this.isEdge() && !this.isFirefox()
                        }
                    }, {
                        key: "isChromiumBased",
                        value: function() {
                            return this.isChrome() || this.isElectron() || this.isNWJS() || this.isOpera()
                        }
                    }, {
                        key: "isSafariWithWebrtc",
                        value: function() {
                            return this.isSafari() && !this.isVersionLessThan("11")
                        }
                    }, {
                        key: "isSafariWithVP8",
                        value: function() {
                            return this.isSafari() && !this.isVersionLessThan("12.1")
                        }
                    }, {
                        key: "isSupported",
                        value: function() {
                            return this.isChromiumBased() || this.isFirefox() || this.isReactNative() || this.isSafariWithWebrtc()
                        }
                    }, {
                        key: "isUserInteractionRequiredForUnmute",
                        value: function() {
                            return this.isFirefox() && this.isVersionLessThan("68") || this.isSafari()
                        }
                    }, {
                        key: "supportsVideoMuteOnConnInterrupted",
                        value: function() {
                            return this.isChromiumBased() || this.isReactNative() || this.isSafariWithVP8()
                        }
                    }, {
                        key: "supportsBandwidthStatistics",
                        value: function() {
                            return !this.isFirefox() && !this.isEdge() && !this.isSafariWithWebrtc()
                        }
                    }, {
                        key: "supportsDataChannels",
                        value: function() {
                            return !this.isEdge()
                        }
                    }, {
                        key: "supportsDeviceChangeEvent",
                        value: function() {
                            return navigator.mediaDevices && void 0 !== navigator.mediaDevices.ondevicechange && void 0 !== navigator.mediaDevices.addEventListener
                        }
                    }, {
                        key: "supportsRtpStatistics",
                        value: function() {
                            return this.isChromiumBased() || this.isEdge() || this.isFirefox() || this.isReactNative() || this.isSafariWithWebrtc()
                        }
                    }, {
                        key: "supportsLocalCandidateRttStatistics",
                        value: function() {
                            return this.isChromiumBased() || this.isReactNative() || this.isSafariWithVP8()
                        }
                    }, {
                        key: "supportsRTTStatistics",
                        value: function() {
                            return !this.isFirefox() && !this.isEdge()
                        }
                    }, {
                        key: "supportsRtpSender",
                        value: function() {
                            return this.isFirefox() || this.isSafariWithVP8()
                        }
                    }, {
                        key: "supportsRtx",
                        value: function() {
                            return !this.isFirefox() && !this.usesUnifiedPlan()
                        }
                    }, {
                        key: "supportsSimulcast",
                        value: function() {
                            return this.isChromiumBased() || this.isFirefox() || this.isSafariWithVP8() || this.isReactNative()
                        }
                    }, {
                        key: "supportsVideo",
                        value: function() {
                            return !this.isSafariWithWebrtc() || this.isSafariWithVP8() && this.usesPlanB()
                        }
                    }, {
                        key: "usesPlanB",
                        value: function() {
                            return !this.usesUnifiedPlan()
                        }
                    }, {
                        key: "usesUnifiedPlan",
                        value: function() {
                            return !!this.isFirefox() || !(!this.isSafariWithVP8() || void 0 === window.RTCRtpTransceiver) && Object.keys(RTCRtpTransceiver.prototype).indexOf("currentDirection") > -1
                        }
                    }, {
                        key: "usesNewGumFlow",
                        value: function() {
                            return this.isChrome() ? !this.isVersionLessThan(61) : !(!this.isFirefox() && !this.isSafariWithWebrtc()) || !!this.isChromiumBased() && this._getChromiumBasedVersion() >= 61
                        }
                    }, {
                        key: "usesAdapter",
                        value: function() {
                            return this.usesNewGumFlow() || this.isEdge()
                        }
                    }, {
                        key: "supportsGetDisplayMedia",
                        value: function() {
                            return void 0 !== navigator.getDisplayMedia || void 0 !== navigator.mediaDevices && void 0 !== navigator.mediaDevices.getDisplayMedia
                        }
                    }, {
                        key: "supportsSdpSemantics",
                        value: function() {
                            return this.isChromiumBased() && this._getChromiumBasedVersion() >= 65
                        }
                    }, {
                        key: "_getChromiumBasedVersion",
                        value: function() {
                            if (this.isChromiumBased()) {
                                if (this.isNWJS()) return Number.parseInt(r.versions.chromium, 10);
                                var e = navigator.userAgent;
                                if (e.match(/Chrome/)) return Number.parseInt(e.match(/Chrome\/([\d.]+)/)[1], 10)
                            }
                            return -1
                        }
                    }]) && s(n.prototype, i), o && s(n, o), t
                }(o.a)
        }).call(this, "modules/browser/BrowserCapabilities.js", n(48))
    }, function(module, exports, __webpack_require__) {
        (function(process, global) {
            var __WEBPACK_AMD_DEFINE_RESULT__;
            /**
             * [js-md5]{@link https://github.com/emn178/js-md5}
             *
             * @namespace md5
             * @version 0.7.3
             * @author Chen, Yi-Cyuan [emn178@gmail.com]
             * @copyright Chen, Yi-Cyuan 2014-2017
             * @license MIT
             */
            ! function() {
                "use strict";
                var ERROR = "input is invalid type",
                    WINDOW = "object" == typeof window,
                    root = WINDOW ? window : {};
                root.JS_MD5_NO_WINDOW && (WINDOW = !1);
                var WEB_WORKER = !WINDOW && "object" == typeof self,
                    NODE_JS = !root.JS_MD5_NO_NODE_JS && "object" == typeof process && process.versions && process.versions.node;
                NODE_JS ? root = global : WEB_WORKER && (root = self);
                var COMMON_JS = !root.JS_MD5_NO_COMMON_JS && "object" == typeof module && module.exports,
                    AMD = __webpack_require__(122),
                    ARRAY_BUFFER = !root.JS_MD5_NO_ARRAY_BUFFER && "undefined" != typeof ArrayBuffer,
                    HEX_CHARS = "0123456789abcdef".split(""),
                    EXTRA = [128, 32768, 8388608, -2147483648],
                    SHIFT = [0, 8, 16, 24],
                    OUTPUT_TYPES = ["hex", "array", "digest", "buffer", "arrayBuffer", "base64"],
                    BASE64_ENCODE_CHAR = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split(""),
                    blocks = [],
                    buffer8;
                if (ARRAY_BUFFER) {
                    var buffer = new ArrayBuffer(68);
                    buffer8 = new Uint8Array(buffer), blocks = new Uint32Array(buffer)
                }!root.JS_MD5_NO_NODE_JS && Array.isArray || (Array.isArray = function(e) {
                    return "[object Array]" === Object.prototype.toString.call(e)
                }), !ARRAY_BUFFER || !root.JS_MD5_NO_ARRAY_BUFFER_IS_VIEW && ArrayBuffer.isView || (ArrayBuffer.isView = function(e) {
                    return "object" == typeof e && e.buffer && e.buffer.constructor === ArrayBuffer
                });
                var createOutputMethod = function(e) {
                        return function(t) {
                            return new Md5(!0).update(t)[e]()
                        }
                    },
                    createMethod = function() {
                        var e = createOutputMethod("hex");
                        NODE_JS && (e = nodeWrap(e)), e.create = function() {
                            return new Md5
                        }, e.update = function(t) {
                            return e.create().update(t)
                        };
                        for (var t = 0; t < OUTPUT_TYPES.length; ++t) {
                            var n = OUTPUT_TYPES[t];
                            e[n] = createOutputMethod(n)
                        }
                        return e
                    },
                    nodeWrap = function(method) {
                        var crypto = eval("require('crypto')"),
                            Buffer = eval("require('buffer').Buffer"),
                            nodeMethod = function(e) {
                                if ("string" == typeof e) return crypto.createHash("md5").update(e, "utf8").digest("hex");
                                if (null == e) throw ERROR;
                                return e.constructor === ArrayBuffer && (e = new Uint8Array(e)), Array.isArray(e) || ArrayBuffer.isView(e) || e.constructor === Buffer ? crypto.createHash("md5").update(new Buffer(e)).digest("hex") : method(e)
                            };
                        return nodeMethod
                    };

                function Md5(e) {
                    if (e) blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0, this.blocks = blocks, this.buffer8 = buffer8;
                    else if (ARRAY_BUFFER) {
                        var t = new ArrayBuffer(68);
                        this.buffer8 = new Uint8Array(t), this.blocks = new Uint32Array(t)
                    } else this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
                    this.h0 = this.h1 = this.h2 = this.h3 = this.start = this.bytes = this.hBytes = 0, this.finalized = this.hashed = !1, this.first = !0
                }
                Md5.prototype.update = function(e) {
                    if (!this.finalized) {
                        var t, n = typeof e;
                        if ("string" !== n) {
                            if ("object" !== n) throw ERROR;
                            if (null === e) throw ERROR;
                            if (ARRAY_BUFFER && e.constructor === ArrayBuffer) e = new Uint8Array(e);
                            else if (!(Array.isArray(e) || ARRAY_BUFFER && ArrayBuffer.isView(e))) throw ERROR;
                            t = !0
                        }
                        for (var r, i, o = 0, a = e.length, s = this.blocks, c = this.buffer8; o < a;) {
                            if (this.hashed && (this.hashed = !1, s[0] = s[16], s[16] = s[1] = s[2] = s[3] = s[4] = s[5] = s[6] = s[7] = s[8] = s[9] = s[10] = s[11] = s[12] = s[13] = s[14] = s[15] = 0), t)
                                if (ARRAY_BUFFER)
                                    for (i = this.start; o < a && i < 64; ++o) c[i++] = e[o];
                                else
                                    for (i = this.start; o < a && i < 64; ++o) s[i >> 2] |= e[o] << SHIFT[3 & i++];
                            else if (ARRAY_BUFFER)
                                for (i = this.start; o < a && i < 64; ++o)(r = e.charCodeAt(o)) < 128 ? c[i++] = r : r < 2048 ? (c[i++] = 192 | r >> 6, c[i++] = 128 | 63 & r) : r < 55296 || r >= 57344 ? (c[i++] = 224 | r >> 12, c[i++] = 128 | r >> 6 & 63, c[i++] = 128 | 63 & r) : (r = 65536 + ((1023 & r) << 10 | 1023 & e.charCodeAt(++o)), c[i++] = 240 | r >> 18, c[i++] = 128 | r >> 12 & 63, c[i++] = 128 | r >> 6 & 63, c[i++] = 128 | 63 & r);
                            else
                                for (i = this.start; o < a && i < 64; ++o)(r = e.charCodeAt(o)) < 128 ? s[i >> 2] |= r << SHIFT[3 & i++] : r < 2048 ? (s[i >> 2] |= (192 | r >> 6) << SHIFT[3 & i++], s[i >> 2] |= (128 | 63 & r) << SHIFT[3 & i++]) : r < 55296 || r >= 57344 ? (s[i >> 2] |= (224 | r >> 12) << SHIFT[3 & i++], s[i >> 2] |= (128 | r >> 6 & 63) << SHIFT[3 & i++], s[i >> 2] |= (128 | 63 & r) << SHIFT[3 & i++]) : (r = 65536 + ((1023 & r) << 10 | 1023 & e.charCodeAt(++o)), s[i >> 2] |= (240 | r >> 18) << SHIFT[3 & i++], s[i >> 2] |= (128 | r >> 12 & 63) << SHIFT[3 & i++], s[i >> 2] |= (128 | r >> 6 & 63) << SHIFT[3 & i++], s[i >> 2] |= (128 | 63 & r) << SHIFT[3 & i++]);
                            this.lastByteIndex = i, this.bytes += i - this.start, i >= 64 ? (this.start = i - 64, this.hash(), this.hashed = !0) : this.start = i
                        }
                        return this.bytes > 4294967295 && (this.hBytes += this.bytes / 4294967296 << 0, this.bytes = this.bytes % 4294967296), this
                    }
                }, Md5.prototype.finalize = function() {
                    if (!this.finalized) {
                        this.finalized = !0;
                        var e = this.blocks,
                            t = this.lastByteIndex;
                        e[t >> 2] |= EXTRA[3 & t], t >= 56 && (this.hashed || this.hash(), e[0] = e[16], e[16] = e[1] = e[2] = e[3] = e[4] = e[5] = e[6] = e[7] = e[8] = e[9] = e[10] = e[11] = e[12] = e[13] = e[14] = e[15] = 0), e[14] = this.bytes << 3, e[15] = this.hBytes << 3 | this.bytes >>> 29, this.hash()
                    }
                }, Md5.prototype.hash = function() {
                    var e, t, n, r, i, o, a = this.blocks;
                    this.first ? t = ((t = ((e = ((e = a[0] - 680876937) << 7 | e >>> 25) - 271733879 << 0) ^ (n = ((n = (-271733879 ^ (r = ((r = (-1732584194 ^ 2004318071 & e) + a[1] - 117830708) << 12 | r >>> 20) + e << 0) & (-271733879 ^ e)) + a[2] - 1126478375) << 17 | n >>> 15) + r << 0) & (r ^ e)) + a[3] - 1316259209) << 22 | t >>> 10) + n << 0 : (e = this.h0, t = this.h1, n = this.h2, t = ((t += ((e = ((e += ((r = this.h3) ^ t & (n ^ r)) + a[0] - 680876936) << 7 | e >>> 25) + t << 0) ^ (n = ((n += (t ^ (r = ((r += (n ^ e & (t ^ n)) + a[1] - 389564586) << 12 | r >>> 20) + e << 0) & (e ^ t)) + a[2] + 606105819) << 17 | n >>> 15) + r << 0) & (r ^ e)) + a[3] - 1044525330) << 22 | t >>> 10) + n << 0), t = ((t += ((e = ((e += (r ^ t & (n ^ r)) + a[4] - 176418897) << 7 | e >>> 25) + t << 0) ^ (n = ((n += (t ^ (r = ((r += (n ^ e & (t ^ n)) + a[5] + 1200080426) << 12 | r >>> 20) + e << 0) & (e ^ t)) + a[6] - 1473231341) << 17 | n >>> 15) + r << 0) & (r ^ e)) + a[7] - 45705983) << 22 | t >>> 10) + n << 0, t = ((t += ((e = ((e += (r ^ t & (n ^ r)) + a[8] + 1770035416) << 7 | e >>> 25) + t << 0) ^ (n = ((n += (t ^ (r = ((r += (n ^ e & (t ^ n)) + a[9] - 1958414417) << 12 | r >>> 20) + e << 0) & (e ^ t)) + a[10] - 42063) << 17 | n >>> 15) + r << 0) & (r ^ e)) + a[11] - 1990404162) << 22 | t >>> 10) + n << 0, t = ((t += ((e = ((e += (r ^ t & (n ^ r)) + a[12] + 1804603682) << 7 | e >>> 25) + t << 0) ^ (n = ((n += (t ^ (r = ((r += (n ^ e & (t ^ n)) + a[13] - 40341101) << 12 | r >>> 20) + e << 0) & (e ^ t)) + a[14] - 1502002290) << 17 | n >>> 15) + r << 0) & (r ^ e)) + a[15] + 1236535329) << 22 | t >>> 10) + n << 0, t = ((t += ((r = ((r += (t ^ n & ((e = ((e += (n ^ r & (t ^ n)) + a[1] - 165796510) << 5 | e >>> 27) + t << 0) ^ t)) + a[6] - 1069501632) << 9 | r >>> 23) + e << 0) ^ e & ((n = ((n += (e ^ t & (r ^ e)) + a[11] + 643717713) << 14 | n >>> 18) + r << 0) ^ r)) + a[0] - 373897302) << 20 | t >>> 12) + n << 0, t = ((t += ((r = ((r += (t ^ n & ((e = ((e += (n ^ r & (t ^ n)) + a[5] - 701558691) << 5 | e >>> 27) + t << 0) ^ t)) + a[10] + 38016083) << 9 | r >>> 23) + e << 0) ^ e & ((n = ((n += (e ^ t & (r ^ e)) + a[15] - 660478335) << 14 | n >>> 18) + r << 0) ^ r)) + a[4] - 405537848) << 20 | t >>> 12) + n << 0, t = ((t += ((r = ((r += (t ^ n & ((e = ((e += (n ^ r & (t ^ n)) + a[9] + 568446438) << 5 | e >>> 27) + t << 0) ^ t)) + a[14] - 1019803690) << 9 | r >>> 23) + e << 0) ^ e & ((n = ((n += (e ^ t & (r ^ e)) + a[3] - 187363961) << 14 | n >>> 18) + r << 0) ^ r)) + a[8] + 1163531501) << 20 | t >>> 12) + n << 0, t = ((t += ((r = ((r += (t ^ n & ((e = ((e += (n ^ r & (t ^ n)) + a[13] - 1444681467) << 5 | e >>> 27) + t << 0) ^ t)) + a[2] - 51403784) << 9 | r >>> 23) + e << 0) ^ e & ((n = ((n += (e ^ t & (r ^ e)) + a[7] + 1735328473) << 14 | n >>> 18) + r << 0) ^ r)) + a[12] - 1926607734) << 20 | t >>> 12) + n << 0, t = ((t += ((o = (r = ((r += ((i = t ^ n) ^ (e = ((e += (i ^ r) + a[5] - 378558) << 4 | e >>> 28) + t << 0)) + a[8] - 2022574463) << 11 | r >>> 21) + e << 0) ^ e) ^ (n = ((n += (o ^ t) + a[11] + 1839030562) << 16 | n >>> 16) + r << 0)) + a[14] - 35309556) << 23 | t >>> 9) + n << 0, t = ((t += ((o = (r = ((r += ((i = t ^ n) ^ (e = ((e += (i ^ r) + a[1] - 1530992060) << 4 | e >>> 28) + t << 0)) + a[4] + 1272893353) << 11 | r >>> 21) + e << 0) ^ e) ^ (n = ((n += (o ^ t) + a[7] - 155497632) << 16 | n >>> 16) + r << 0)) + a[10] - 1094730640) << 23 | t >>> 9) + n << 0, t = ((t += ((o = (r = ((r += ((i = t ^ n) ^ (e = ((e += (i ^ r) + a[13] + 681279174) << 4 | e >>> 28) + t << 0)) + a[0] - 358537222) << 11 | r >>> 21) + e << 0) ^ e) ^ (n = ((n += (o ^ t) + a[3] - 722521979) << 16 | n >>> 16) + r << 0)) + a[6] + 76029189) << 23 | t >>> 9) + n << 0, t = ((t += ((o = (r = ((r += ((i = t ^ n) ^ (e = ((e += (i ^ r) + a[9] - 640364487) << 4 | e >>> 28) + t << 0)) + a[12] - 421815835) << 11 | r >>> 21) + e << 0) ^ e) ^ (n = ((n += (o ^ t) + a[15] + 530742520) << 16 | n >>> 16) + r << 0)) + a[2] - 995338651) << 23 | t >>> 9) + n << 0, t = ((t += ((r = ((r += (t ^ ((e = ((e += (n ^ (t | ~r)) + a[0] - 198630844) << 6 | e >>> 26) + t << 0) | ~n)) + a[7] + 1126891415) << 10 | r >>> 22) + e << 0) ^ ((n = ((n += (e ^ (r | ~t)) + a[14] - 1416354905) << 15 | n >>> 17) + r << 0) | ~e)) + a[5] - 57434055) << 21 | t >>> 11) + n << 0, t = ((t += ((r = ((r += (t ^ ((e = ((e += (n ^ (t | ~r)) + a[12] + 1700485571) << 6 | e >>> 26) + t << 0) | ~n)) + a[3] - 1894986606) << 10 | r >>> 22) + e << 0) ^ ((n = ((n += (e ^ (r | ~t)) + a[10] - 1051523) << 15 | n >>> 17) + r << 0) | ~e)) + a[1] - 2054922799) << 21 | t >>> 11) + n << 0, t = ((t += ((r = ((r += (t ^ ((e = ((e += (n ^ (t | ~r)) + a[8] + 1873313359) << 6 | e >>> 26) + t << 0) | ~n)) + a[15] - 30611744) << 10 | r >>> 22) + e << 0) ^ ((n = ((n += (e ^ (r | ~t)) + a[6] - 1560198380) << 15 | n >>> 17) + r << 0) | ~e)) + a[13] + 1309151649) << 21 | t >>> 11) + n << 0, t = ((t += ((r = ((r += (t ^ ((e = ((e += (n ^ (t | ~r)) + a[4] - 145523070) << 6 | e >>> 26) + t << 0) | ~n)) + a[11] - 1120210379) << 10 | r >>> 22) + e << 0) ^ ((n = ((n += (e ^ (r | ~t)) + a[2] + 718787259) << 15 | n >>> 17) + r << 0) | ~e)) + a[9] - 343485551) << 21 | t >>> 11) + n << 0, this.first ? (this.h0 = e + 1732584193 << 0, this.h1 = t - 271733879 << 0, this.h2 = n - 1732584194 << 0, this.h3 = r + 271733878 << 0, this.first = !1) : (this.h0 = this.h0 + e << 0, this.h1 = this.h1 + t << 0, this.h2 = this.h2 + n << 0, this.h3 = this.h3 + r << 0)
                }, Md5.prototype.hex = function() {
                    this.finalize();
                    var e = this.h0,
                        t = this.h1,
                        n = this.h2,
                        r = this.h3;
                    return HEX_CHARS[e >> 4 & 15] + HEX_CHARS[15 & e] + HEX_CHARS[e >> 12 & 15] + HEX_CHARS[e >> 8 & 15] + HEX_CHARS[e >> 20 & 15] + HEX_CHARS[e >> 16 & 15] + HEX_CHARS[e >> 28 & 15] + HEX_CHARS[e >> 24 & 15] + HEX_CHARS[t >> 4 & 15] + HEX_CHARS[15 & t] + HEX_CHARS[t >> 12 & 15] + HEX_CHARS[t >> 8 & 15] + HEX_CHARS[t >> 20 & 15] + HEX_CHARS[t >> 16 & 15] + HEX_CHARS[t >> 28 & 15] + HEX_CHARS[t >> 24 & 15] + HEX_CHARS[n >> 4 & 15] + HEX_CHARS[15 & n] + HEX_CHARS[n >> 12 & 15] + HEX_CHARS[n >> 8 & 15] + HEX_CHARS[n >> 20 & 15] + HEX_CHARS[n >> 16 & 15] + HEX_CHARS[n >> 28 & 15] + HEX_CHARS[n >> 24 & 15] + HEX_CHARS[r >> 4 & 15] + HEX_CHARS[15 & r] + HEX_CHARS[r >> 12 & 15] + HEX_CHARS[r >> 8 & 15] + HEX_CHARS[r >> 20 & 15] + HEX_CHARS[r >> 16 & 15] + HEX_CHARS[r >> 28 & 15] + HEX_CHARS[r >> 24 & 15]
                }, Md5.prototype.toString = Md5.prototype.hex, Md5.prototype.digest = function() {
                    this.finalize();
                    var e = this.h0,
                        t = this.h1,
                        n = this.h2,
                        r = this.h3;
                    return [255 & e, e >> 8 & 255, e >> 16 & 255, e >> 24 & 255, 255 & t, t >> 8 & 255, t >> 16 & 255, t >> 24 & 255, 255 & n, n >> 8 & 255, n >> 16 & 255, n >> 24 & 255, 255 & r, r >> 8 & 255, r >> 16 & 255, r >> 24 & 255]
                }, Md5.prototype.array = Md5.prototype.digest, Md5.prototype.arrayBuffer = function() {
                    this.finalize();
                    var e = new ArrayBuffer(16),
                        t = new Uint32Array(e);
                    return t[0] = this.h0, t[1] = this.h1, t[2] = this.h2, t[3] = this.h3, e
                }, Md5.prototype.buffer = Md5.prototype.arrayBuffer, Md5.prototype.base64 = function() {
                    for (var e, t, n, r = "", i = this.array(), o = 0; o < 15;) e = i[o++], t = i[o++], n = i[o++], r += BASE64_ENCODE_CHAR[e >>> 2] + BASE64_ENCODE_CHAR[63 & (e << 4 | t >>> 4)] + BASE64_ENCODE_CHAR[63 & (t << 2 | n >>> 6)] + BASE64_ENCODE_CHAR[63 & n];
                    return e = i[o], r += BASE64_ENCODE_CHAR[e >>> 2] + BASE64_ENCODE_CHAR[e << 4 & 63] + "=="
                };
                var exports = createMethod();
                COMMON_JS ? module.exports = exports : (root.md5 = exports, AMD && (__WEBPACK_AMD_DEFINE_RESULT__ = function() {
                    return exports
                }.call(exports, __webpack_require__, exports, module), void 0 === __WEBPACK_AMD_DEFINE_RESULT__ || (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)))
            }()
        }).call(this, __webpack_require__(48), __webpack_require__(43))
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return f
            }));
            var r = n(3),
                i = n(19),
                o = n(23),
                a = n(9);

            function s(e, t) {
                return function(e) {
                    if (Array.isArray(e)) return e
                }(e) || function(e, t) {
                    var n = [],
                        r = !0,
                        i = !1,
                        o = void 0;
                    try {
                        for (var a, s = e[Symbol.iterator](); !(r = (a = s.next()).done) && (n.push(a.value), !t || n.length !== t); r = !0);
                    } catch (e) {
                        i = !0, o = e
                    } finally {
                        try {
                            r || null == s.return || s.return()
                        } finally {
                            if (i) throw o
                        }
                    }
                    return n
                }(e, t) || function() {
                    throw new TypeError("Invalid attempt to destructure non-iterable instance")
                }()
            }
            var c = n(11),
                u = n(4).getLogger(e),
                l = {};

            function d(e, t) {
                return !t || t <= 0 || !e || e <= 0 ? 0 : Math.round(e / t * 100)
            }

            function p() {
                this.loss = {}, this.bitrate = {
                    download: 0,
                    upload: 0
                }, this.resolution = {}, this.framerate = 0
            }

            function h() {
                this.bandwidth = {}, this.bitrate = {}, this.packetLoss = null, this.transport = []
            }

            function f(e, t, n, i) {
                this._browserType = r.a.getName();
                var o = l[this._browserType];
                if (!o) throw "The browser type '".concat(this._browserType, "' isn't supported!");
                this._usesPromiseGetStats = r.a.isSafariWithWebrtc() || r.a.isFirefox(), this._getStatValue = this._usesPromiseGetStats ? this._defineNewGetStatValueMethod(o) : this._defineGetStatValueMethod(o), this.peerconnection = e, this.baselineAudioLevelsReport = null, this.currentAudioLevelsReport = null, this.currentStatsReport = null, this.previousStatsReport = null, this.audioLevelReportHistory = {}, this.audioLevelsIntervalId = null, this.eventEmitter = i, this.conferenceStats = new h, this.audioLevelsIntervalMilis = t, this.statsIntervalId = null, this.statsIntervalMilis = n, this.ssrc2stats = new Map
            }
            l[i.b.FIREFOX] = {
                ssrc: "ssrc",
                packetsReceived: "packetsReceived",
                packetsLost: "packetsLost",
                packetsSent: "packetsSent",
                bytesReceived: "bytesReceived",
                bytesSent: "bytesSent",
                framerateMean: "framerateMean",
                ip: "ipAddress",
                port: "portNumber",
                protocol: "transport"
            }, l[i.b.CHROME] = {
                receiveBandwidth: "googAvailableReceiveBandwidth",
                sendBandwidth: "googAvailableSendBandwidth",
                remoteAddress: "googRemoteAddress",
                transportType: "googTransportType",
                localAddress: "googLocalAddress",
                activeConnection: "googActiveConnection",
                ssrc: "ssrc",
                packetsReceived: "packetsReceived",
                packetsSent: "packetsSent",
                packetsLost: "packetsLost",
                bytesReceived: "bytesReceived",
                bytesSent: "bytesSent",
                googFrameHeightReceived: "googFrameHeightReceived",
                googFrameWidthReceived: "googFrameWidthReceived",
                googFrameHeightSent: "googFrameHeightSent",
                googFrameWidthSent: "googFrameWidthSent",
                googFrameRateReceived: "googFrameRateReceived",
                googFrameRateSent: "googFrameRateSent",
                audioInputLevel: "audioInputLevel",
                audioOutputLevel: "audioOutputLevel",
                currentRoundTripTime: "googRtt",
                remoteCandidateType: "googRemoteCandidateType",
                localCandidateType: "googLocalCandidateType",
                ip: "ip",
                port: "port",
                protocol: "protocol"
            }, l[i.b.EDGE] = {
                sendBandwidth: "googAvailableSendBandwidth",
                remoteAddress: "remoteAddress",
                transportType: "protocol",
                localAddress: "localAddress",
                activeConnection: "activeConnection",
                ssrc: "ssrc",
                packetsReceived: "packetsReceived",
                packetsSent: "packetsSent",
                packetsLost: "packetsLost",
                bytesReceived: "bytesReceived",
                bytesSent: "bytesSent",
                googFrameHeightReceived: "frameHeight",
                googFrameWidthReceived: "frameWidth",
                googFrameHeightSent: "frameHeight",
                googFrameWidthSent: "frameWidth",
                googFrameRateReceived: "framesPerSecond",
                googFrameRateSent: "framesPerSecond",
                audioInputLevel: "audioLevel",
                audioOutputLevel: "audioLevel",
                currentRoundTripTime: "roundTripTime"
            }, l[i.b.OPERA] = l[i.b.CHROME], l[i.b.NWJS] = l[i.b.CHROME], l[i.b.ELECTRON] = l[i.b.CHROME], l[i.b.SAFARI] = l[i.b.CHROME], l[i.b.REACT_NATIVE] = l[i.b.CHROME], p.prototype.setLoss = function(e) {
                this.loss = e || {}
            }, p.prototype.setResolution = function(e) {
                this.resolution = e || {}
            }, p.prototype.addBitrate = function(e) {
                this.bitrate.download += e.download, this.bitrate.upload += e.upload
            }, p.prototype.resetBitrate = function() {
                this.bitrate.download = 0, this.bitrate.upload = 0
            }, p.prototype.setFramerate = function(e) {
                this.framerate = e || 0
            }, f.prototype.stop = function() {
                this.audioLevelsIntervalId && (clearInterval(this.audioLevelsIntervalId), this.audioLevelsIntervalId = null), this.statsIntervalId && (clearInterval(this.statsIntervalId), this.statsIntervalId = null)
            }, f.prototype.errorCallback = function(e) {
                c.callErrorHandler(e), u.error("Get stats error", e), this.stop()
            }, f.prototype.start = function(e) {
                var t = this,
                    n = this;
                e && (this.audioLevelsIntervalId = setInterval((function() {
                    n.peerconnection.getStats((function(e) {
                        var r = null;
                        r = e && e.result && "function" == typeof e.result ? e.result() : e, n.currentAudioLevelsReport = r, t._usesPromiseGetStats ? n.processNewAudioLevelReport() : n.processAudioLevelReport(), n.baselineAudioLevelsReport = n.currentAudioLevelsReport
                    }), (function(e) {
                        return n.errorCallback(e)
                    }))
                }), n.audioLevelsIntervalMilis)), r.a.supportsRtpStatistics() && (this.statsIntervalId = setInterval((function() {
                    n.peerconnection.getStats((function(e) {
                        var r = null;
                        r = e && e.result && "function" == typeof e.result ? e.result() : e, n.currentStatsReport = r;
                        try {
                            t._usesPromiseGetStats ? n.processNewStatsReport() : n.processStatsReport()
                        } catch (e) {
                            c.callErrorHandler(e), u.error("Unsupported key:".concat(e), e)
                        }
                        n.previousStatsReport = n.currentStatsReport
                    }), (function(e) {
                        return n.errorCallback(e)
                    }))
                }), n.statsIntervalMilis))
            }, f.prototype._defineGetStatValueMethod = function(e) {
                var t;
                switch (this._browserType) {
                    case i.b.CHROME:
                    case i.b.OPERA:
                    case i.b.NWJS:
                    case i.b.ELECTRON:
                        t = function(e, t) {
                            return e.stat(t)
                        };
                        break;
                    case i.b.REACT_NATIVE:
                        t = function(e, t) {
                            var n;
                            return e.values.some((function(e) {
                                return !!e.hasOwnProperty(t) && (n = e[t], !0)
                            })), n
                        };
                        break;
                    case i.b.EDGE:
                        t = function(e, t) {
                            return e[t]
                        };
                        break;
                    default:
                        t = function(e, t) {
                            return e[t]
                        }
                }
                return function(n, r) {
                    return t(n, function(t) {
                        var n = e[t];
                        if (n) return n;
                        throw "The property '".concat(t, "' isn't supported!")
                    }(r))
                }
            }, f.prototype.getNonNegativeStat = function(e, t) {
                var n = this._getStatValue(e, t);
                return "number" != typeof n && (n = Number(n)), isNaN(n) ? 0 : Math.max(0, n)
            }, f.prototype.processStatsReport = function() {
                var e = this;
                if (this.previousStatsReport) {
                    var t = this._getStatValue,
                        n = {};
                    for (var i in this.currentStatsReport)
                        if (this.currentStatsReport.hasOwnProperty(i)) {
                            var a = this.currentStatsReport[i];
                            if (a) {
                                try {
                                    var s = t(a, "receiveBandwidth"),
                                        c = t(a, "sendBandwidth");
                                    (s || c) && (this.conferenceStats.bandwidth = {
                                        download: Math.round(s / 1e3),
                                        upload: Math.round(c / 1e3)
                                    })
                                } catch (e) {}
                                if ("googCandidatePair" === a.type)
                                    if ("continue" === function() {
                                            var n = void 0,
                                                r = void 0,
                                                i = void 0,
                                                o = void 0,
                                                s = void 0,
                                                c = void 0,
                                                u = void 0;
                                            try {
                                                if (!(n = t(a, "activeConnection"))) return "continue";
                                                r = t(a, "remoteAddress"), u = t(a, "transportType"), o = t(a, "localAddress"), i = t(a, "localCandidateType"), s = t(a, "remoteCandidateType"), c = e.getNonNegativeStat(a, "currentRoundTripTime")
                                            } catch (e) {}
                                            if (!r || !u || !o || "true" !== n) return "continue";
                                            var l = e.conferenceStats.transport;
                                            return l.some((function(e) {
                                                return e.ip === r && e.type === u && e.localip === o
                                            })) || l.push({
                                                ip: r,
                                                type: u,
                                                localip: o,
                                                p2p: e.peerconnection.isP2P,
                                                localCandidateType: i,
                                                remoteCandidateType: s,
                                                rtt: c
                                            }), "continue"
                                        }()) continue;
                                if ("candidatepair" === a.type) {
                                    if ("succeeded" !== a.state || !a.selected) continue;
                                    var l = this.currentStatsReport[a.localCandidateId],
                                        d = this.currentStatsReport[a.remoteCandidateId];
                                    this.conferenceStats.transport.push({
                                        ip: "".concat(d.ipAddress, ":").concat(d.portNumber),
                                        type: l.transport,
                                        localip: "".concat(l.ipAddress, ":").concat(l.portNumber),
                                        p2p: this.peerconnection.isP2P,
                                        localCandidateType: l.candidateType,
                                        remoteCandidateType: d.candidateType
                                    })
                                }
                                if ("transportdiagnostics" === a.msType && this.conferenceStats.transport.push({
                                        ip: a.remoteAddress,
                                        type: a.protocol,
                                        localip: a.localAddress,
                                        p2p: this.peerconnection.isP2P
                                    }), ("ssrc" === a.type || "outboundrtp" === a.type || "inboundrtp" === a.type || "track" === a.type) && (!r.a.isEdge() || "inboundrtp" !== a.type && "outboundrtp" !== a.type)) {
                                    var h = this.previousStatsReport[i],
                                        f = this.getNonNegativeStat(a, "ssrc");
                                    if ("track" === a.type && Array.isArray(a.ssrcIds) && (f = Number(a.ssrcIds[0])), h && f && (r.a.isEdge() || !0 !== a.isRemote && !0 !== a.remoteSource)) {
                                        var m = this.ssrc2stats.get(f);
                                        m || (m = new p, this.ssrc2stats.set(f, m));
                                        var v = !0,
                                            y = "packetsReceived",
                                            g = t(a, y);
                                        null != g && "" !== g || (v = !1, null == (g = t(a, y = "packetsSent")) && u.warn("No packetsReceived nor packetsSent stat found")), (!g || g < 0) && (g = 0);
                                        var _ = this.getNonNegativeStat(h, y),
                                            S = Math.max(0, g - _),
                                            b = this.getNonNegativeStat(a, "packetsLost"),
                                            E = this.getNonNegativeStat(h, "packetsLost"),
                                            T = Math.max(0, b - E);
                                        m.setLoss({
                                            packetsTotal: S + T,
                                            packetsLost: T,
                                            isDownloadStream: v
                                        });
                                        var C = this.getNonNegativeStat(a, "bytesReceived"),
                                            R = this.getNonNegativeStat(h, "bytesReceived"),
                                            A = Math.max(0, C - R),
                                            w = 0,
                                            k = t(a, "bytesSent");
                                        "number" != typeof k && "string" != typeof k || (k = Number(k), isNaN(k) || (n[f] = k, k > 0 && (w = k - t(h, "bytesSent")))), w = Math.max(0, w);
                                        var O = a.timestamp - h.timestamp,
                                            I = 0,
                                            P = 0;
                                        O > 0 && (I = Math.round(8 * A / O), P = Math.round(8 * w / O)), m.addBitrate({
                                            download: I,
                                            upload: P
                                        });
                                        var D = {
                                            height: null,
                                            width: null
                                        };
                                        try {
                                            var N = void 0,
                                                L = void 0;
                                            (N = t(a, "googFrameHeightReceived")) && (L = t(a, "googFrameWidthReceived")) ? (D.height = N, D.width = L) : (N = t(a, "googFrameHeightSent")) && (L = t(a, "googFrameWidthSent")) && (D.height = N, D.width = L)
                                        } catch (e) {}
                                        var M = void 0;
                                        try {
                                            M = t(a, "googFrameRateReceived") || t(a, "googFrameRateSent") || 0
                                        } catch (e) {
                                            try {
                                                M = this.getNonNegativeStat(a, "framerateMean")
                                            } catch (e) {}
                                        }
                                        m.setFramerate(Math.round(M || 0)), D.height && D.width ? m.setResolution(D) : m.setResolution(null)
                                    }
                                }
                            }
                        } this.eventEmitter.emit(o.c, this.peerconnection, n), this._processAndEmitReport()
                }
            }, f.prototype._processAndEmitReport = function() {
                var e = this,
                    t = {
                        download: 0,
                        upload: 0
                    },
                    n = {
                        download: 0,
                        upload: 0
                    },
                    r = 0,
                    i = 0,
                    a = {},
                    c = {},
                    l = 0,
                    p = 0,
                    h = 0,
                    f = 0,
                    m = !0,
                    v = !1,
                    y = void 0;
                try {
                    for (var g, _ = this.ssrc2stats[Symbol.iterator](); !(m = (g = _.next()).done); m = !0) {
                        var S = s(g.value, 2),
                            b = S[0],
                            E = S[1],
                            T = E.loss,
                            C = T.isDownloadStream ? "download" : "upload";
                        t[C] += T.packetsTotal, n[C] += T.packetsLost, r += E.bitrate.download, i += E.bitrate.upload;
                        var R = this.peerconnection.getTrackBySSRC(b);
                        if (R) {
                            R.isAudioTrack() ? (l += E.bitrate.download, p += E.bitrate.upload) : (h += E.bitrate.download, f += E.bitrate.upload);
                            var A = R.getParticipantId();
                            if (A) {
                                var w = E.resolution;
                                if (w.width && w.height && -1 !== w.width && -1 !== w.height) {
                                    var k = a[A] || {};
                                    k[b] = w, a[A] = k
                                }
                                if (0 !== E.framerate) {
                                    var O = c[A] || {};
                                    O[b] = E.framerate, c[A] = O
                                }
                            } else u.error("No participant ID returned by ".concat(R))
                        }
                        E.resetBitrate()
                    }
                } catch (e) {
                    v = !0, y = e
                } finally {
                    try {
                        m || null == _.return || _.return()
                    } finally {
                        if (v) throw y
                    }
                }
                this.conferenceStats.bitrate = {
                    upload: i,
                    download: r
                }, this.conferenceStats.bitrate.audio = {
                    upload: p,
                    download: l
                }, this.conferenceStats.bitrate.video = {
                    upload: f,
                    download: h
                }, this.conferenceStats.packetLoss = {
                    total: d(n.download + n.upload, t.download + t.upload),
                    download: d(n.download, t.download),
                    upload: d(n.upload, t.upload)
                };
                var I, P = {};
                Object.keys(this.audioLevelReportHistory).forEach((function(t) {
                    var n = e.audioLevelReportHistory[t],
                        r = n.data,
                        i = n.isLocal,
                        o = r.reduce((function(e, t) {
                            return e + t
                        })) / r.length;
                    if (i) I = o;
                    else {
                        var a = e.peerconnection.getTrackBySSRC(Number(t));
                        if (a) {
                            var s = a.getParticipantId();
                            s && (P[s] = o)
                        }
                    }
                })), this.audioLevelReportHistory = {}, this.eventEmitter.emit(o.d, this.peerconnection, {
                    bandwidth: this.conferenceStats.bandwidth,
                    bitrate: this.conferenceStats.bitrate,
                    packetLoss: this.conferenceStats.packetLoss,
                    resolution: a,
                    framerate: c,
                    transport: this.conferenceStats.transport,
                    localAvgAudioLevels: I,
                    avgAudioLevels: P
                }), this.conferenceStats.transport = []
            }, f.prototype.processAudioLevelReport = function() {
                if (this.baselineAudioLevelsReport) {
                    var e = this._getStatValue;
                    for (var t in this.currentAudioLevelsReport)
                        if (this.currentAudioLevelsReport.hasOwnProperty(t)) {
                            var n = this.currentAudioLevelsReport[t];
                            if ("ssrc" === n.type || "track" === n.type) {
                                var i = this.baselineAudioLevelsReport[t],
                                    a = this.getNonNegativeStat(n, "ssrc");
                                if (!a && Array.isArray(n.ssrcIds) && (a = Number(n.ssrcIds[0])), i)
                                    if (a) {
                                        var s = void 0;
                                        try {
                                            s = e(n, "audioInputLevel") || e(n, "audioOutputLevel")
                                        } catch (e) {
                                            return u.warn("Audio Levels are not available in the statistics."), void clearInterval(this.audioLevelsIntervalId)
                                        }
                                        if (s) {
                                            var c = void 0;
                                            c = "ssrc" === n.type ? !e(n, "packetsReceived") : !n.remoteSource, r.a.isEdge() ? s = s < 0 ? Math.pow(10, s / 20) : 0 : s /= 32767, a in this.audioLevelReportHistory || (this.audioLevelReportHistory[a] = {
                                                isLocal: c,
                                                data: []
                                            }), this.audioLevelReportHistory[a].data.push(s), this.eventEmitter.emit(o.a, this.peerconnection, a, s, c)
                                        }
                                    } else Date.now() - n.timestamp < 3e3 && u.warn("No ssrc: ");
                                else u.warn("".concat(a, " not enough data"))
                            }
                        }
                }
            }, f.prototype._defineNewGetStatValueMethod = function(e) {
                return function(t, n) {
                    return t[function(t) {
                        var n = e[t];
                        if (n) return n;
                        throw "The property '".concat(t, "' isn't supported!")
                    }(n)]
                }
            }, f.prototype.getNonNegativeValue = function(e) {
                var t = e;
                return "number" != typeof t && (t = Number(t)), isNaN(t) ? 0 : Math.max(0, t)
            }, f.prototype._calculateBitrate = function(e, t, n) {
                var r = this.getNonNegativeValue(e[n]),
                    i = this.getNonNegativeValue(t[n]),
                    o = Math.max(0, r - i),
                    a = e.timestamp - t.timestamp,
                    s = 0;
                return a > 0 && (s = Math.round(8 * o / a)), s
            }, f.prototype.processNewStatsReport = function() {
                var e = this;
                if (this.previousStatsReport) {
                    var t = this._getStatValue,
                        n = {};
                    this.currentStatsReport.forEach((function(r) {
                        if ("candidate-pair" === r.type && r.nominated && "succeeded" === r.state) {
                            var i = r.availableIncomingBitrate,
                                o = r.availableOutgoingBitrate;
                            (i || o) && (e.conferenceStats.bandwidth = {
                                download: Math.round(i / 1e3),
                                upload: Math.round(o / 1e3)
                            });
                            var a = e.currentStatsReport.get(r.remoteCandidateId),
                                s = e.currentStatsReport.get(r.localCandidateId);
                            if (a && s) {
                                var c = t(a, "ip"),
                                    u = t(a, "port"),
                                    l = "".concat(c, ":").concat(u),
                                    d = t(s, "ip"),
                                    h = t(s, "port"),
                                    f = "".concat(d, ":").concat(h),
                                    m = t(a, "protocol"),
                                    v = e.conferenceStats.transport;
                                v.some((function(e) {
                                    return e.ip === l && e.type === m && e.localip === f
                                })) || v.push({
                                    ip: l,
                                    type: m,
                                    localIp: f,
                                    p2p: e.peerconnection.isP2P,
                                    localCandidateType: s.candidateType,
                                    remoteCandidateType: a.candidateType,
                                    networkType: s.networkType,
                                    rtt: 1e3 * r.currentRoundTripTime
                                })
                            }
                        } else if ("inbound-rtp" === r.type || "outbound-rtp" === r.type) {
                            var y = e.previousStatsReport.get(r.id),
                                g = e.getNonNegativeValue(r.ssrc);
                            if (!y || !g) return;
                            var _ = e.ssrc2stats.get(g);
                            _ || (_ = new p, e.ssrc2stats.set(g, _));
                            var S = !0,
                                b = "packetsReceived";
                            "outbound-rtp" === r.type && (S = !1, b = "packetsSent");
                            var E = r[b];
                            (!E || E < 0) && (E = 0);
                            var T = e.getNonNegativeValue(y[b]),
                                C = Math.max(0, E - T),
                                R = e.getNonNegativeValue(r.packetsLost),
                                A = e.getNonNegativeValue(y.packetsLost),
                                w = Math.max(0, R - A);
                            _.setLoss({
                                packetsTotal: C + w,
                                packetsLost: w,
                                isDownloadStream: S
                            }), "inbound-rtp" === r.type ? _.addBitrate({
                                download: e._calculateBitrate(r, y, "bytesReceived"),
                                upload: 0
                            }) : (n[g] = e.getNonNegativeValue(r.bytesSent), _.addBitrate({
                                download: 0,
                                upload: e._calculateBitrate(r, y, "bytesSent")
                            }));
                            var k = r.framerateMean;
                            k && _.setFramerate(Math.round(k || 0))
                        } else if ("track" === r.type) {
                            var O = {
                                    height: r.frameHeight,
                                    width: r.frameWidth
                                },
                                I = r.framesPerSecond;
                            if (!I) {
                                var P = e.previousStatsReport.get(r.id);
                                if (P) {
                                    var D = r.timestamp - P.timestamp;
                                    if (D > 0 && r.framesSent) I = (r.framesSent - P.framesSent) / D * 1e3
                                }
                                if (!I) return
                            }
                            var N = r.trackIdentifier,
                                L = e.peerconnection.getSsrcByTrackId(N),
                                M = e.ssrc2stats.get(L);
                            M || (M = new p, e.ssrc2stats.set(L, M)), M.setFramerate(Math.round(I || 0)), O.height && O.width ? M.setResolution(O) : M.setResolution(null)
                        }
                    })), this.eventEmitter.emit(o.c, this.peerconnection, n), this._processAndEmitReport()
                }
            }, f.prototype.processNewAudioLevelReport = function() {
                var e = this;
                this.baselineAudioLevelsReport && this.currentAudioLevelsReport.forEach((function(t) {
                    if ("track" === t.type) {
                        var n = t.audioLevel;
                        if (n) {
                            var r = t.trackIdentifier,
                                i = e.peerconnection.getSsrcByTrackId(r);
                            if (i) {
                                var s = i === e.peerconnection.getLocalSSRC(e.peerconnection.getLocalTracks(a.a));
                                e.eventEmitter.emit(o.a, e.peerconnection, i, n, s)
                            }
                        }
                    }
                }))
            }
        }).call(this, "modules/statistics/RTPStatsCollector.js")
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return l
            }));
            var r = n(1),
                i = n(4),
                o = n(2),
                a = n(41),
                s = n(9);

            function c(e, t) {
                for (var n = 0; n < t.length; n++) {
                    var r = t[n];
                    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                }
            }
            var u = Object(i.getLogger)(e),
                l = function() {
                    function e(t, n, i, o, s, c, u) {
                        ! function(e, t) {
                            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                        }(this, e), this._jid = t, this._id = r.Strophe.getResourceFromJid(t), this._conference = n, this._displayName = i, this._supportsDTMF = !1, this._tracks = [], this._role = "none", this._status = c, this._hidden = o, this._statsID = s, this._connectionStatus = a.a.ACTIVE, this._properties = {}, this._identity = u
                    }
                    var t, n, i;
                    return t = e, (n = [{
                        key: "getConference",
                        value: function() {
                            return this._conference
                        }
                    }, {
                        key: "getProperty",
                        value: function(e) {
                            return this._properties[e]
                        }
                    }, {
                        key: "hasAnyVideoTrackWebRTCMuted",
                        value: function() {
                            return this.getTracks().some((function(e) {
                                return e.getType() === s.b && e.isWebRTCTrackMuted()
                            }))
                        }
                    }, {
                        key: "_setConnectionStatus",
                        value: function(e) {
                            this._connectionStatus = e
                        }
                    }, {
                        key: "getConnectionStatus",
                        value: function() {
                            return this._connectionStatus
                        }
                    }, {
                        key: "setProperty",
                        value: function(e, t) {
                            var n = this._properties[e];
                            t !== n && (this._properties[e] = t, this._conference.eventEmitter.emit(o.PARTICIPANT_PROPERTY_CHANGED, this, e, n, t))
                        }
                    }, {
                        key: "getTracks",
                        value: function() {
                            return this._tracks.slice()
                        }
                    }, {
                        key: "getTracksByMediaType",
                        value: function(e) {
                            return this.getTracks().filter((function(t) {
                                return t.getType() === e
                            }))
                        }
                    }, {
                        key: "getId",
                        value: function() {
                            return this._id
                        }
                    }, {
                        key: "getJid",
                        value: function() {
                            return this._jid
                        }
                    }, {
                        key: "getDisplayName",
                        value: function() {
                            return this._displayName
                        }
                    }, {
                        key: "getStatsID",
                        value: function() {
                            return this._statsID
                        }
                    }, {
                        key: "getStatus",
                        value: function() {
                            return this._status
                        }
                    }, {
                        key: "isModerator",
                        value: function() {
                            return "moderator" === this._role
                        }
                    }, {
                        key: "isHidden",
                        value: function() {
                            return this._hidden
                        }
                    }, {
                        key: "isAudioMuted",
                        value: function() {
                            return this._isMediaTypeMuted(s.a)
                        }
                    }, {
                        key: "_isMediaTypeMuted",
                        value: function(e) {
                            return this.getTracks().reduce((function(t, n) {
                                return t && (n.getType() !== e || n.isMuted())
                            }), !0)
                        }
                    }, {
                        key: "isVideoMuted",
                        value: function() {
                            return this._isMediaTypeMuted(s.b)
                        }
                    }, {
                        key: "getRole",
                        value: function() {
                            return this._role
                        }
                    }, {
                        key: "supportsDTMF",
                        value: function() {
                            return this._supportsDTMF
                        }
                    }, {
                        key: "getFeatures",
                        value: function() {
                            var e = this,
                                t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 5e3;
                            return this._conference.xmpp.caps.getFeatures(this._jid, t).catch((function(n) {
                                return n && n.constructor === String ? e._conference.xmpp.caps.getFeatures(e._jid, t) : (u.warn("Failed to discover features of ".concat(e._jid), n), Promise.reject(n))
                            }))
                        }
                    }, {
                        key: "getBotType",
                        value: function() {
                            return this._botType
                        }
                    }]) && c(t.prototype, n), i && c(t, i), e
                }()
        }).call(this, "JitsiParticipant.js")
    }, function(e, t, n) {
        "use strict";
        n.d(t, "a", (function() {
            return o
        }));
        var r = n(21),
            i = n(35);

        function o(e) {
            var t, n = this,
                o = e.id,
                a = e.password,
                s = e.onCreateResource,
                c = e.onLoginSuccessful,
                u = e.roomPassword,
                l = !1,
                d = new i.c(this.connection.options),
                p = new Promise((function(e, i) {
                    t = i, d.addListener(r.CONNECTION_DISCONNECTED, (function() {
                        d = void 0
                    })), d.addListener(r.CONNECTION_ESTABLISHED, (function() {
                        l || (c && c(), d.createRoom(n.options.name, n.options.config, s).moderator.authenticate().then((function() {
                            d && d.disconnect(), l || (n.join(u), e())
                        })).catch((function(e) {
                            var t = e.error,
                                n = e.message;
                            d.disconnect(), i({
                                authenticationError: t,
                                message: n
                            })
                        })))
                    })), d.addListener(r.CONNECTION_FAILED, (function(e, t, n) {
                        i({
                            connectionError: e,
                            credentials: n,
                            message: t
                        }), d = void 0
                    })), l || d.connect(o, a)
                }));
            return p.cancel = function() {
                l = !0, t({}), d && d.disconnect()
            }, p
        }
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            var r = n(4),
                i = n(1),
                o = n(78),
                a = n(34),
                s = n(0),
                c = n.n(s);

            function u(e) {
                return (u = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                    return typeof e
                } : function(e) {
                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                })(e)
            }

            function l(e, t) {
                for (var n = 0; n < t.length; n++) {
                    var r = t[n];
                    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                }
            }

            function d(e, t) {
                return !t || "object" !== u(t) && "function" != typeof t ? function(e) {
                    if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return e
                }(e) : t
            }

            function p(e, t, n) {
                return (p = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function(e, t, n) {
                    var r = function(e, t) {
                        for (; !Object.prototype.hasOwnProperty.call(e, t) && null !== (e = h(e)););
                        return e
                    }(e, t);
                    if (r) {
                        var i = Object.getOwnPropertyDescriptor(r, t);
                        return i.get ? i.get.call(n) : i.value
                    }
                })(e, t, n || e)
            }

            function h(e) {
                return (h = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
                    return e.__proto__ || Object.getPrototypeOf(e)
                })(e)
            }

            function f(e, t) {
                return (f = Object.setPrototypeOf || function(e, t) {
                    return e.__proto__ = t, e
                })(e, t)
            }
            var m = Object(r.getLogger)(e),
                v = function(e) {
                    function t(e) {
                        var n;
                        return function(e, t) {
                            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                        }(this, t), (n = d(this, h(t).call(this))).xmpp = e, n.rooms = {}, n
                    }
                    var n, r, a;
                    return function(e, t) {
                        if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
                        e.prototype = Object.create(t && t.prototype, {
                            constructor: {
                                value: e,
                                writable: !0,
                                configurable: !0
                            }
                        }), t && f(e, t)
                    }(t, e), n = t, (r = [{
                        key: "init",
                        value: function(e) {
                            p(h(t.prototype), "init", this).call(this, e), this.connection.addHandler(this.onPresence.bind(this), null, "presence", null, null, null, null), this.connection.addHandler(this.onPresenceUnavailable.bind(this), null, "presence", "unavailable", null), this.connection.addHandler(this.onPresenceError.bind(this), null, "presence", "error", null), this.connection.addHandler(this.onMessage.bind(this), null, "message", null, null), this.connection.addHandler(this.onMute.bind(this), "http://jitsi.org/jitmeet/audio", "iq", "set", null, null)
                        }
                    }, {
                        key: "createRoom",
                        value: function(e, t, n) {
                            var r = i.Strophe.getBareJidFromJid(e);
                            if (this.rooms[r]) {
                                var a = "You are already in the room!";
                                throw m.error(a), new Error(a)
                            }
                            return this.rooms[r] = new o.a(this.connection, e, t, this.xmpp, n), this.eventEmitter.emit(c.a.EMUC_ROOM_ADDED, this.rooms[r]), this.rooms[r]
                        }
                    }, {
                        key: "doLeave",
                        value: function(e) {
                            this.eventEmitter.emit(c.a.EMUC_ROOM_REMOVED, this.rooms[e]), delete this.rooms[e]
                        }
                    }, {
                        key: "onPresence",
                        value: function(e) {
                            var t = e.getAttribute("from");
                            if (e.getAttribute("type")) return !0;
                            var n = this.rooms[i.Strophe.getBareJidFromJid(t)];
                            return !n || ($(e).find('>x[xmlns="http://jabber.org/protocol/muc#user"]>status[code="201"]').length && n.createNonAnonymousRoom(), n.onPresence(e), !0)
                        }
                    }, {
                        key: "onPresenceUnavailable",
                        value: function(e) {
                            var t = e.getAttribute("from"),
                                n = this.rooms[i.Strophe.getBareJidFromJid(t)];
                            return !n || (n.onPresenceUnavailable(e, t), !0)
                        }
                    }, {
                        key: "onPresenceError",
                        value: function(e) {
                            var t = e.getAttribute("from"),
                                n = this.rooms[i.Strophe.getBareJidFromJid(t)];
                            return !n || (n.onPresenceError(e, t), !0)
                        }
                    }, {
                        key: "onMessage",
                        value: function(e) {
                            var t = e.getAttribute("from"),
                                n = this.rooms[i.Strophe.getBareJidFromJid(t)];
                            return !n || (n.onMessage(e, t), !0)
                        }
                    }, {
                        key: "onMute",
                        value: function(e) {
                            var t = e.getAttribute("from"),
                                n = this.rooms[i.Strophe.getBareJidFromJid(t)];
                            return !n || (n.onMute(e), !0)
                        }
                    }]) && l(n.prototype, r), a && l(n, a), t
                }(a.a);
            t.a = function(e) {
                i.Strophe.addConnectionPlugin("emuc", new v(e))
            }
        }).call(this, "modules/xmpp/strophe.emuc.js")
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return b
            }));
            var r = n(4),
                i = n(1),
                o = n(11),
                a = n.n(o),
                s = n(52),
                c = n(24),
                u = n(9),
                l = n(0),
                d = n.n(l),
                p = n(79);

            function h(e) {
                return (h = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                    return typeof e
                } : function(e) {
                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                })(e)
            }

            function f(e, t) {
                for (var n = 0; n < t.length; n++) {
                    var r = t[n];
                    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                }
            }

            function m(e, t) {
                return !t || "object" !== h(t) && "function" != typeof t ? function(e) {
                    if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return e
                }(e) : t
            }

            function v(e) {
                return (v = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
                    return e.__proto__ || Object.getPrototypeOf(e)
                })(e)
            }

            function y(e, t) {
                return (y = Object.setPrototypeOf || function(e, t) {
                    return e.__proto__ = t, e
                })(e, t)
            }
            var g = Object(r.getLogger)(e),
                _ = {
                    packet2JSON: function(e, t) {
                        for (var n = Array.from(e.children), r = 0; r < n.length; r++) {
                            for (var o = n[r], a = {
                                    attributes: {},
                                    children: [],
                                    tagName: o.tagName
                                }, s = Array.from(o.attributes), c = 0; c < s.length; c++) {
                                var u = s[c];
                                a.attributes[u.name] = u.value
                            }
                            var l = i.Strophe.getText(o);
                            l && (a.value = i.Strophe.xmlunescape(l)), t.push(a), this.packet2JSON(o, a.children)
                        }
                    },
                    json2packet: function(e, t) {
                        for (var n = 0; n < e.length; n++) {
                            var r = e[n];
                            r && (t.c(r.tagName, r.attributes), r.value && t.t(r.value), r.children && this.json2packet(r.children, t), t.up())
                        }
                    }
                };

            function S(e, t) {
                for (var n = [], r = 0; r < e.length; r++) e[r].tagName === t && n.push(e[r]);
                return n
            }
            var b = function(e) {
                function t(e, n, r, o, a) {
                    var c;
                    return function(e, t) {
                        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                    }(this, t), (c = m(this, v(t).call(this))).xmpp = o, c.connection = e, c.roomjid = i.Strophe.getBareJidFromJid(n), c.myroomjid = n, c.password = r, g.info("Joined MUC as ".concat(c.myroomjid)), c.members = {}, c.presMap = {}, c.presHandlers = {}, c.joined = !1, c.role = null, c.focusMucJid = null, c.noBridgeAvailable = !1, c.options = a || {}, c.moderator = new p.a(c.roomjid, c.xmpp, c.eventEmitter, {
                        connection: c.xmpp.options,
                        conference: c.options
                    }), c.initPresenceMap(a), c.lastPresences = {}, c.phoneNumber = null, c.phonePin = null, c.connectionTimes = {}, c.participantPropertyListener = null, c.locked = !1, c.transcriptionStatus = s.OFF, c
                }
                var n, r, o;
                return function(e, t) {
                    if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
                    e.prototype = Object.create(t && t.prototype, {
                        constructor: {
                            value: e,
                            writable: !0,
                            configurable: !0
                        }
                    }), t && y(e, t)
                }(t, e), n = t, (r = [{
                    key: "initPresenceMap",
                    value: function() {
                        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                        this.presMap.to = this.myroomjid, this.presMap.xns = "http://jabber.org/protocol/muc", this.presMap.nodes = [], e.statsId && this.presMap.nodes.push({
                            tagName: "stats-id",
                            value: e.statsId
                        }), this.addVideoInfoToPresence(!1), e.deploymentInfo && e.deploymentInfo.userRegion && this.presMap.nodes.push({
                            tagName: "region",
                            attributes: {
                                id: e.deploymentInfo.userRegion,
                                xmlns: "http://jitsi.org/jitsi-meet"
                            }
                        })
                    }
                }, {
                    key: "join",
                    value: function(e) {
                        var t = this;
                        return this.password = e, new Promise((function(e) {
                            t.options.disableFocus && g.info("Conference focus disabled"), (t.options.disableFocus ? Promise.resolve() : t.moderator.allocateConferenceFocus()).then((function() {
                                t.sendPresence(!0), e()
                            }))
                        }))
                    }
                }, {
                    key: "sendPresence",
                    value: function(e) {
                        var t = this.presMap.to;
                        if (t && (this.joined || e)) {
                            var n = Object(i.$pres)({
                                to: t
                            });
                            e && (n.c("x", {
                                xmlns: this.presMap.xns
                            }), this.password && n.c("password").t(this.password).up(), n.up()), _.json2packet(this.presMap.nodes, n), this.connection.send(n), e && this.connection.flush()
                        }
                    }
                }, {
                    key: "doLeave",
                    value: function() {
                        g.log("do leave", this.myroomjid);
                        var e = Object(i.$pres)({
                            to: this.myroomjid,
                            type: "unavailable"
                        });
                        this.presMap.length = 0, this.connection.flush(), this.connection.send(e), this.connection.flush()
                    }
                }, {
                    key: "discoRoomInfo",
                    value: function() {
                        var e = this,
                            t = Object(i.$iq)({
                                type: "get",
                                to: this.roomjid
                            }).c("query", {
                                xmlns: i.Strophe.NS.DISCO_INFO
                            });
                        this.connection.sendIQ(t, (function(t) {
                            var n = 1 === $(t).find('>query>feature[var="muc_passwordprotected"]').length;
                            n !== e.locked && (e.eventEmitter.emit(d.a.MUC_LOCK_CHANGED, n), e.locked = n)
                        }), (function(e) {
                            a.a.callErrorHandler(e), g.error("Error getting room info: ", e)
                        }))
                    }
                }, {
                    key: "createNonAnonymousRoom",
                    value: function() {
                        var e = Object(i.$iq)({
                                type: "get",
                                to: this.roomjid
                            }).c("query", {
                                xmlns: "http://jabber.org/protocol/muc#owner"
                            }).c("x", {
                                xmlns: "jabber:x:data",
                                type: "submit"
                            }),
                            t = this;
                        this.connection.sendIQ(e, (function(e) {
                            if (!$(e).find('>query>x[xmlns="jabber:x:data"]>field[var="muc#roomconfig_whois"]').length) {
                                var n = "non-anonymous rooms not supported";
                                return a.a.callErrorHandler(new Error(n)), void g.error(n)
                            }
                            var r = Object(i.$iq)({
                                to: t.roomjid,
                                type: "set"
                            }).c("query", {
                                xmlns: "http://jabber.org/protocol/muc#owner"
                            });
                            r.c("x", {
                                xmlns: "jabber:x:data",
                                type: "submit"
                            }), r.c("field", {
                                var: "FORM_TYPE"
                            }).c("value").t("http://jabber.org/protocol/muc#roomconfig").up().up(), r.c("field", {
                                var: "muc#roomconfig_whois"
                            }).c("value").t("anyone").up().up(), t.connection.sendIQ(r)
                        }), (function(e) {
                            a.a.callErrorHandler(e), g.error("Error getting room configuration form: ", e)
                        }))
                    }
                }, {
                    key: "onPresence",
                    value: function(e) {
                        var t = e.getAttribute("from"),
                            n = {},
                            r = e.getElementsByTagName("status")[0];
                        r && (n.status = r.textContent || "");
                        var o = !1,
                            a = !1,
                            s = e.getElementsByTagNameNS("http://jabber.org/protocol/muc#user", "x")[0],
                            c = s && s.getElementsByTagName("item")[0];
                        n.affiliation = c && c.getAttribute("affiliation"), n.role = c && c.getAttribute("role");
                        var u = c && c.getAttribute("jid");
                        n.jid = u, n.isFocus = u && 0 === u.indexOf("".concat(this.moderator.getFocusUserJid(), "/")), n.isHiddenDomain = u && u.indexOf("@") > 0 && this.options.hiddenDomain === u.substring(u.indexOf("@") + 1, u.indexOf("/")), this.eventEmitter.emit(d.a.PRESENCE_RECEIVED, {
                            fromHiddenDomain: n.isHiddenDomain,
                            presence: e
                        });
                        var l = e.querySelector("x");
                        l && l.remove();
                        var p = [];
                        _.packet2JSON(e, p), this.lastPresences[t] = p;
                        for (var h = function(e) {
                                var t = {},
                                    n = e.children.find((function(e) {
                                        return "user" === e.tagName
                                    }));
                                if (n) {
                                    t.user = {};
                                    for (var r = ["id", "name", "avatar"], i = function() {
                                            var e = r[o],
                                                i = n.children.find((function(t) {
                                                    return t.tagName === e
                                                }));
                                            i && (t.user[e] = i.value)
                                        }, o = 0; o < r.length; o++) i()
                                }
                                var a = e.children.find((function(e) {
                                    return "group" === e.tagName
                                }));
                                return a && (t.group = a.value), t
                            }, f = 0; f < p.length; f++) {
                            var m = p[f];
                            switch (m.tagName) {
                                case "bot":
                                    var v = m.attributes;
                                    if (!v) break;
                                    var y = v.type;
                                    n.botType = y;
                                    break;
                                case "nick":
                                    n.nick = m.value;
                                    break;
                                case "userId":
                                    n.id = m.value;
                                    break;
                                case "stats-id":
                                    n.statsID = m.value;
                                    break;
                                case "identity":
                                    n.identity = h(m);
                                    break;
                                case "stat":
                                    var S = m.attributes;
                                    if (!S) break;
                                    "version" === S.name && (n.version = S.value)
                            }
                        }
                        if (t === this.myroomjid) {
                            var b = "owner" === n.affiliation ? n.role : "none";
                            if (this.role !== b && (this.role = b, this.eventEmitter.emit(d.a.LOCAL_ROLE_CHANGED, this.role)), !this.joined) {
                                this.joined = !0;
                                var E = this.connectionTimes["muc.joined"] = window.performance.now();
                                g.log("(TIME) MUC joined:\t", E), this.password && (this.locked = !0), this.sendPresence(), this.eventEmitter.emit(d.a.MUC_JOINED)
                            }
                        } else if (void 0 === u) g.info("Ignoring member with undefined JID");
                        else if (void 0 === this.members[t]) this.members[t] = n, g.log("entered", t, n), o = void 0 !== n.status, a = void 0 !== n.version, n.isFocus ? this._initFocus(t, u) : (this.eventEmitter.emit(d.a.MUC_MEMBER_JOINED, t, n.nick, n.role, n.isHiddenDomain, n.statsID, n.status, n.identity, n.botType), o = !1);
                        else {
                            var T = this.members[t];
                            T.role !== n.role && (T.role = n.role, this.eventEmitter.emit(d.a.MUC_ROLE_CHANGED, t, n.role)), T.botType !== n.botType && (T.botType = n.botType, this.eventEmitter.emit(d.a.MUC_MEMBER_BOT_TYPE_CHANGED, t, n.botType)), n.isFocus && (T.isFocus = !0, this._initFocus(t, u)), n.displayName && (T.displayName = n.displayName), T.status !== n.status && (o = !0, T.status = n.status), T.version !== n.version && (a = !0, T.version = n.version)
                        }
                        for (var C = 0; C < p.length; C++) {
                            var R = p[C];
                            switch (R.tagName) {
                                case "nick":
                                    if (!n.isFocus) {
                                        var A = this.xmpp.options.displayJids ? i.Strophe.getResourceFromJid(t) : n.nick;
                                        this.eventEmitter.emit(d.a.DISPLAY_NAME_CHANGED, t, A)
                                    }
                                    break;
                                case "bridgeNotAvailable":
                                    n.isFocus && !this.noBridgeAvailable && (this.noBridgeAvailable = !0, this.eventEmitter.emit(d.a.BRIDGE_DOWN));
                                    break;
                                case "conference-properties":
                                    if (n.isFocus) {
                                        for (var w = {}, k = 0; k < R.children.length; k++) {
                                            var O = R.children[k].attributes;
                                            O && O.key && (w[O.key] = O.value)
                                        }
                                        this.eventEmitter.emit(d.a.CONFERENCE_PROPERTIES_CHANGED, w)
                                    }
                                    break;
                                case "transcription-status":
                                    var I = R.attributes;
                                    if (!I) break;
                                    var P = I.status;
                                    P && P !== this.transcriptionStatus && (this.transcriptionStatus = P, this.eventEmitter.emit(d.a.TRANSCRIPTION_STATUS_CHANGED, P));
                                    break;
                                case "call-control":
                                    var D = R.attributes;
                                    if (!D) break;
                                    this.phoneNumber = D.phone || null, this.phonePin = D.pin || null, this.eventEmitter.emit(d.a.PHONE_NUMBER_CHANGED);
                                    break;
                                default:
                                    this.processNode(R, t)
                            }
                        }
                        o && this.eventEmitter.emit(d.a.PRESENCE_STATUS, t, n.status), a && g.info("Received version for ".concat(u, ": ").concat(n.version))
                    }
                }, {
                    key: "_initFocus",
                    value: function(e, t) {
                        this.focusMucJid = e, g.info("Ignore focus: ".concat(e, ", real JID: ").concat(t))
                    }
                }, {
                    key: "setParticipantPropertyListener",
                    value: function(e) {
                        this.participantPropertyListener = e
                    }
                }, {
                    key: "processNode",
                    value: function(e, t) {
                        try {
                            var n = this.presHandlers[e.tagName];
                            e.tagName.startsWith("jitsi_participant_") && (n = [this.participantPropertyListener]), n && n.forEach((function(n) {
                                n(e, i.Strophe.getResourceFromJid(t), t)
                            }))
                        } catch (t) {
                            a.a.callErrorHandler(t), g.error("Error processing:".concat(e.tagName, " node."), t)
                        }
                    }
                }, {
                    key: "sendMessage",
                    value: function(e, t, n) {
                        var r = Object(i.$msg)({
                            to: this.roomjid,
                            type: "groupchat"
                        });
                        "body" === t ? r.c(t, e).up() : r.c(t, {
                            xmlns: "http://jitsi.org/jitmeet"
                        }, e).up(), n && r.c("nick", {
                            xmlns: "http://jabber.org/protocol/nick"
                        }).t(n).up().up(), this.connection.send(r), this.eventEmitter.emit(d.a.SENDING_CHAT_MESSAGE, e)
                    }
                }, {
                    key: "sendOfText",          // BAO
                    value: function(t) {
                        var n = Object(i.$msg)({
                            to: this.roomjid,
                            type: "groupchat"
                        });
                        n.c("body").t(t);
                        this.connection.send(n);
                    }
                }, {
                    key: "sendOfMeet",          // BAO
                    value: function(t) {
                        var n = Object(i.$msg)({
                            to: this.roomjid,
                            type: "groupchat"
                        });
                        n.c("ofmeet", {xmlns: "jabber:x:ofmeet"}).t(t);
                        this.connection.send(n);
                    }
                }, {
                    key: "sendOfMessage",          // BAO
                    value: function(e, t) {
                        var n = Object(i.$msg)({
                            to: e
                        });
                        n.c("ofmeet", {xmlns: "jabber:x:ofmeet"}).t(t);
                        this.connection.send(n);
                    }
                }, {
                    key: "sendOfUpload",          // BAO
                    value: function(file, callback, errorCallback) {
                        var iq = Object(i.$iq)({
                                type: "get",
                                to: "httpfileupload." + this.connection.domain
                            }).c("request", {
                                xmlns: "urn:xmpp:http:upload"
                            }).c('filename').t(file.name).up().c('size').t(file.size);

                        this.connection.sendIQ(iq, callback, errorCallback)
                    }
                }, {
                    key: "sendPrivateMessage",
                    value: function(e, t, n, r) {
                        var o = Object(i.$msg)({
                            to: "".concat(this.roomjid, "/").concat(e),
                            type: "chat"
                        });
                        "body" === n ? o.c(n, t).up() : o.c(n, {
                            xmlns: "http://jitsi.org/jitmeet"
                        }, t).up(), r && o.c("nick", {
                            xmlns: "http://jabber.org/protocol/nick"
                        }).t(r).up().up(), this.connection.send(o), this.eventEmitter.emit(d.a.SENDING_PRIVATE_CHAT_MESSAGE, t)
                    }
                }, {
                    key: "setSubject",
                    value: function(e) {
                        var t = Object(i.$msg)({
                            to: this.roomjid,
                            type: "groupchat"
                        });
                        t.c("subject", e), this.connection.send(t)
                    }
                }, {
                    key: "onParticipantLeft",
                    value: function(e, t) {
                        delete this.lastPresences[e], t || (this.eventEmitter.emit(d.a.MUC_MEMBER_LEFT, e), this.moderator.onMucMemberLeft(e))
                    }
                }, {
                    key: "onPresenceUnavailable",
                    value: function(e, t) {
                        var n = this;
                        if ($(e).find('>ignore[xmlns="http://jitsi.org/jitmeet/"]').length) return !0;
                        if ($(e).find('>x[xmlns="http://jabber.org/protocol/muc#user"]>destroy').length) {
                            var r, o = $(e).find('>x[xmlns="http://jabber.org/protocol/muc#user"]>destroy>reason');
                            return o.length && (r = o.text()), this.eventEmitter.emit(d.a.MUC_DESTROYED, r), this.connection.emuc.doLeave(this.roomjid), !0
                        }
                        var a = $(e).find('>x[xmlns="http://jabber.org/protocol/muc#user"]>status[code="110"]').length,
                            s = $(e).find('>x[xmlns="http://jabber.org/protocol/muc#user"]>status[code="307"]').length,
                            c = Object.keys(this.members);
                        if (s) {
                            var u, l = $(e).find('>x[xmlns="http://jabber.org/protocol/muc#user"]>item>actor');
                            l.length && (u = l.attr("nick")), c.find((function(e) {
                                return i.Strophe.getResourceFromJid(e) === u
                            })) && this.eventEmitter.emit(d.a.KICKED, a, u, i.Strophe.getResourceFromJid(t))
                        }
                        a ? c.length > 0 && (c.forEach((function(e) {
                            var t = n.members[e];
                            delete n.members[e], n.onParticipantLeft(e, t.isFocus)
                        })), this.connection.emuc.doLeave(this.roomjid), s || this.eventEmitter.emit(d.a.MUC_LEFT)) : (delete this.members[t], this.onParticipantLeft(t, !1))
                    }
                }, {
                    key: "onMessage",
                    value: function(e, t) {
                        var n = $(e).find('>nick[xmlns="http://jabber.org/protocol/nick"]').text() || i.Strophe.getResourceFromJid(t),
                            r = e.getAttribute("type");
                        if ("error" === r) {
                            var o = $(e).find(">error>text").text();
                            return this.eventEmitter.emit(d.a.CHAT_ERROR_RECEIVED, o), !0
                        }
                        var a = $(e).find(">body").text(),
                            s = $(e).find(">subject");
                        if (s.length) {
                            var c = s.text();
                            (c || "" === c) && (this.eventEmitter.emit(d.a.SUBJECT_CHANGED, c), g.log("Subject is changed to ".concat(c)))
                        }
                        var u = $(e).find(">delay").attr("stamp");
                        if (!u && (u = $(e).find('>[xmlns="jabber:x:delay"]').attr("stamp"))) {
                            var l = u.match(/(\d{4})(\d{2})(\d{2}T\d{2}:\d{2}:\d{2})/);
                            u = "".concat(l[1], "-").concat(l[2], "-").concat(l[3], "Z")
                        }
                        t === this.roomjid && $(e).find('>x[xmlns="http://jabber.org/protocol/muc#user"]>status[code="104"]').length && this.discoRoomInfo();
                        var p = $(e).find(">json-message").text(),
                            h = this.xmpp.tryParseJSONAndVerify(p);
                        h && void 0 === u ? this.eventEmitter.emit(d.a.JSON_MESSAGE_RECEIVED, t, h) : a && ("chat" === r ? this.eventEmitter.emit(d.a.PRIVATE_MESSAGE_RECEIVED, t, n, a, this.myroomjid, u) : "groupchat" === r && this.eventEmitter.emit(d.a.MESSAGE_RECEIVED, t, n, a, this.myroomjid, u))
                    }
                }, {
                    key: "onPresenceError",
                    value: function(e, t) {
                        $(e).find('>error[type="auth"]>not-authorized[xmlns="urn:ietf:params:xml:ns:xmpp-stanzas"]').length ? (g.log("on password required", t), this.eventEmitter.emit(d.a.PASSWORD_REQUIRED)) : $(e).find('>error[type="cancel"]>not-allowed[xmlns="urn:ietf:params:xml:ns:xmpp-stanzas"]').length ? i.Strophe.getDomainFromJid(e.getAttribute("to")) === this.xmpp.options.hosts.anonymousdomain ? this.eventEmitter.emit(d.a.ROOM_JOIN_ERROR) : (g.warn("onPresError ", e), this.eventEmitter.emit(d.a.ROOM_CONNECT_NOT_ALLOWED_ERROR)) : $(e).find(">error>service-unavailable").length ? (g.warn("Maximum users limit for the room has been reached", e), this.eventEmitter.emit(d.a.ROOM_MAX_USERS_ERROR)) : (g.warn("onPresError ", e), this.eventEmitter.emit(d.a.ROOM_CONNECT_ERROR))
                    }
                }, {
                    key: "kick",
                    value: function(e) {
                        var t = Object(i.$iq)({
                            to: this.roomjid,
                            type: "set"
                        }).c("query", {
                            xmlns: "http://jabber.org/protocol/muc#admin"
                        }).c("item", {
                            nick: i.Strophe.getResourceFromJid(e),
                            role: "none"
                        }).c("reason").t("You have been kicked.").up().up().up();
                        this.connection.sendIQ(t, (function(t) {
                            return g.log("Kick participant with jid: ", e, t)
                        }), (function(e) {
                            return g.log("Kick participant error: ", e)
                        }))
                    }
                }, {
                    key: "lockRoom",
                    value: function(e, t, n, r) {
                        var o = this;
                        this.connection.sendIQ(Object(i.$iq)({
                            to: this.roomjid,
                            type: "get"
                        }).c("query", {
                            xmlns: "http://jabber.org/protocol/muc#owner"
                        }), (function(a) {
                            if ($(a).find('>query>x[xmlns="jabber:x:data"]>field[var="muc#roomconfig_roomsecret"]').length) {
                                var s = Object(i.$iq)({
                                    to: o.roomjid,
                                    type: "set"
                                }).c("query", {
                                    xmlns: "http://jabber.org/protocol/muc#owner"
                                });
                                s.c("x", {
                                    xmlns: "jabber:x:data",
                                    type: "submit"
                                }), s.c("field", {
                                    var: "FORM_TYPE"
                                }).c("value").t("http://jabber.org/protocol/muc#roomconfig").up().up(), s.c("field", {
                                    var: "muc#roomconfig_roomsecret"
                                }).c("value").t(e).up().up(), s.c("field", {
                                    var: "muc#roomconfig_whois"
                                }).c("value").t("anyone").up().up(), o.connection.sendIQ(s, t, n)
                            } else r()
                        }), n)
                    }
                }, {
                    key: "addToPresence",
                    value: function(e, t) {
                        t.tagName = e, this.removeFromPresence(e), this.presMap.nodes.push(t)
                    }
                }, {
                    key: "getFromPresence",
                    value: function(e) {
                        return this.presMap.nodes.find((function(t) {
                            return e === t.tagName
                        }))
                    }
                }, {
                    key: "removeFromPresence",
                    value: function(e) {
                        var t = this.presMap.nodes.filter((function(t) {
                            return e !== t.tagName
                        }));
                        this.presMap.nodes = t
                    }
                }, {
                    key: "addPresenceListener",
                    value: function(e, t) {
                        if ("function" != typeof t) throw new Error('"handler" is not a function');
                        var n = this.presHandlers[e];
                        n || (this.presHandlers[e] = n = []), -1 === n.indexOf(t) ? n.push(t) : g.warn("Trying to add the same handler more than once for: ".concat(e))
                    }
                }, {
                    key: "removePresenceListener",
                    value: function(e, t) {
                        var n = this.presHandlers[e],
                            r = n ? n.indexOf(t) : -1; - 1 !== r ? n.splice(r, 1) : g.warn("Handler for: ".concat(e, " was not registered"))
                    }
                }, {
                    key: "isFocus",
                    value: function(e) {
                        var t = this.members[e];
                        return t ? t.isFocus : null
                    }
                }, {
                    key: "isModerator",
                    value: function() {
                        return "moderator" === this.role
                    }
                }, {
                    key: "getMemberRole",
                    value: function(e) {
                        return this.members[e] ? this.members[e].role : null
                    }
                }, {
                    key: "setVideoMute",
                    value: function(e, t) {
                        this.sendVideoInfoPresence(e), t && t(e)
                    }
                }, {
                    key: "setAudioMute",
                    value: function(e, t) {
                        return this.sendAudioInfoPresence(e, t)
                    }
                }, {
                    key: "addAudioInfoToPresence",
                    value: function(e) {
                        this.removeFromPresence("audiomuted"), this.addToPresence("audiomuted", {
                            attributes: {
                                xmlns: "http://jitsi.org/jitmeet/audio"
                            },
                            value: e.toString()
                        })
                    }
                }, {
                    key: "sendAudioInfoPresence",
                    value: function(e, t) {
                        this.addAudioInfoToPresence(e), this.connection && this.sendPresence(), t && t()
                    }
                }, {
                    key: "addVideoInfoToPresence",
                    value: function(e) {
                        this.removeFromPresence("videomuted"), this.addToPresence("videomuted", {
                            attributes: {
                                xmlns: "http://jitsi.org/jitmeet/video"
                            },
                            value: e.toString()
                        })
                    }
                }, {
                    key: "sendVideoInfoPresence",
                    value: function(e) {
                        this.addVideoInfoToPresence(e), this.connection && this.sendPresence()
                    }
                }, {
                    key: "getMediaPresenceInfo",
                    value: function(e, t) {
                        var n = this.lastPresences["".concat(this.roomjid, "/").concat(e)];
                        if (!n) return null;
                        var r = {
                                muted: !1,
                                videoType: void 0
                            },
                            i = null;
                        if (t === u.a) i = S(n, "audiomuted");
                        else {
                            if (t !== u.b) return g.error("Unsupported media type: ".concat(t)), null;
                            i = S(n, "videomuted");
                            var o = S(n, "videoType");
                            o.length > 0 && (r.videoType = o[0].value)
                        }
                        return r.muted = i.length > 0 && "true" === i[0].value, r
                    }
                }, {
                    key: "isSIPCallingSupported",
                    value: function() {
                        return !!this.moderator && this.moderator.isSipGatewayEnabled()
                    }
                }, {
                    key: "dial",
                    value: function(e) {
                        return this.connection.rayo.dial(e, "fromnumber", i.Strophe.getBareJidFromJid(this.myroomjid), this.password, this.focusMucJid)
                    }
                }, {
                    key: "hangup",
                    value: function() {
                        return this.connection.rayo.hangup()
                    }
                }, {
                    key: "getPhoneNumber",
                    value: function() {
                        return this.phoneNumber
                    }
                }, {
                    key: "getPhonePin",
                    value: function() {
                        return this.phonePin
                    }
                }, {
                    key: "muteParticipant",
                    value: function(e, t) {
                        g.info("set mute", t);
                        var n = Object(i.$iq)({
                            to: this.focusMucJid,
                            type: "set"
                        }).c("mute", {
                            xmlns: "http://jitsi.org/jitmeet/audio",
                            jid: e
                        }).t(t.toString()).up();
                        this.connection.sendIQ(n, (function(e) {
                            return g.log("set mute", e)
                        }), (function(e) {
                            return g.log("set mute error", e)
                        }))
                    }
                }, {
                    key: "onMute",
                    value: function(e) {
                        if (e.getAttribute("from") === this.focusMucJid) {
                            var t = $(e).find("mute");
                            t.length && "true" === t.text() ? this.eventEmitter.emit(d.a.AUDIO_MUTED_BY_FOCUS, t.attr("actor")) : g.warn("Ignoring a mute request which does not explicitly specify a positive mute command.")
                        } else g.warn("Ignored mute from non focus peer")
                    }
                }, {
                    key: "leave",
                    value: function() {
                        var e = this;
                        return new Promise((function(t, n) {
                            var r = setTimeout((function() {
                                    return o(!0)
                                }), 5e3),
                                i = e.eventEmitter;

                            function o() {
                                var e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
                                i.removeListener(d.a.MUC_LEFT, o), clearTimeout(r), e ? n(new Error("The timeout for the confirmation about leaving the room expired.")) : t()
                            }
                            i.on(d.a.MUC_LEFT, o), e.doLeave()
                        }))
                    }
                }]) && f(n.prototype, r), o && f(n, o), t
            }(c.a)
        }).call(this, "modules/xmpp/ChatRoom.js")
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return d
            }));
            var r = n(1),
                i = n(3),
                o = n(32),
                a = n(4).getLogger(e),
                s = n(0),
                c = n(56),
                u = n(11);

            function l(e) {
                var t = 1;
                return function(n) {
                    if (!n) {
                        var r = Math.pow(2, t - 1);
                        return t += 1, r * e
                    }
                    t = 1
                }
            }

            function d(e, t, n, r) {
                function i(e) {
                    if (e.data && e.data.sessionId) {
                        if (e.origin !== window.location.origin) return void a.warn("Ignoring sessionId from different origin: ".concat(e.origin));
                        o.a.sessionId = e.data.sessionId
                    }
                }
                this.roomName = e, this.xmppService = t, this.getNextTimeout = l(1e3), this.getNextErrorTimeout = l(1e3), this.externalAuthEnabled = !1, this.options = r, this.sipGatewayEnabled = this.options.connection.hosts && void 0 !== this.options.connection.hosts.call_control, this.eventEmitter = n, this.connection = this.xmppService.connection, window.addEventListener ? window.addEventListener("message", i, !1) : window.attachEvent("onmessage", i)
            }
            d.prototype.isExternalAuthEnabled = function() {
                return this.externalAuthEnabled
            }, d.prototype.isSipGatewayEnabled = function() {
                return this.sipGatewayEnabled
            }, d.prototype.onMucMemberLeft = function(e) {
                a.info("Someone left is it focus ? ".concat(e)), "focus" === r.Strophe.getResourceFromJid(e) && (a.info("Focus has left the room - leaving conference"), this.eventEmitter.emit(s.FOCUS_LEFT))
            }, d.prototype.setFocusUserJid = function(e) {
                this.focusUserJid || (this.focusUserJid = e, a.info("Focus jid set to:  ".concat(this.focusUserJid)))
            }, d.prototype.getFocusUserJid = function() {
                return this.focusUserJid
            }, d.prototype.getFocusComponent = function() {
                var e = this.options.connection.hosts.focus;
                return e || (e = "focus.".concat(this.options.connection.hosts.domain)), e
            }, d.prototype.createConferenceIq = function() {
                var e, t = Object(r.$iq)({
                        to: this.getFocusComponent(),
                        type: "set"
                    }),
                    n = o.a.sessionId,
                    s = o.a.machineId,
                    c = this.options.conference;
                switch (a.info("Session ID: ".concat(n, " machine UID: ").concat(s)), t.c("conference", {
                    xmlns: "http://jitsi.org/protocol/focus",
                    room: this.roomName,
                    "machine-uid": s
                }), n && t.attrs({
                    "session-id": n
                }), void 0 !== this.options.connection.enforcedBridge && t.c("property", {
                    name: "enforcedBridge",
                    value: this.options.connection.enforcedBridge
                }).up(), void 0 !== this.options.connection.hosts && void 0 !== this.options.connection.hosts.call_control && t.c("property", {
                    name: "call_control",
                    value: this.options.connection.hosts.call_control
                }).up(), void 0 !== c.channelLastN && t.c("property", {
                    name: "channelLastN",
                    value: c.channelLastN
                }).up(), t.c("property", {
                    name: "disableRtx",
                    value: Boolean(c.disableRtx)
                }).up(), void 0 !== c.enableTcc && t.c("property", {
                    name: "enableTcc",
                    value: Boolean(c.enableTcc)
                }).up(), void 0 !== c.enableRemb && t.c("property", {
                    name: "enableRemb",
                    value: Boolean(c.enableRemb)
                }).up(), void 0 !== c.minParticipants && t.c("property", {
                    name: "minParticipants",
                    value: c.minParticipants
                }).up(), t.c("property", {
                    name: "enableLipSync",
                    value: !1 !== this.options.connection.enableLipSync
                }).up(), void 0 !== c.audioPacketDelay && t.c("property", {
                    name: "audioPacketDelay",
                    value: c.audioPacketDelay
                }).up(), c.startBitrate && t.c("property", {
                    name: "startBitrate",
                    value: c.startBitrate
                }).up(), c.minBitrate && t.c("property", {
                    name: "minBitrate",
                    value: c.minBitrate
                }).up(), c.testing && c.testing.octo && "number" == typeof c.testing.octo.probability && Math.random() < c.testing.octo.probability && t.c("property", {
                    name: "octo",
                    value: !0
                }).up(), this.options.conference.openBridgeChannel) {
                    case "datachannel":
                    case !0:
                    case void 0:
                        e = !0;
                        break;
                    case "websocket":
                        e = !1
                }
                return e && !i.a.supportsDataChannels() && (e = !1), t.c("property", {
                    name: "openSctp",
                    value: e
                }).up(), void 0 !== this.options.conference.startAudioMuted && t.c("property", {
                    name: "startAudioMuted",
                    value: this.options.conference.startAudioMuted
                }).up(), void 0 !== this.options.conference.startVideoMuted && t.c("property", {
                    name: "startVideoMuted",
                    value: this.options.conference.startVideoMuted
                }).up(), void 0 !== this.options.conference.stereo && t.c("property", {
                    name: "stereo",
                    value: this.options.conference.stereo
                }).up(), void 0 !== this.options.conference.useRoomAsSharedDocumentName && t.c("property", {
                    name: "useRoomAsSharedDocumentName",
                    value: this.options.conference.useRoomAsSharedDocumentName
                }).up(), t.up(), t
            }, d.prototype.parseSessionId = function(e) {
                var t = $(e).find("conference").attr("session-id");
                t && (a.info("Received sessionId:  ".concat(t)), o.a.sessionId = t)
            }, d.prototype.parseConfigOptions = function(e) {
                this.setFocusUserJid($(e).find("conference").attr("focusjid"));
                var t = $(e).find(">conference>property[name='authentication'][value='true']").length > 0;
                a.info("Authentication enabled: ".concat(t)), this.externalAuthEnabled = $(e).find(">conference>property[name='externalAuth'][value='true']").length > 0, a.info("External authentication enabled: ".concat(this.externalAuthEnabled)), this.externalAuthEnabled || this.parseSessionId(e);
                var n = $(e).find(">conference").attr("identity");
                this.eventEmitter.emit(c.IDENTITY_UPDATED, t, n), $(e).find(">conference>property[name='sipGatewayEnabled'][value='true']").length && (this.sipGatewayEnabled = !0), a.info("Sip gateway enabled:  ".concat(this.sipGatewayEnabled))
            }, d.prototype.allocateConferenceFocus = function() {
                var e = this;
                return new Promise((function(t) {
                    e.setFocusUserJid(e.options.connection.focusUserJid), e.connection.sendIQ(e.createConferenceIq(), (function(n) {
                        return e._allocateConferenceFocusSuccess(n, t)
                    }), (function(n) {
                        return e._allocateConferenceFocusError(n, t)
                    })), e.connection.flush()
                }))
            }, d.prototype._allocateConferenceFocusError = function(e, t) {
                var n = this,
                    i = $(e).find(">error>session-invalid").length || $(e).find(">error>not-acceptable").length;
                if (i && (a.info("Session expired! - removing"), o.a.sessionId = void 0), $(e).find(">error>graceful-shutdown").length) this.eventEmitter.emit(s.GRACEFUL_SHUTDOWN);
                else {
                    var c = $(e).find(">error>reservation-error");
                    if (c.length) {
                        var l, d = c.attr("error-code"),
                            p = $(e).find(">error>text");
                        return p && (l = p.text()), void this.eventEmitter.emit(s.RESERVATION_ERROR, d, l)
                    }
                    if ($(e).find(">error>not-authorized").length) return a.warn("Unauthorized to start the conference", e), r.Strophe.getDomainFromJid(e.getAttribute("to")) !== this.options.connection.hosts.anonymousdomain && (this.externalAuthEnabled = !0), void this.eventEmitter.emit(s.AUTHENTICATION_REQUIRED);
                    var h = this.getNextErrorTimeout(),
                        f = "Focus error, retry after ".concat(h);
                    u.callErrorHandler(new Error(f)), a.error(f, e);
                    var m = this.getFocusComponent(),
                        v = h / 1e3;
                    i || this.eventEmitter.emit(s.FOCUS_DISCONNECTED, m, v), this.getNextTimeout(!0), window.setTimeout((function() {
                        return n.allocateConferenceFocus().then(t)
                    }), h)
                }
            }, d.prototype._allocateConferenceFocusSuccess = function(e, t) {
                var n = this;
                if (this.parseConfigOptions(e), this.getNextErrorTimeout(!0), "true" === $(e).find("conference").attr("ready")) this.getNextTimeout(!0), t();
                else {
                    var r = this.getNextTimeout();
                    a.info("Waiting for the focus... ".concat(r)), window.setTimeout((function() {
                        return n.allocateConferenceFocus().then(t)
                    }), r)
                }
            }, d.prototype.authenticate = function() {
                var e = this;
                return new Promise((function(t, n) {
                    e.connection.sendIQ(e.createConferenceIq(), (function(n) {
                        e.parseSessionId(n), t()
                    }), (function(e) {
                        return n({
                            error: $(e).find("iq>error :first").prop("tagName"),
                            message: $(e).find("iq>error>text").text()
                        })
                    }))
                }))
            }, d.prototype.getLoginUrl = function(e, t) {
                this._getLoginUrl(!1, e, t)
            }, d.prototype._getLoginUrl = function(e, t, n) {
                var i = Object(r.$iq)({
                        to: this.getFocusComponent(),
                        type: "get"
                    }),
                    s = {
                        xmlns: "http://jitsi.org/protocol/focus",
                        room: this.roomName,
                        "machine-uid": o.a.machineId
                    },
                    c = "auth url";

                function l(e, t) {
                    u.callErrorHandler(new Error(e)), a.error(e, t), n(t)
                }
                e && (s.popup = !0, c = "POPUP ".concat(c)), i.c("login-url", s), this.connection.sendIQ(i, (function(e) {
                    var n = $(e).find("login-url").attr("url");
                    (n = decodeURIComponent(n)) ? (a.info("Got ".concat(c, ": ").concat(n)), t(n)) : l("Failed to get ".concat(c, " from the focus"), e)
                }), l.bind(void 0, "Get ".concat(c, " error")))
            }, d.prototype.getPopupLoginUrl = function(e, t) {
                this._getLoginUrl(!0, e, t)
            }, d.prototype.logout = function(e) {
                var t = Object(r.$iq)({
                        to: this.getFocusComponent(),
                        type: "set"
                    }),
                    n = o.a.sessionId;
                n ? (t.c("logout", {
                    xmlns: "http://jitsi.org/protocol/focus",
                    "session-id": n
                }), this.connection.sendIQ(t, (function(t) {
                    var n = $(t).find("logout").attr("logout-url");
                    n && (n = decodeURIComponent(n)), a.info("Log out OK, url: ".concat(n), t), o.a.sessionId = void 0, e(n)
                }), (function(e) {
                    u.callErrorHandler(new Error("Logout error")), a.error("Logout error", e)
                }))) : e()
            }
        }).call(this, "modules/xmpp/moderator.js")
    }, function(e, t, n) {
        var r = n(33),
            i = ["Aaliyah", "Aaron", "Abagail", "Abbey", "Abbie", "Abbigail", "Abby", "Abdiel", "Abdul", "Abdullah", "Abe", "Abel", "Abelardo", "Abigail", "Abigale", "Abigayle", "Abner", "Abraham", "Ada", "Adah", "Adalberto", "Adaline", "Adam", "Adan", "Addie", "Addison", "Adela", "Adelbert", "Adele", "Adelia", "Adeline", "Adell", "Adella", "Adelle", "Aditya", "Adolf", "Adolfo", "Adolph", "Adolphus", "Adonis", "Adrain", "Adrian", "Adriana", "Adrianna", "Adriel", "Adrien", "Adrienne", "Afton", "Aglae", "Agnes", "Agustin", "Agustina", "Ahmad", "Ahmed", "Aida", "Aidan", "Aiden", "Aileen", "Aisha", "Aiyana", "Akeem", "Al", "Alaina", "Alan", "Alana", "Alanis", "Alanna", "Alayna", "Alba", "Albert", "Alberta", "Albertha", "Alberto", "Albin", "Albina", "Alda", "Alden", "Alec", "Aleen", "Alejandra", "Alejandrin", "Alek", "Alena", "Alene", "Alessandra", "Alessandro", "Alessia", "Aletha", "Alex", "Alexa", "Alexander", "Alexandra", "Alexandre", "Alexandrea", "Alexandria", "Alexandrine", "Alexandro", "Alexane", "Alexanne", "Alexie", "Alexis", "Alexys", "Alexzander", "Alf", "Alfonso", "Alfonzo", "Alford", "Alfred", "Alfreda", "Alfredo", "Ali", "Alia", "Alice", "Alicia", "Alisa", "Alisha", "Alison", "Alivia", "Aliya", "Aliyah", "Aliza", "Alize", "Allan", "Allen", "Allene", "Allie", "Allison", "Ally", "Alphonso", "Alta", "Althea", "Alva", "Alvah", "Alvena", "Alvera", "Alverta", "Alvina", "Alvis", "Alyce", "Alycia", "Alysa", "Alysha", "Alyson", "Alysson", "Amalia", "Amanda", "Amani", "Amara", "Amari", "Amaya", "Amber", "Ambrose", "Amelia", "Amelie", "Amely", "America", "Americo", "Amie", "Amina", "Amir", "Amira", "Amiya", "Amos", "Amparo", "Amy", "Amya", "Ana", "Anabel", "Anabelle", "Anahi", "Anais", "Anastacio", "Anastasia", "Anderson", "Andre", "Andreane", "Andreanne", "Andres", "Andrew", "Andy", "Angel", "Angela", "Angelica", "Angelina", "Angeline", "Angelita", "Angelo", "Angie", "Angus", "Anibal", "Anika", "Anissa", "Anita", "Aniya", "Aniyah", "Anjali", "Anna", "Annabel", "Annabell", "Annabelle", "Annalise", "Annamae", "Annamarie", "Anne", "Annetta", "Annette", "Annie", "Ansel", "Ansley", "Anthony", "Antoinette", "Antone", "Antonetta", "Antonette", "Antonia", "Antonietta", "Antonina", "Antonio", "Antwan", "Antwon", "Anya", "April", "Ara", "Araceli", "Aracely", "Arch", "Archibald", "Ardella", "Arden", "Ardith", "Arely", "Ari", "Ariane", "Arianna", "Aric", "Ariel", "Arielle", "Arjun", "Arlene", "Arlie", "Arlo", "Armand", "Armando", "Armani", "Arnaldo", "Arne", "Arno", "Arnold", "Arnoldo", "Arnulfo", "Aron", "Art", "Arthur", "Arturo", "Arvel", "Arvid", "Arvilla", "Aryanna", "Asa", "Asha", "Ashlee", "Ashleigh", "Ashley", "Ashly", "Ashlynn", "Ashton", "Ashtyn", "Asia", "Assunta", "Astrid", "Athena", "Aubree", "Aubrey", "Audie", "Audra", "Audreanne", "Audrey", "August", "Augusta", "Augustine", "Augustus", "Aurelia", "Aurelie", "Aurelio", "Aurore", "Austen", "Austin", "Austyn", "Autumn", "Ava", "Avery", "Avis", "Axel", "Ayana", "Ayden", "Ayla", "Aylin", "Baby", "Bailee", "Bailey", "Barbara", "Barney", "Baron", "Barrett", "Barry", "Bart", "Bartholome", "Barton", "Baylee", "Beatrice", "Beau", "Beaulah", "Bell", "Bella", "Belle", "Ben", "Benedict", "Benjamin", "Bennett", "Bennie", "Benny", "Benton", "Berenice", "Bernadette", "Bernadine", "Bernard", "Bernardo", "Berneice", "Bernhard", "Bernice", "Bernie", "Berniece", "Bernita", "Berry", "Bert", "Berta", "Bertha", "Bertram", "Bertrand", "Beryl", "Bessie", "Beth", "Bethany", "Bethel", "Betsy", "Bette", "Bettie", "Betty", "Bettye", "Beulah", "Beverly", "Bianka", "Bill", "Billie", "Billy", "Birdie", "Blair", "Blaise", "Blake", "Blanca", "Blanche", "Blaze", "Bo", "Bobbie", "Bobby", "Bonita", "Bonnie", "Boris", "Boyd", "Brad", "Braden", "Bradford", "Bradley", "Bradly", "Brady", "Braeden", "Brain", "Brandi", "Brando", "Brandon", "Brandt", "Brandy", "Brandyn", "Brannon", "Branson", "Brant", "Braulio", "Braxton", "Brayan", "Breana", "Breanna", "Breanne", "Brenda", "Brendan", "Brenden", "Brendon", "Brenna", "Brennan", "Brennon", "Brent", "Bret", "Brett", "Bria", "Brian", "Briana", "Brianne", "Brice", "Bridget", "Bridgette", "Bridie", "Brielle", "Brigitte", "Brionna", "Brisa", "Britney", "Brittany", "Brock", "Broderick", "Brody", "Brook", "Brooke", "Brooklyn", "Brooks", "Brown", "Bruce", "Bryana", "Bryce", "Brycen", "Bryon", "Buck", "Bud", "Buddy", "Buford", "Bulah", "Burdette", "Burley", "Burnice", "Buster", "Cade", "Caden", "Caesar", "Caitlyn", "Cale", "Caleb", "Caleigh", "Cali", "Calista", "Callie", "Camden", "Cameron", "Camila", "Camilla", "Camille", "Camren", "Camron", "Camryn", "Camylle", "Candace", "Candelario", "Candice", "Candida", "Candido", "Cara", "Carey", "Carissa", "Carlee", "Carleton", "Carley", "Carli", "Carlie", "Carlo", "Carlos", "Carlotta", "Carmel", "Carmela", "Carmella", "Carmelo", "Carmen", "Carmine", "Carol", "Carolanne", "Carole", "Carolina", "Caroline", "Carolyn", "Carolyne", "Carrie", "Carroll", "Carson", "Carter", "Cary", "Casandra", "Casey", "Casimer", "Casimir", "Casper", "Cassandra", "Cassandre", "Cassidy", "Cassie", "Catalina", "Caterina", "Catharine", "Catherine", "Cathrine", "Cathryn", "Cathy", "Cayla", "Ceasar", "Cecelia", "Cecil", "Cecile", "Cecilia", "Cedrick", "Celestine", "Celestino", "Celia", "Celine", "Cesar", "Chad", "Chadd", "Chadrick", "Chaim", "Chance", "Chandler", "Chanel", "Chanelle", "Charity", "Charlene", "Charles", "Charley", "Charlie", "Charlotte", "Chase", "Chasity", "Chauncey", "Chaya", "Chaz", "Chelsea", "Chelsey", "Chelsie", "Chesley", "Chester", "Chet", "Cheyanne", "Cheyenne", "Chloe", "Chris", "Christ", "Christa", "Christelle", "Christian", "Christiana", "Christina", "Christine", "Christop", "Christophe", "Christopher", "Christy", "Chyna", "Ciara", "Cicero", "Cielo", "Cierra", "Cindy", "Citlalli", "Clair", "Claire", "Clara", "Clarabelle", "Clare", "Clarissa", "Clark", "Claud", "Claude", "Claudia", "Claudie", "Claudine", "Clay", "Clemens", "Clement", "Clementina", "Clementine", "Clemmie", "Cleo", "Cleora", "Cleta", "Cletus", "Cleve", "Cleveland", "Clifford", "Clifton", "Clint", "Clinton", "Clotilde", "Clovis", "Cloyd", "Clyde", "Coby", "Cody", "Colby", "Cole", "Coleman", "Colin", "Colleen", "Collin", "Colt", "Colten", "Colton", "Columbus", "Concepcion", "Conner", "Connie", "Connor", "Conor", "Conrad", "Constance", "Constantin", "Consuelo", "Cooper", "Cora", "Coralie", "Corbin", "Cordelia", "Cordell", "Cordia", "Cordie", "Corene", "Corine", "Cornelius", "Cornell", "Corrine", "Cortez", "Cortney", "Cory", "Coty", "Courtney", "Coy", "Craig", "Crawford", "Creola", "Cristal", "Cristian", "Cristina", "Cristobal", "Cristopher", "Cruz", "Crystal", "Crystel", "Cullen", "Curt", "Curtis", "Cydney", "Cynthia", "Cyril", "Cyrus", "Dagmar", "Dahlia", "Daija", "Daisha", "Daisy", "Dakota", "Dale", "Dallas", "Dallin", "Dalton", "Damaris", "Dameon", "Damian", "Damien", "Damion", "Damon", "Dan", "Dana", "Dandre", "Dane", "D'angelo", "Dangelo", "Danial", "Daniela", "Daniella", "Danielle", "Danika", "Dannie", "Danny", "Dante", "Danyka", "Daphne", "Daphnee", "Daphney", "Darby", "Daren", "Darian", "Dariana", "Darien", "Dario", "Darion", "Darius", "Darlene", "Daron", "Darrel", "Darrell", "Darren", "Darrick", "Darrin", "Darrion", "Darron", "Darryl", "Darwin", "Daryl", "Dashawn", "Dasia", "Dave", "David", "Davin", "Davion", "Davon", "Davonte", "Dawn", "Dawson", "Dax", "Dayana", "Dayna", "Dayne", "Dayton", "Dean", "Deangelo", "Deanna", "Deborah", "Declan", "Dedric", "Dedrick", "Dee", "Deion", "Deja", "Dejah", "Dejon", "Dejuan", "Delaney", "Delbert", "Delfina", "Delia", "Delilah", "Dell", "Della", "Delmer", "Delores", "Delpha", "Delphia", "Delphine", "Delta", "Demarco", "Demarcus", "Demario", "Demetris", "Demetrius", "Demond", "Dena", "Denis", "Dennis", "Deon", "Deondre", "Deontae", "Deonte", "Dereck", "Derek", "Derick", "Deron", "Derrick", "Deshaun", "Deshawn", "Desiree", "Desmond", "Dessie", "Destany", "Destin", "Destinee", "Destiney", "Destini", "Destiny", "Devan", "Devante", "Deven", "Devin", "Devon", "Devonte", "Devyn", "Dewayne", "Dewitt", "Dexter", "Diamond", "Diana", "Dianna", "Diego", "Dillan", "Dillon", "Dimitri", "Dina", "Dino", "Dion", "Dixie", "Dock", "Dolly", "Dolores", "Domenic", "Domenica", "Domenick", "Domenico", "Domingo", "Dominic", "Dominique", "Don", "Donald", "Donato", "Donavon", "Donna", "Donnell", "Donnie", "Donny", "Dora", "Dorcas", "Dorian", "Doris", "Dorothea", "Dorothy", "Dorris", "Dortha", "Dorthy", "Doug", "Douglas", "Dovie", "Doyle", "Drake", "Drew", "Duane", "Dudley", "Dulce", "Duncan", "Durward", "Dustin", "Dusty", "Dwight", "Dylan", "Earl", "Earlene", "Earline", "Earnest", "Earnestine", "Easter", "Easton", "Ebba", "Ebony", "Ed", "Eda", "Edd", "Eddie", "Eden", "Edgar", "Edgardo", "Edison", "Edmond", "Edmund", "Edna", "Eduardo", "Edward", "Edwardo", "Edwin", "Edwina", "Edyth", "Edythe", "Effie", "Efrain", "Efren", "Eileen", "Einar", "Eino", "Eladio", "Elaina", "Elbert", "Elda", "Eldon", "Eldora", "Eldred", "Eldridge", "Eleanora", "Eleanore", "Eleazar", "Electa", "Elena", "Elenor", "Elenora", "Eleonore", "Elfrieda", "Eli", "Elian", "Eliane", "Elias", "Eliezer", "Elijah", "Elinor", "Elinore", "Elisa", "Elisabeth", "Elise", "Eliseo", "Elisha", "Elissa", "Eliza", "Elizabeth", "Ella", "Ellen", "Ellie", "Elliot", "Elliott", "Ellis", "Ellsworth", "Elmer", "Elmira", "Elmo", "Elmore", "Elna", "Elnora", "Elody", "Eloisa", "Eloise", "Elouise", "Eloy", "Elroy", "Elsa", "Else", "Elsie", "Elta", "Elton", "Elva", "Elvera", "Elvie", "Elvis", "Elwin", "Elwyn", "Elyse", "Elyssa", "Elza", "Emanuel", "Emelia", "Emelie", "Emely", "Emerald", "Emerson", "Emery", "Emie", "Emil", "Emile", "Emilia", "Emiliano", "Emilie", "Emilio", "Emily", "Emma", "Emmalee", "Emmanuel", "Emmanuelle", "Emmet", "Emmett", "Emmie", "Emmitt", "Emmy", "Emory", "Ena", "Enid", "Enoch", "Enola", "Enos", "Enrico", "Enrique", "Ephraim", "Era", "Eriberto", "Eric", "Erica", "Erich", "Erick", "Ericka", "Erik", "Erika", "Erin", "Erling", "Erna", "Ernest", "Ernestina", "Ernestine", "Ernesto", "Ernie", "Ervin", "Erwin", "Eryn", "Esmeralda", "Esperanza", "Esta", "Esteban", "Estefania", "Estel", "Estell", "Estella", "Estelle", "Estevan", "Esther", "Estrella", "Etha", "Ethan", "Ethel", "Ethelyn", "Ethyl", "Ettie", "Eudora", "Eugene", "Eugenia", "Eula", "Eulah", "Eulalia", "Euna", "Eunice", "Eusebio", "Eva", "Evalyn", "Evan", "Evangeline", "Evans", "Eve", "Eveline", "Evelyn", "Everardo", "Everett", "Everette", "Evert", "Evie", "Ewald", "Ewell", "Ezekiel", "Ezequiel", "Ezra", "Fabian", "Fabiola", "Fae", "Fannie", "Fanny", "Fatima", "Faustino", "Fausto", "Favian", "Fay", "Faye", "Federico", "Felicia", "Felicita", "Felicity", "Felipa", "Felipe", "Felix", "Felton", "Fermin", "Fern", "Fernando", "Ferne", "Fidel", "Filiberto", "Filomena", "Finn", "Fiona", "Flavie", "Flavio", "Fleta", "Fletcher", "Flo", "Florence", "Florencio", "Florian", "Florida", "Florine", "Flossie", "Floy", "Floyd", "Ford", "Forest", "Forrest", "Foster", "Frances", "Francesca", "Francesco", "Francis", "Francisca", "Francisco", "Franco", "Frank", "Frankie", "Franz", "Fred", "Freda", "Freddie", "Freddy", "Frederic", "Frederick", "Frederik", "Frederique", "Fredrick", "Fredy", "Freeda", "Freeman", "Freida", "Frida", "Frieda", "Friedrich", "Fritz", "Furman", "Gabe", "Gabriel", "Gabriella", "Gabrielle", "Gaetano", "Gage", "Gail", "Gardner", "Garett", "Garfield", "Garland", "Garnet", "Garnett", "Garret", "Garrett", "Garrick", "Garrison", "Garry", "Garth", "Gaston", "Gavin", "Gay", "Gayle", "Gaylord", "Gene", "General", "Genesis", "Genevieve", "Gennaro", "Genoveva", "Geo", "Geoffrey", "George", "Georgette", "Georgiana", "Georgianna", "Geovanni", "Geovanny", "Geovany", "Gerald", "Geraldine", "Gerard", "Gerardo", "Gerda", "Gerhard", "Germaine", "German", "Gerry", "Gerson", "Gertrude", "Gia", "Gianni", "Gideon", "Gilbert", "Gilberto", "Gilda", "Giles", "Gillian", "Gina", "Gino", "Giovani", "Giovanna", "Giovanni", "Giovanny", "Gisselle", "Giuseppe", "Gladyce", "Gladys", "Glen", "Glenda", "Glenna", "Glennie", "Gloria", "Godfrey", "Golda", "Golden", "Gonzalo", "Gordon", "Grace", "Gracie", "Graciela", "Grady", "Graham", "Grant", "Granville", "Grayce", "Grayson", "Green", "Greg", "Gregg", "Gregoria", "Gregorio", "Gregory", "Greta", "Gretchen", "Greyson", "Griffin", "Grover", "Guadalupe", "Gudrun", "Guido", "Guillermo", "Guiseppe", "Gunnar", "Gunner", "Gus", "Gussie", "Gust", "Gustave", "Guy", "Gwen", "Gwendolyn", "Hadley", "Hailee", "Hailey", "Hailie", "Hal", "Haleigh", "Haley", "Halie", "Halle", "Hallie", "Hank", "Hanna", "Hannah", "Hans", "Hardy", "Harley", "Harmon", "Harmony", "Harold", "Harrison", "Harry", "Harvey", "Haskell", "Hassan", "Hassie", "Hattie", "Haven", "Hayden", "Haylee", "Hayley", "Haylie", "Hazel", "Hazle", "Heath", "Heather", "Heaven", "Heber", "Hector", "Heidi", "Helen", "Helena", "Helene", "Helga", "Hellen", "Helmer", "Heloise", "Henderson", "Henri", "Henriette", "Henry", "Herbert", "Herman", "Hermann", "Hermina", "Herminia", "Herminio", "Hershel", "Herta", "Hertha", "Hester", "Hettie", "Hilario", "Hilbert", "Hilda", "Hildegard", "Hillard", "Hillary", "Hilma", "Hilton", "Hipolito", "Hiram", "Hobart", "Holden", "Hollie", "Hollis", "Holly", "Hope", "Horace", "Horacio", "Hortense", "Hosea", "Houston", "Howard", "Howell", "Hoyt", "Hubert", "Hudson", "Hugh", "Hulda", "Humberto", "Hunter", "Hyman", "Ian", "Ibrahim", "Icie", "Ida", "Idell", "Idella", "Ignacio", "Ignatius", "Ike", "Ila", "Ilene", "Iliana", "Ima", "Imani", "Imelda", "Immanuel", "Imogene", "Ines", "Irma", "Irving", "Irwin", "Isaac", "Isabel", "Isabell", "Isabella", "Isabelle", "Isac", "Isadore", "Isai", "Isaiah", "Isaias", "Isidro", "Ismael", "Isobel", "Isom", "Israel", "Issac", "Itzel", "Iva", "Ivah", "Ivory", "Ivy", "Izabella", "Izaiah", "Jabari", "Jace", "Jacey", "Jacinthe", "Jacinto", "Jack", "Jackeline", "Jackie", "Jacklyn", "Jackson", "Jacky", "Jaclyn", "Jacquelyn", "Jacques", "Jacynthe", "Jada", "Jade", "Jaden", "Jadon", "Jadyn", "Jaeden", "Jaida", "Jaiden", "Jailyn", "Jaime", "Jairo", "Jakayla", "Jake", "Jakob", "Jaleel", "Jalen", "Jalon", "Jalyn", "Jamaal", "Jamal", "Jamar", "Jamarcus", "Jamel", "Jameson", "Jamey", "Jamie", "Jamil", "Jamir", "Jamison", "Jammie", "Jan", "Jana", "Janae", "Jane", "Janelle", "Janessa", "Janet", "Janice", "Janick", "Janie", "Janis", "Janiya", "Jannie", "Jany", "Jaquan", "Jaquelin", "Jaqueline", "Jared", "Jaren", "Jarod", "Jaron", "Jarred", "Jarrell", "Jarret", "Jarrett", "Jarrod", "Jarvis", "Jasen", "Jasmin", "Jason", "Jasper", "Jaunita", "Javier", "Javon", "Javonte", "Jay", "Jayce", "Jaycee", "Jayda", "Jayde", "Jayden", "Jaydon", "Jaylan", "Jaylen", "Jaylin", "Jaylon", "Jayme", "Jayne", "Jayson", "Jazlyn", "Jazmin", "Jazmyn", "Jazmyne", "Jean", "Jeanette", "Jeanie", "Jeanne", "Jed", "Jedediah", "Jedidiah", "Jeff", "Jefferey", "Jeffery", "Jeffrey", "Jeffry", "Jena", "Jenifer", "Jennie", "Jennifer", "Jennings", "Jennyfer", "Jensen", "Jerad", "Jerald", "Jeramie", "Jeramy", "Jerel", "Jeremie", "Jeremy", "Jermain", "Jermaine", "Jermey", "Jerod", "Jerome", "Jeromy", "Jerrell", "Jerrod", "Jerrold", "Jerry", "Jess", "Jesse", "Jessica", "Jessie", "Jessika", "Jessy", "Jessyca", "Jesus", "Jett", "Jettie", "Jevon", "Jewel", "Jewell", "Jillian", "Jimmie", "Jimmy", "Jo", "Joan", "Joana", "Joanie", "Joanne", "Joannie", "Joanny", "Joany", "Joaquin", "Jocelyn", "Jodie", "Jody", "Joe", "Joel", "Joelle", "Joesph", "Joey", "Johan", "Johann", "Johanna", "Johathan", "John", "Johnathan", "Johnathon", "Johnnie", "Johnny", "Johnpaul", "Johnson", "Jolie", "Jon", "Jonas", "Jonatan", "Jonathan", "Jonathon", "Jordan", "Jordane", "Jordi", "Jordon", "Jordy", "Jordyn", "Jorge", "Jose", "Josefa", "Josefina", "Joseph", "Josephine", "Josh", "Joshua", "Joshuah", "Josiah", "Josiane", "Josianne", "Josie", "Josue", "Jovan", "Jovani", "Jovanny", "Jovany", "Joy", "Joyce", "Juana", "Juanita", "Judah", "Judd", "Jude", "Judge", "Judson", "Judy", "Jules", "Julia", "Julian", "Juliana", "Julianne", "Julie", "Julien", "Juliet", "Julio", "Julius", "June", "Junior", "Junius", "Justen", "Justice", "Justina", "Justine", "Juston", "Justus", "Justyn", "Juvenal", "Juwan", "Kacey", "Kaci", "Kacie", "Kade", "Kaden", "Kadin", "Kaela", "Kaelyn", "Kaia", "Kailee", "Kailey", "Kailyn", "Kaitlin", "Kaitlyn", "Kale", "Kaleb", "Kaleigh", "Kaley", "Kali", "Kallie", "Kameron", "Kamille", "Kamren", "Kamron", "Kamryn", "Kane", "Kara", "Kareem", "Karelle", "Karen", "Kari", "Kariane", "Karianne", "Karina", "Karine", "Karl", "Karlee", "Karley", "Karli", "Karlie", "Karolann", "Karson", "Kasandra", "Kasey", "Kassandra", "Katarina", "Katelin", "Katelyn", "Katelynn", "Katharina", "Katherine", "Katheryn", "Kathleen", "Kathlyn", "Kathryn", "Kathryne", "Katlyn", "Katlynn", "Katrina", "Katrine", "Kattie", "Kavon", "Kay", "Kaya", "Kaycee", "Kayden", "Kayla", "Kaylah", "Kaylee", "Kayleigh", "Kayley", "Kayli", "Kaylie", "Kaylin", "Keagan", "Keanu", "Keara", "Keaton", "Keegan", "Keeley", "Keely", "Keenan", "Keira", "Keith", "Kellen", "Kelley", "Kelli", "Kellie", "Kelly", "Kelsi", "Kelsie", "Kelton", "Kelvin", "Ken", "Kendall", "Kendra", "Kendrick", "Kenna", "Kennedi", "Kennedy", "Kenneth", "Kennith", "Kenny", "Kenton", "Kenya", "Kenyatta", "Kenyon", "Keon", "Keshaun", "Keshawn", "Keven", "Kevin", "Kevon", "Keyon", "Keyshawn", "Khalid", "Khalil", "Kian", "Kiana", "Kianna", "Kiara", "Kiarra", "Kiel", "Kiera", "Kieran", "Kiley", "Kim", "Kimberly", "King", "Kip", "Kira", "Kirk", "Kirsten", "Kirstin", "Kitty", "Kobe", "Koby", "Kody", "Kolby", "Kole", "Korbin", "Korey", "Kory", "Kraig", "Kris", "Krista", "Kristian", "Kristin", "Kristina", "Kristofer", "Kristoffer", "Kristopher", "Kristy", "Krystal", "Krystel", "Krystina", "Kurt", "Kurtis", "Kyla", "Kyle", "Kylee", "Kyleigh", "Kyler", "Kylie", "Kyra", "Lacey", "Lacy", "Ladarius", "Lafayette", "Laila", "Laisha", "Lamar", "Lambert", "Lamont", "Lance", "Landen", "Lane", "Laney", "Larissa", "Laron", "Larry", "Larue", "Laura", "Laurel", "Lauren", "Laurence", "Lauretta", "Lauriane", "Laurianne", "Laurie", "Laurine", "Laury", "Lauryn", "Lavada", "Lavern", "Laverna", "Laverne", "Lavina", "Lavinia", "Lavon", "Lavonne", "Lawrence", "Lawson", "Layla", "Layne", "Lazaro", "Lea", "Leann", "Leanna", "Leanne", "Leatha", "Leda", "Lee", "Leif", "Leila", "Leilani", "Lela", "Lelah", "Leland", "Lelia", "Lempi", "Lemuel", "Lenna", "Lennie", "Lenny", "Lenora", "Lenore", "Leo", "Leola", "Leon", "Leonard", "Leonardo", "Leone", "Leonel", "Leonie", "Leonor", "Leonora", "Leopold", "Leopoldo", "Leora", "Lera", "Lesley", "Leslie", "Lesly", "Lessie", "Lester", "Leta", "Letha", "Letitia", "Levi", "Lew", "Lewis", "Lexi", "Lexie", "Lexus", "Lia", "Liam", "Liana", "Libbie", "Libby", "Lila", "Lilian", "Liliana", "Liliane", "Lilla", "Lillian", "Lilliana", "Lillie", "Lilly", "Lily", "Lilyan", "Lina", "Lincoln", "Linda", "Lindsay", "Lindsey", "Linnea", "Linnie", "Linwood", "Lionel", "Lisa", "Lisandro", "Lisette", "Litzy", "Liza", "Lizeth", "Lizzie", "Llewellyn", "Lloyd", "Logan", "Lois", "Lola", "Lolita", "Loma", "Lon", "London", "Lonie", "Lonnie", "Lonny", "Lonzo", "Lora", "Loraine", "Loren", "Lorena", "Lorenz", "Lorenza", "Lorenzo", "Lori", "Lorine", "Lorna", "Lottie", "Lou", "Louie", "Louisa", "Lourdes", "Louvenia", "Lowell", "Loy", "Loyal", "Loyce", "Lucas", "Luciano", "Lucie", "Lucienne", "Lucile", "Lucinda", "Lucio", "Lucious", "Lucius", "Lucy", "Ludie", "Ludwig", "Lue", "Luella", "Luigi", "Luis", "Luisa", "Lukas", "Lula", "Lulu", "Luna", "Lupe", "Lura", "Lurline", "Luther", "Luz", "Lyda", "Lydia", "Lyla", "Lynn", "Lyric", "Lysanne", "Mabel", "Mabelle", "Mable", "Mac", "Macey", "Maci", "Macie", "Mack", "Mackenzie", "Macy", "Madaline", "Madalyn", "Maddison", "Madeline", "Madelyn", "Madelynn", "Madge", "Madie", "Madilyn", "Madisen", "Madison", "Madisyn", "Madonna", "Madyson", "Mae", "Maegan", "Maeve", "Mafalda", "Magali", "Magdalen", "Magdalena", "Maggie", "Magnolia", "Magnus", "Maia", "Maida", "Maiya", "Major", "Makayla", "Makenna", "Makenzie", "Malachi", "Malcolm", "Malika", "Malinda", "Mallie", "Mallory", "Malvina", "Mandy", "Manley", "Manuel", "Manuela", "Mara", "Marc", "Marcel", "Marcelina", "Marcelino", "Marcella", "Marcelle", "Marcellus", "Marcelo", "Marcia", "Marco", "Marcos", "Marcus", "Margaret", "Margarete", "Margarett", "Margaretta", "Margarette", "Margarita", "Marge", "Margie", "Margot", "Margret", "Marguerite", "Maria", "Mariah", "Mariam", "Marian", "Mariana", "Mariane", "Marianna", "Marianne", "Mariano", "Maribel", "Marie", "Mariela", "Marielle", "Marietta", "Marilie", "Marilou", "Marilyne", "Marina", "Mario", "Marion", "Marisa", "Marisol", "Maritza", "Marjolaine", "Marjorie", "Marjory", "Mark", "Markus", "Marlee", "Marlen", "Marlene", "Marley", "Marlin", "Marlon", "Marques", "Marquis", "Marquise", "Marshall", "Marta", "Martin", "Martina", "Martine", "Marty", "Marvin", "Mary", "Maryam", "Maryjane", "Maryse", "Mason", "Mateo", "Mathew", "Mathias", "Mathilde", "Matilda", "Matilde", "Matt", "Matteo", "Mattie", "Maud", "Maude", "Maudie", "Maureen", "Maurice", "Mauricio", "Maurine", "Maverick", "Mavis", "Max", "Maxie", "Maxime", "Maximilian", "Maximillia", "Maximillian", "Maximo", "Maximus", "Maxine", "Maxwell", "May", "Maya", "Maybell", "Maybelle", "Maye", "Maymie", "Maynard", "Mayra", "Mazie", "Mckayla", "Mckenna", "Mckenzie", "Meagan", "Meaghan", "Meda", "Megane", "Meggie", "Meghan", "Mekhi", "Melany", "Melba", "Melisa", "Melissa", "Mellie", "Melody", "Melvin", "Melvina", "Melyna", "Melyssa", "Mercedes", "Meredith", "Merl", "Merle", "Merlin", "Merritt", "Mertie", "Mervin", "Meta", "Mia", "Micaela", "Micah", "Michael", "Michaela", "Michale", "Micheal", "Michel", "Michele", "Michelle", "Miguel", "Mikayla", "Mike", "Mikel", "Milan", "Miles", "Milford", "Miller", "Millie", "Milo", "Milton", "Mina", "Minerva", "Minnie", "Miracle", "Mireille", "Mireya", "Misael", "Missouri", "Misty", "Mitchel", "Mitchell", "Mittie", "Modesta", "Modesto", "Mohamed", "Mohammad", "Mohammed", "Moises", "Mollie", "Molly", "Mona", "Monica", "Monique", "Monroe", "Monserrat", "Monserrate", "Montana", "Monte", "Monty", "Morgan", "Moriah", "Morris", "Mortimer", "Morton", "Mose", "Moses", "Moshe", "Mossie", "Mozell", "Mozelle", "Muhammad", "Muriel", "Murl", "Murphy", "Murray", "Mustafa", "Mya", "Myah", "Mylene", "Myles", "Myra", "Myriam", "Myrl", "Myrna", "Myron", "Myrtice", "Myrtie", "Myrtis", "Myrtle", "Nadia", "Nakia", "Name", "Nannie", "Naomi", "Naomie", "Napoleon", "Narciso", "Nash", "Nasir", "Nat", "Natalia", "Natalie", "Natasha", "Nathan", "Nathanael", "Nathanial", "Nathaniel", "Nathen", "Nayeli", "Neal", "Ned", "Nedra", "Neha", "Neil", "Nelda", "Nella", "Nelle", "Nellie", "Nels", "Nelson", "Neoma", "Nestor", "Nettie", "Neva", "Newell", "Newton", "Nia", "Nicholas", "Nicholaus", "Nichole", "Nick", "Nicklaus", "Nickolas", "Nico", "Nicola", "Nicolas", "Nicole", "Nicolette", "Nigel", "Nikita", "Nikki", "Nikko", "Niko", "Nikolas", "Nils", "Nina", "Noah", "Noble", "Noe", "Noel", "Noelia", "Noemi", "Noemie", "Noemy", "Nola", "Nolan", "Nona", "Nora", "Norbert", "Norberto", "Norene", "Norma", "Norris", "Norval", "Norwood", "Nova", "Novella", "Nya", "Nyah", "Nyasia", "Obie", "Oceane", "Ocie", "Octavia", "Oda", "Odell", "Odessa", "Odie", "Ofelia", "Okey", "Ola", "Olaf", "Ole", "Olen", "Oleta", "Olga", "Olin", "Oliver", "Ollie", "Oma", "Omari", "Omer", "Ona", "Onie", "Opal", "Ophelia", "Ora", "Oral", "Oran", "Oren", "Orie", "Orin", "Orion", "Orland", "Orlando", "Orlo", "Orpha", "Orrin", "Orval", "Orville", "Osbaldo", "Osborne", "Oscar", "Osvaldo", "Oswald", "Oswaldo", "Otha", "Otho", "Otilia", "Otis", "Ottilie", "Ottis", "Otto", "Ova", "Owen", "Ozella", "Pablo", "Paige", "Palma", "Pamela", "Pansy", "Paolo", "Paris", "Parker", "Pascale", "Pasquale", "Pat", "Patience", "Patricia", "Patrick", "Patsy", "Pattie", "Paul", "Paula", "Pauline", "Paxton", "Payton", "Pearl", "Pearlie", "Pearline", "Pedro", "Peggie", "Penelope", "Percival", "Percy", "Perry", "Pete", "Peter", "Petra", "Peyton", "Philip", "Phoebe", "Phyllis", "Pierce", "Pierre", "Pietro", "Pink", "Pinkie", "Piper", "Polly", "Porter", "Precious", "Presley", "Preston", "Price", "Prince", "Princess", "Priscilla", "Providenci", "Prudence", "Queen", "Queenie", "Quentin", "Quincy", "Quinn", "Quinten", "Quinton", "Rachael", "Rachel", "Rachelle", "Rae", "Raegan", "Rafael", "Rafaela", "Raheem", "Rahsaan", "Rahul", "Raina", "Raleigh", "Ralph", "Ramiro", "Ramon", "Ramona", "Randal", "Randall", "Randi", "Randy", "Ransom", "Raoul", "Raphael", "Raphaelle", "Raquel", "Rashad", "Rashawn", "Rasheed", "Raul", "Raven", "Ray", "Raymond", "Raymundo", "Reagan", "Reanna", "Reba", "Rebeca", "Rebecca", "Rebeka", "Rebekah", "Reece", "Reed", "Reese", "Regan", "Reggie", "Reginald", "Reid", "Reilly", "Reina", "Reinhold", "Remington", "Rene", "Renee", "Ressie", "Reta", "Retha", "Retta", "Reuben", "Reva", "Rex", "Rey", "Reyes", "Reymundo", "Reyna", "Reynold", "Rhea", "Rhett", "Rhianna", "Rhiannon", "Rhoda", "Ricardo", "Richard", "Richie", "Richmond", "Rick", "Rickey", "Rickie", "Ricky", "Rico", "Rigoberto", "Riley", "Rita", "River", "Robb", "Robbie", "Robert", "Roberta", "Roberto", "Robin", "Robyn", "Rocio", "Rocky", "Rod", "Roderick", "Rodger", "Rodolfo", "Rodrick", "Rodrigo", "Roel", "Rogelio", "Roger", "Rogers", "Rolando", "Rollin", "Roma", "Romaine", "Roman", "Ron", "Ronaldo", "Ronny", "Roosevelt", "Rory", "Rosa", "Rosalee", "Rosalia", "Rosalind", "Rosalinda", "Rosalyn", "Rosamond", "Rosanna", "Rosario", "Roscoe", "Rose", "Rosella", "Roselyn", "Rosemarie", "Rosemary", "Rosendo", "Rosetta", "Rosie", "Rosina", "Roslyn", "Ross", "Rossie", "Rowan", "Rowena", "Rowland", "Roxane", "Roxanne", "Roy", "Royal", "Royce", "Rozella", "Ruben", "Rubie", "Ruby", "Rubye", "Rudolph", "Rudy", "Rupert", "Russ", "Russel", "Russell", "Rusty", "Ruth", "Ruthe", "Ruthie", "Ryan", "Ryann", "Ryder", "Rylan", "Rylee", "Ryleigh", "Ryley", "Sabina", "Sabrina", "Sabryna", "Sadie", "Sadye", "Sage", "Saige", "Sallie", "Sally", "Salma", "Salvador", "Salvatore", "Sam", "Samanta", "Samantha", "Samara", "Samir", "Sammie", "Sammy", "Samson", "Sandra", "Sandrine", "Sandy", "Sanford", "Santa", "Santiago", "Santina", "Santino", "Santos", "Sarah", "Sarai", "Sarina", "Sasha", "Saul", "Savanah", "Savanna", "Savannah", "Savion", "Scarlett", "Schuyler", "Scot", "Scottie", "Scotty", "Seamus", "Sean", "Sebastian", "Sedrick", "Selena", "Selina", "Selmer", "Serena", "Serenity", "Seth", "Shad", "Shaina", "Shakira", "Shana", "Shane", "Shanel", "Shanelle", "Shania", "Shanie", "Shaniya", "Shanna", "Shannon", "Shanny", "Shanon", "Shany", "Sharon", "Shaun", "Shawn", "Shawna", "Shaylee", "Shayna", "Shayne", "Shea", "Sheila", "Sheldon", "Shemar", "Sheridan", "Sherman", "Sherwood", "Shirley", "Shyann", "Shyanne", "Sibyl", "Sid", "Sidney", "Sienna", "Sierra", "Sigmund", "Sigrid", "Sigurd", "Silas", "Sim", "Simeon", "Simone", "Sincere", "Sister", "Skye", "Skyla", "Skylar", "Sofia", "Soledad", "Solon", "Sonia", "Sonny", "Sonya", "Sophia", "Sophie", "Spencer", "Stacey", "Stacy", "Stan", "Stanford", "Stanley", "Stanton", "Stefan", "Stefanie", "Stella", "Stephan", "Stephania", "Stephanie", "Stephany", "Stephen", "Stephon", "Sterling", "Steve", "Stevie", "Stewart", "Stone", "Stuart", "Summer", "Sunny", "Susan", "Susana", "Susanna", "Susie", "Suzanne", "Sven", "Syble", "Sydnee", "Sydney", "Sydni", "Sydnie", "Sylvan", "Sylvester", "Sylvia", "Tabitha", "Tad", "Talia", "Talon", "Tamara", "Tamia", "Tania", "Tanner", "Tanya", "Tara", "Taryn", "Tate", "Tatum", "Tatyana", "Taurean", "Tavares", "Taya", "Taylor", "Teagan", "Ted", "Telly", "Terence", "Teresa", "Terrance", "Terrell", "Terrence", "Terrill", "Terry", "Tess", "Tessie", "Tevin", "Thad", "Thaddeus", "Thalia", "Thea", "Thelma", "Theo", "Theodora", "Theodore", "Theresa", "Therese", "Theresia", "Theron", "Thomas", "Thora", "Thurman", "Tia", "Tiana", "Tianna", "Tiara", "Tierra", "Tiffany", "Tillman", "Timmothy", "Timmy", "Timothy", "Tina", "Tito", "Titus", "Tobin", "Toby", "Tod", "Tom", "Tomas", "Tomasa", "Tommie", "Toney", "Toni", "Tony", "Torey", "Torrance", "Torrey", "Toy", "Trace", "Tracey", "Tracy", "Travis", "Travon", "Tre", "Tremaine", "Tremayne", "Trent", "Trenton", "Tressa", "Tressie", "Treva", "Trever", "Trevion", "Trevor", "Trey", "Trinity", "Trisha", "Tristian", "Tristin", "Triston", "Troy", "Trudie", "Trycia", "Trystan", "Turner", "Twila", "Tyler", "Tyra", "Tyree", "Tyreek", "Tyrel", "Tyrell", "Tyrese", "Tyrique", "Tyshawn", "Tyson", "Ubaldo", "Ulices", "Ulises", "Una", "Unique", "Urban", "Uriah", "Uriel", "Ursula", "Vada", "Valentin", "Valentina", "Valentine", "Valerie", "Vallie", "Van", "Vance", "Vanessa", "Vaughn", "Veda", "Velda", "Vella", "Velma", "Velva", "Vena", "Verda", "Verdie", "Vergie", "Verla", "Verlie", "Vern", "Verna", "Verner", "Vernice", "Vernie", "Vernon", "Verona", "Veronica", "Vesta", "Vicenta", "Vicente", "Vickie", "Vicky", "Victor", "Victoria", "Vida", "Vidal", "Vilma", "Vince", "Vincent", "Vincenza", "Vincenzo", "Vinnie", "Viola", "Violet", "Violette", "Virgie", "Virgil", "Virginia", "Virginie", "Vita", "Vito", "Viva", "Vivian", "Viviane", "Vivianne", "Vivien", "Vivienne", "Vladimir", "Wade", "Waino", "Waldo", "Walker", "Wallace", "Walter", "Walton", "Wanda", "Ward", "Warren", "Watson", "Wava", "Waylon", "Wayne", "Webster", "Weldon", "Wellington", "Wendell", "Wendy", "Werner", "Westley", "Weston", "Whitney", "Wilber", "Wilbert", "Wilburn", "Wiley", "Wilford", "Wilfred", "Wilfredo", "Wilfrid", "Wilhelm", "Wilhelmine", "Will", "Willa", "Willard", "William", "Willie", "Willis", "Willow", "Willy", "Wilma", "Wilmer", "Wilson", "Wilton", "Winfield", "Winifred", "Winnifred", "Winona", "Winston", "Woodrow", "Wyatt", "Wyman", "Xander", "Xavier", "Xzavier", "Yadira", "Yasmeen", "Yasmin", "Yasmine", "Yazmin", "Yesenia", "Yessenia", "Yolanda", "Yoshiko", "Yvette", "Yvonne", "Zachariah", "Zachary", "Zachery", "Zack", "Zackary", "Zackery", "Zakary", "Zander", "Zane", "Zaria", "Zechariah", "Zelda", "Zella", "Zelma", "Zena", "Zetta", "Zion", "Zita", "Zoe", "Zoey", "Zoie", "Zoila", "Zola", "Zora", "Zula"];
        e.exports = {
            generateUsername: function() {
                var e = r.randomElement(i),
                    t = r.randomAlphanumStr(3);
                return "".concat(e, "-").concat(t)
            }
        }
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return T
            }));
            var r = n(7),
                i = n(4),
                o = n(1),
                a = n(0),
                s = n.n(a),
                c = n(11),
                u = n.n(c),
                l = n(33),
                d = n.n(l),
                p = n(5),
                h = n(44),
                f = n(34);

            function m(e) {
                return (m = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                    return typeof e
                } : function(e) {
                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                })(e)
            }

            function v(e, t) {
                for (var n = 0; n < t.length; n++) {
                    var r = t[n];
                    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                }
            }

            function y(e, t) {
                return !t || "object" !== m(t) && "function" != typeof t ? function(e) {
                    if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return e
                }(e) : t
            }

            function g(e, t, n) {
                return (g = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function(e, t, n) {
                    var r = function(e, t) {
                        for (; !Object.prototype.hasOwnProperty.call(e, t) && null !== (e = _(e)););
                        return e
                    }(e, t);
                    if (r) {
                        var i = Object.getOwnPropertyDescriptor(r, t);
                        return i.get ? i.get.call(n) : i.value
                    }
                })(e, t, n || e)
            }

            function _(e) {
                return (_ = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
                    return e.__proto__ || Object.getPrototypeOf(e)
                })(e)
            }

            function S(e, t) {
                return (S = Object.setPrototypeOf || function(e, t) {
                    return e.__proto__ = t, e
                })(e, t)
            }
            var b = Object(i.getLogger)(e),
                E = function(e) {
                    function t(e, n, r) {
                        var i;
                        return function(e, t) {
                            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                        }(this, t), (i = y(this, _(t).call(this))).xmpp = e, i.eventEmitter = n, i.sessions = {}, i.jvbIceConfig = r.jvb, i.p2pIceConfig = r.p2p, i.mediaConstraints = {
                            offerToReceiveAudio: !0,
                            offerToReceiveVideo: !0
                        }, i
                    }
                    var n, i, a;
                    return function(e, t) {
                        if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
                        e.prototype = Object.create(t && t.prototype, {
                            constructor: {
                                value: e,
                                writable: !0,
                                configurable: !0
                            }
                        }), t && S(e, t)
                    }(t, e), n = t, (i = [{
                        key: "init",
                        value: function(e) {
                            g(_(t.prototype), "init", this).call(this, e), this.connection.addHandler(this.onJingle.bind(this), "urn:xmpp:jingle:1", "iq", "set", null, null)
                        }
                    }, {
                        key: "onJingle",
                        value: function(e) {
                            var t = $(e).find("jingle").attr("sid"),
                                n = $(e).find("jingle").attr("action"),
                                i = e.getAttribute("from"),
                                a = Object(o.$iq)({
                                    type: "result",
                                    to: i,
                                    id: e.getAttribute("id")
                                });
                            b.log("on jingle ".concat(n, " from ").concat(i), e);
                            var c = this.sessions[t];
                            if ("session-initiate" !== n) {
                                if (!c) return a.attrs({
                                    type: "error"
                                }), a.c("error", {
                                    type: "cancel"
                                }).c("item-not-found", {
                                    xmlns: "urn:ietf:params:xml:ns:xmpp-stanzas"
                                }).up().c("unknown-session", {
                                    xmlns: "urn:xmpp:jingle:errors:1"
                                }), b.warn("invalid session id", e), this.connection.send(a), !0;
                                if (i !== c.remoteJid) return b.warn("jid mismatch for session id", t, c.remoteJid, e), a.attrs({
                                    type: "error"
                                }), a.c("error", {
                                    type: "cancel"
                                }).c("item-not-found", {
                                    xmlns: "urn:ietf:params:xml:ns:xmpp-stanzas"
                                }).up().c("unknown-session", {
                                    xmlns: "urn:xmpp:jingle:errors:1"
                                }), this.connection.send(a), !0
                            } else if (void 0 !== c) return a.attrs({
                                type: "error"
                            }), a.c("error", {
                                type: "cancel"
                            }).c("service-unavailable", {
                                xmlns: "urn:ietf:params:xml:ns:xmpp-stanzas"
                            }).up(), b.warn("duplicate session id", t, e), this.connection.send(a), !0;
                            var l = window.performance.now(),
                                d = "focus" !== o.Strophe.getResourceFromJid(i);
                            switch (n) {
                                case "session-initiate":
                                    b.log("(TIME) received session-initiate:\t", l);
                                    var f = $(e).find("jingle>startmuted");
                                    if (f && f.length > 0) {
                                        var m = f.attr("audio"),
                                            v = f.attr("video");
                                        this.eventEmitter.emit(s.a.START_MUTED_FROM_FOCUS, "true" === m, "true" === v)
                                    }
                                    b.info("Marking session from ".concat(i, " as ").concat(d ? "" : "*not*", " P2P")), c = new h.a($(e).find("jingle").attr("sid"), $(e).attr("to"), i, this.connection, this.mediaConstraints, d ? this.p2pIceConfig : this.jvbIceConfig, d, !1), this.sessions[c.sid] = c, this.eventEmitter.emit(s.a.CALL_INCOMING, c, $(e).find(">jingle"), l);
                                    break;
                                case "session-accept":
                                    this.eventEmitter.emit(s.a.CALL_ACCEPTED, c, $(e).find(">jingle"));
                                    break;
                                case "content-modify":
                                    c.modifyContents($(e).find(">jingle"));
                                    break;
                                case "transport-info":
                                    this.eventEmitter.emit(s.a.TRANSPORT_INFO, c, $(e).find(">jingle"));
                                    break;
                                case "session-terminate":
                                    b.log("terminating...", c.sid);
                                    var y = null,
                                        g = null;
                                    $(e).find(">jingle>reason").length && (y = $(e).find(">jingle>reason>:first")[0].tagName, g = $(e).find(">jingle>reason>text").text()), this.terminate(c.sid, y, g), this.eventEmitter.emit(s.a.CALL_ENDED, c, y, g);
                                    break;
                                case "transport-replace":
                                    b.info("(TIME) Start transport replace", l), p.a.sendAnalytics(Object(r.F)(r.f, {
                                        p2p: d,
                                        value: l
                                    })), c.replaceTransport($(e).find(">jingle"), (function() {
                                        var e = window.performance.now();
                                        b.info("(TIME) Transport replace success!", e), p.a.sendAnalytics(Object(r.F)(r.g, {
                                            p2p: d,
                                            value: e
                                        }))
                                    }), (function(e) {
                                        u.a.callErrorHandler(e), b.error("Transport replace failed", e), c.sendTransportReject()
                                    }));
                                    break;
                                case "addsource":
                                case "source-add":
                                    c.addRemoteStream($(e).find(">jingle>content"));
                                    break;
                                case "removesource":
                                case "source-remove":
                                    c.removeRemoteStream($(e).find(">jingle>content"));
                                    break;
                                default:
                                    b.warn("jingle action not implemented", n), a.attrs({
                                        type: "error"
                                    }), a.c("error", {
                                        type: "cancel"
                                    }).c("bad-request", {
                                        xmlns: "urn:ietf:params:xml:ns:xmpp-stanzas"
                                    }).up()
                            }
                            return this.connection.send(a), !0
                        }
                    }, {
                        key: "newP2PJingleSession",
                        value: function(e, t) {
                            var n = new h.a(d.a.randomHexString(12), e, t, this.connection, this.mediaConstraints, this.p2pIceConfig, !0, !0);
                            return this.sessions[n.sid] = n, n
                        }
                    }, {
                        key: "terminate",
                        value: function(e, t, n) {
                            this.sessions.hasOwnProperty(e) && ("ended" !== this.sessions[e].state && this.sessions[e].onTerminated(t, n), delete this.sessions[e])
                        }
                    }, {
                        key: "getStunAndTurnCredentials",
                        value: function() {
                            var e = this;
                            this.connection.sendIQ(Object(o.$iq)({
                                type: "get",
                                to: this.connection.domain
                            }).c("services", {
                                xmlns: "urn:xmpp:extdisco:1"
                            }), (function(t) {
                                var n = [];
                                $(t).find(">services>service").each((function(e, t) {
                                    var r = {},
                                        i = (t = $(t)).attr("type");
                                    switch (i) {
                                        case "stun":
                                            r.url = "stun:".concat(t.attr("host")), t.attr("port") && (r.url += ":".concat(t.attr("port"))), n.push(r);
                                            break;
                                        case "turn":
                                        case "turns":
                                            r.url = "".concat(i, ":");
                                            var o = t.attr("username");
                                            if (o) {
                                                var a = navigator.userAgent.match(/Chrom(e|ium)\/([0-9]+)\./);
                                                a && parseInt(a[2], 10) < 28 ? r.url += "".concat(o, "@") : r.username = o
                                            }
                                            r.url += t.attr("host"), t.attr("port") && (r.url += ":".concat(t.attr("port")));
                                            var s = t.attr("transport");
                                            s && "udp" !== s && (r.url += "?transport=".concat(s)), r.credential = t.attr("password") || r.credential, n.push(r)
                                    }
                                }));
                                var r = e.xmpp.options;
                                r.useStunTurn && (e.jvbIceConfig.iceServers = n.filter((function(e) {
                                    return e.url.startsWith("turns")
                                }))), r.p2p && r.p2p.useStunTurn && (e.p2pIceConfig.iceServers = n)
                            }), (function(e) {
                                b.warn("getting turn credentials failed", e), b.warn("is mod_turncredentials or similar installed?")
                            }))
                        }
                    }, {
                        key: "getLog",
                        value: function() {
                            var e = this,
                                t = {};
                            return Object.keys(this.sessions).forEach((function(n) {
                                var r = e.sessions[n].peerconnection;
                                r && r.updateLog && (t["jingle_".concat(n)] = {
                                    updateLog: r.updateLog,
                                    stats: r.stats,
                                    url: window.location.href
                                })
                            })), t
                        }
                    }]) && v(n.prototype, i), a && v(n, a), t
                }(f.b);

            function T(e, t, n) {
                o.Strophe.addConnectionPlugin("jingle", new E(e, t, n))
            }
        }).call(this, "modules/xmpp/strophe.jingle.js")
    }, function(e, t) {
        e.exports = {
            integerHash: function(e) {
                if (!e) return 0;
                var t, n = 0;
                for (t = 0; t < e.length; t++) n += e.charCodeAt(t) * Math.pow(31, e.length - 1 - t), n = Math.abs(0 | n);
                return n
            }
        }
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return s
            }));
            var r = n(4),
                i = n(30);

            function o(e, t) {
                for (var n = 0; n < t.length; n++) {
                    var r = t[n];
                    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                }
            }
            var a = Object(r.getLogger)(e),
                s = function() {
                    function e(t, n, r, i, o, a, s) {
                        ! function(e, t) {
                            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                        }(this, e), this.sid = t, this.localJid = n, this.remoteJid = r, this.connection = i, this.mediaConstraints = o, this.iceConfig = a, this.isInitiator = s, this.usedrip = !0, this.dripContainer = [], this.room = null, this.state = null, this.rtc = null
                    }
                    var t, n, r;
                    return t = e, (n = [{
                        key: "initialize",
                        value: function(e, t, n) {
                            if (null !== this.state) {
                                var r = "attempt to initiate on session ".concat(this.sid, "\n                   in state ").concat(this.state);
                                throw a.error(r), new Error(r)
                            }
                            this.room = e, this.rtc = t, this.state = i.c, this.doInitialize(n)
                        }
                    }, {
                        key: "doInitialize",
                        value: function(e) {}
                    }, {
                        key: "addIceCandidates",
                        value: function(e) {}
                    }, {
                        key: "getState",
                        value: function() {
                            return this.state
                        }
                    }, {
                        key: "addSources",
                        value: function(e) {}
                    }, {
                        key: "removeSources",
                        value: function(e) {}
                    }, {
                        key: "terminate",
                        value: function(e, t, n) {}
                    }, {
                        key: "acceptOffer",
                        value: function(e, t, n) {}
                    }, {
                        key: "_getInitiatorJid",
                        value: function() {
                            return this.isInitiator ? this.localJid : this.remoteJid
                        }
                    }, {
                        key: "initiatorJid",
                        get: function() {
                            return this.isInitiator ? this.localJid : this.remoteJid
                        }
                    }, {
                        key: "responderJid",
                        get: function() {
                            return this.isInitiator ? this.remoteJid : this.localJid
                        }
                    }]) && o(t.prototype, n), r && o(t, r), e
                }()
        }).call(this, "modules/xmpp/JingleSession.js")
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return h
            }));
            var r = n(4),
                i = n(9),
                o = n(37),
                a = n(85);

            function s(e) {
                return (s = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                    return typeof e
                } : function(e) {
                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                })(e)
            }

            function c(e, t) {
                for (var n = 0; n < t.length; n++) {
                    var r = t[n];
                    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                }
            }

            function u(e, t) {
                return !t || "object" !== s(t) && "function" != typeof t ? function(e) {
                    if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return e
                }(e) : t
            }

            function l(e) {
                return (l = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
                    return e.__proto__ || Object.getPrototypeOf(e)
                })(e)
            }

            function d(e, t) {
                return (d = Object.setPrototypeOf || function(e, t) {
                    return e.__proto__ = t, e
                })(e, t)
            }
            var p = Object(r.getLogger)(e),
                h = function(e) {
                    function t() {
                        var e;
                        return function(e, t) {
                            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                        }(this, t), (e = u(this, l(t).call(this))).ssrcOwners = new Map, e.chatRoom = null, e
                    }
                    var n, r, a;
                    return function(e, t) {
                        if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
                        e.prototype = Object.create(t && t.prototype, {
                            constructor: {
                                value: e,
                                writable: !0,
                                configurable: !0
                            }
                        }), t && d(e, t)
                    }(t, e), n = t, (r = [{
                        key: "setChatRoom",
                        value: function(e) {
                            var t = this,
                                n = this.chatRoom;
                            this.chatRoom = e, n && (n.removePresenceListener("audiomuted", this._audioMuteHandler), n.removePresenceListener("videomuted", this._videoMuteHandler), n.removePresenceListener("videoType", this._videoTypeHandler)), e && (this._audioMuteHandler = function(e, n) {
                                t.eventEmitter.emit(o.a, n, i.a, "true" === e.value)
                            }, e.addPresenceListener("audiomuted", this._audioMuteHandler), this._videoMuteHandler = function(e, n) {
                                t.eventEmitter.emit(o.a, n, i.b, "true" === e.value)
                            }, e.addPresenceListener("videomuted", this._videoMuteHandler), this._videoTypeHandler = function(e, n) {
                                t.eventEmitter.emit(o.b, n, e.value)
                            }, e.addPresenceListener("videoType", this._videoTypeHandler))
                        }
                    }, {
                        key: "getPeerMediaInfo",
                        value: function(e, t) {
                            if (this.chatRoom) return this.chatRoom.getMediaPresenceInfo(e, t);
                            p.error("Requested peer media info, before room was set")
                        }
                    }, {
                        key: "getSSRCOwner",
                        value: function(e) {
                            return this.ssrcOwners.get(e)
                        }
                    }, {
                        key: "setSSRCOwner",
                        value: function(e, t) {
                            if ("number" != typeof e) throw new TypeError("SSRC(".concat(e, ") must be a number"));
                            this.ssrcOwners.set(e, t)
                        }
                    }]) && c(n.prototype, r), a && c(n, a), t
                }(a.a)
        }).call(this, "modules/xmpp/SignalingLayerImpl.js")
    }, function(e, t, n) {
        "use strict";

        function r(e) {
            return (r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                return typeof e
            } : function(e) {
                return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
            })(e)
        }

        function i(e, t) {
            for (var n = 0; n < t.length; n++) {
                var r = t[n];
                r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
            }
        }

        function o(e, t) {
            return !t || "object" !== r(t) && "function" != typeof t ? function(e) {
                if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return e
            }(e) : t
        }

        function a(e) {
            return (a = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
                return e.__proto__ || Object.getPrototypeOf(e)
            })(e)
        }

        function s(e, t) {
            return (s = Object.setPrototypeOf || function(e, t) {
                return e.__proto__ = t, e
            })(e, t)
        }
        n.d(t, "a", (function() {
            return c
        }));
        var c = function(e) {
            function t() {
                return function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, t), o(this, a(t).apply(this, arguments))
            }
            var n, r, c;
            return function(e, t) {
                if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
                e.prototype = Object.create(t && t.prototype, {
                    constructor: {
                        value: e,
                        writable: !0,
                        configurable: !0
                    }
                }), t && s(e, t)
            }(t, e), n = t, (r = [{
                key: "getSSRCOwner",
                value: function(e) {
                    throw new Error("not implemented")
                }
            }, {
                key: "getPeerMediaInfo",
                value: function(e, t) {
                    throw new Error("not implemented")
                }
            }]) && i(n.prototype, r), c && i(n, c), t
        }(n(24).a)
    }, function(e, t, n) {
        "use strict";
        n.d(t, "a", (function() {
            return a
        }));
        var r = n(87),
            i = n.n(r);

        function o(e, t) {
            for (var n = 0; n < t.length; n++) {
                var r = t[n];
                r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
            }
        }
        var a = function() {
            function e() {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this._queue = i.a.queue(this._processQueueTasks.bind(this), 1), this._stopped = !1
            }
            var t, n, r;
            return t = e, (n = [{
                key: "clear",
                value: function() {
                    this._queue.kill()
                }
            }, {
                key: "_processQueueTasks",
                value: function(e, t) {
                    e(t)
                }
            }, {
                key: "push",
                value: function(e, t) {
                    this._stopped ? t && t(new Error("The queue has been stopped")) : this._queue.push(e, t)
                }
            }, {
                key: "shutdown",
                value: function() {
                    this._stopped = !0
                }
            }]) && o(t.prototype, n), r && o(t, r), e
        }()
    }, function(e, t, n) {
        (function(n, r) {
            var i;
            /*!
             * async
             * https://github.com/caolan/async
             *
             * Copyright 2010-2014 Caolan McMahon
             * Released under the MIT license
             */
            ! function() {
                var o, a, s = {};

                function c(e) {
                    var t = !1;
                    return function() {
                        if (t) throw new Error("Callback was already called.");
                        t = !0, e.apply(o, arguments)
                    }
                }
                null != (o = this) && (a = o.async), s.noConflict = function() {
                    return o.async = a, s
                };
                var u = Object.prototype.toString,
                    l = Array.isArray || function(e) {
                        return "[object Array]" === u.call(e)
                    },
                    d = function(e, t) {
                        if (e.forEach) return e.forEach(t);
                        for (var n = 0; n < e.length; n += 1) t(e[n], n, e)
                    },
                    p = function(e, t) {
                        if (e.map) return e.map(t);
                        var n = [];
                        return d(e, (function(e, r, i) {
                            n.push(t(e, r, i))
                        })), n
                    },
                    h = function(e) {
                        if (Object.keys) return Object.keys(e);
                        var t = [];
                        for (var n in e) e.hasOwnProperty(n) && t.push(n);
                        return t
                    };
                void 0 !== n && n.nextTick ? (s.nextTick = n.nextTick, s.setImmediate = void 0 !== r ? function(e) {
                    r(e)
                } : s.nextTick) : "function" == typeof r ? (s.nextTick = function(e) {
                    r(e)
                }, s.setImmediate = s.nextTick) : (s.nextTick = function(e) {
                    setTimeout(e, 0)
                }, s.setImmediate = s.nextTick), s.each = function(e, t, n) {
                    if (n = n || function() {}, !e.length) return n();
                    var r = 0;

                    function i(t) {
                        t ? (n(t), n = function() {}) : (r += 1) >= e.length && n()
                    }
                    d(e, (function(e) {
                        t(e, c(i))
                    }))
                }, s.forEach = s.each, s.eachSeries = function(e, t, n) {
                    if (n = n || function() {}, !e.length) return n();
                    var r = 0;
                    ! function i() {
                        t(e[r], (function(t) {
                            t ? (n(t), n = function() {}) : (r += 1) >= e.length ? n() : i()
                        }))
                    }()
                }, s.forEachSeries = s.eachSeries, s.eachLimit = function(e, t, n, r) {
                    f(t).apply(null, [e, n, r])
                }, s.forEachLimit = s.eachLimit;
                var f = function(e) {
                        return function(t, n, r) {
                            if (r = r || function() {}, !t.length || e <= 0) return r();
                            var i = 0,
                                o = 0,
                                a = 0;
                            ! function s() {
                                if (i >= t.length) return r();
                                for (; a < e && o < t.length;) a += 1, n(t[(o += 1) - 1], (function(e) {
                                    e ? (r(e), r = function() {}) : (a -= 1, (i += 1) >= t.length ? r() : s())
                                }))
                            }()
                        }
                    },
                    m = function(e) {
                        return function() {
                            var t = Array.prototype.slice.call(arguments);
                            return e.apply(null, [s.each].concat(t))
                        }
                    },
                    v = function(e) {
                        return function() {
                            var t = Array.prototype.slice.call(arguments);
                            return e.apply(null, [s.eachSeries].concat(t))
                        }
                    },
                    y = function(e, t, n, r) {
                        if (t = p(t, (function(e, t) {
                                return {
                                    index: t,
                                    value: e
                                }
                            })), r) {
                            var i = [];
                            e(t, (function(e, t) {
                                n(e.value, (function(n, r) {
                                    i[e.index] = r, t(n)
                                }))
                            }), (function(e) {
                                r(e, i)
                            }))
                        } else e(t, (function(e, t) {
                            n(e.value, (function(e) {
                                t(e)
                            }))
                        }))
                    };
                s.map = m(y), s.mapSeries = v(y), s.mapLimit = function(e, t, n, r) {
                    return g(t)(e, n, r)
                };
                var g = function(e) {
                    return function(e, t) {
                        return function() {
                            var n = Array.prototype.slice.call(arguments);
                            return t.apply(null, [f(e)].concat(n))
                        }
                    }(e, y)
                };
                s.reduce = function(e, t, n, r) {
                    s.eachSeries(e, (function(e, r) {
                        n(t, e, (function(e, n) {
                            t = n, r(e)
                        }))
                    }), (function(e) {
                        r(e, t)
                    }))
                }, s.inject = s.reduce, s.foldl = s.reduce, s.reduceRight = function(e, t, n, r) {
                    var i = p(e, (function(e) {
                        return e
                    })).reverse();
                    s.reduce(i, t, n, r)
                }, s.foldr = s.reduceRight;
                var _ = function(e, t, n, r) {
                    var i = [];
                    e(t = p(t, (function(e, t) {
                        return {
                            index: t,
                            value: e
                        }
                    })), (function(e, t) {
                        n(e.value, (function(n) {
                            n && i.push(e), t()
                        }))
                    }), (function(e) {
                        r(p(i.sort((function(e, t) {
                            return e.index - t.index
                        })), (function(e) {
                            return e.value
                        })))
                    }))
                };
                s.filter = m(_), s.filterSeries = v(_), s.select = s.filter, s.selectSeries = s.filterSeries;
                var S = function(e, t, n, r) {
                    var i = [];
                    e(t = p(t, (function(e, t) {
                        return {
                            index: t,
                            value: e
                        }
                    })), (function(e, t) {
                        n(e.value, (function(n) {
                            n || i.push(e), t()
                        }))
                    }), (function(e) {
                        r(p(i.sort((function(e, t) {
                            return e.index - t.index
                        })), (function(e) {
                            return e.value
                        })))
                    }))
                };
                s.reject = m(S), s.rejectSeries = v(S);
                var b = function(e, t, n, r) {
                    e(t, (function(e, t) {
                        n(e, (function(n) {
                            n ? (r(e), r = function() {}) : t()
                        }))
                    }), (function(e) {
                        r()
                    }))
                };
                s.detect = m(b), s.detectSeries = v(b), s.some = function(e, t, n) {
                    s.each(e, (function(e, r) {
                        t(e, (function(e) {
                            e && (n(!0), n = function() {}), r()
                        }))
                    }), (function(e) {
                        n(!1)
                    }))
                }, s.any = s.some, s.every = function(e, t, n) {
                    s.each(e, (function(e, r) {
                        t(e, (function(e) {
                            e || (n(!1), n = function() {}), r()
                        }))
                    }), (function(e) {
                        n(!0)
                    }))
                }, s.all = s.every, s.sortBy = function(e, t, n) {
                    s.map(e, (function(e, n) {
                        t(e, (function(t, r) {
                            t ? n(t) : n(null, {
                                value: e,
                                criteria: r
                            })
                        }))
                    }), (function(e, t) {
                        if (e) return n(e);
                        n(null, p(t.sort((function(e, t) {
                            var n = e.criteria,
                                r = t.criteria;
                            return n < r ? -1 : n > r ? 1 : 0
                        })), (function(e) {
                            return e.value
                        })))
                    }))
                }, s.auto = function(e, t) {
                    t = t || function() {};
                    var n = h(e),
                        r = n.length;
                    if (!r) return t();
                    var i = {},
                        o = [],
                        a = function(e) {
                            o.unshift(e)
                        },
                        c = function() {
                            r--, d(o.slice(0), (function(e) {
                                e()
                            }))
                        };
                    a((function() {
                        if (!r) {
                            var e = t;
                            t = function() {}, e(null, i)
                        }
                    })), d(n, (function(n) {
                        var r = l(e[n]) ? e[n] : [e[n]],
                            u = function(e) {
                                var r = Array.prototype.slice.call(arguments, 1);
                                if (r.length <= 1 && (r = r[0]), e) {
                                    var o = {};
                                    d(h(i), (function(e) {
                                        o[e] = i[e]
                                    })), o[n] = r, t(e, o), t = function() {}
                                } else i[n] = r, s.setImmediate(c)
                            },
                            p = r.slice(0, Math.abs(r.length - 1)) || [],
                            f = function() {
                                return t = function(e, t) {
                                    return e && i.hasOwnProperty(t)
                                }, r = !0, ((e = p).reduce ? e.reduce(t, r) : (d(e, (function(e, n, i) {
                                    r = t(r, e, n, i)
                                })), r)) && !i.hasOwnProperty(n);
                                var e, t, r
                            };
                        if (f()) r[r.length - 1](u, i);
                        else {
                            a((function e() {
                                f() && (! function(e) {
                                    for (var t = 0; t < o.length; t += 1)
                                        if (o[t] === e) return void o.splice(t, 1)
                                }(e), r[r.length - 1](u, i))
                            }))
                        }
                    }))
                }, s.retry = function(e, t, n) {
                    var r = [];
                    "function" == typeof e && (n = t, t = e, e = 5), e = parseInt(e, 10) || 5;
                    var i = function(i, o) {
                        for (var a = function(e, t) {
                                return function(n) {
                                    e((function(e, r) {
                                        n(!e || t, {
                                            err: e,
                                            result: r
                                        })
                                    }), o)
                                }
                            }; e;) r.push(a(t, !(e -= 1)));
                        s.series(r, (function(e, t) {
                            t = t[t.length - 1], (i || n)(t.err, t.result)
                        }))
                    };
                    return n ? i() : i
                }, s.waterfall = function(e, t) {
                    if (t = t || function() {}, !l(e)) {
                        var n = new Error("First argument to waterfall must be an array of functions");
                        return t(n)
                    }
                    if (!e.length) return t();
                    ! function e(n) {
                        return function(r) {
                            if (r) t.apply(null, arguments), t = function() {};
                            else {
                                var i = Array.prototype.slice.call(arguments, 1),
                                    o = n.next();
                                o ? i.push(e(o)) : i.push(t), s.setImmediate((function() {
                                    n.apply(null, i)
                                }))
                            }
                        }
                    }(s.iterator(e))()
                };
                var E = function(e, t, n) {
                    if (n = n || function() {}, l(t)) e.map(t, (function(e, t) {
                        e && e((function(e) {
                            var n = Array.prototype.slice.call(arguments, 1);
                            n.length <= 1 && (n = n[0]), t.call(null, e, n)
                        }))
                    }), n);
                    else {
                        var r = {};
                        e.each(h(t), (function(e, n) {
                            t[e]((function(t) {
                                var i = Array.prototype.slice.call(arguments, 1);
                                i.length <= 1 && (i = i[0]), r[e] = i, n(t)
                            }))
                        }), (function(e) {
                            n(e, r)
                        }))
                    }
                };
                s.parallel = function(e, t) {
                    E({
                        map: s.map,
                        each: s.each
                    }, e, t)
                }, s.parallelLimit = function(e, t, n) {
                    E({
                        map: g(t),
                        each: f(t)
                    }, e, n)
                }, s.series = function(e, t) {
                    if (t = t || function() {}, l(e)) s.mapSeries(e, (function(e, t) {
                        e && e((function(e) {
                            var n = Array.prototype.slice.call(arguments, 1);
                            n.length <= 1 && (n = n[0]), t.call(null, e, n)
                        }))
                    }), t);
                    else {
                        var n = {};
                        s.eachSeries(h(e), (function(t, r) {
                            e[t]((function(e) {
                                var i = Array.prototype.slice.call(arguments, 1);
                                i.length <= 1 && (i = i[0]), n[t] = i, r(e)
                            }))
                        }), (function(e) {
                            t(e, n)
                        }))
                    }
                }, s.iterator = function(e) {
                    return function t(n) {
                        var r = function t() {
                            return e.length && e[n].apply(null, arguments), t.next()
                        };
                        return r.next = function() {
                            return n < e.length - 1 ? t(n + 1) : null
                        }, r
                    }(0)
                }, s.apply = function(e) {
                    var t = Array.prototype.slice.call(arguments, 1);
                    return function() {
                        return e.apply(null, t.concat(Array.prototype.slice.call(arguments)))
                    }
                };
                var T = function(e, t, n, r) {
                    var i = [];
                    e(t, (function(e, t) {
                        n(e, (function(e, n) {
                            i = i.concat(n || []), t(e)
                        }))
                    }), (function(e) {
                        r(e, i)
                    }))
                };
                s.concat = m(T), s.concatSeries = v(T), s.whilst = function(e, t, n) {
                    e() ? t((function(r) {
                        if (r) return n(r);
                        s.whilst(e, t, n)
                    })) : n()
                }, s.doWhilst = function(e, t, n) {
                    e((function(r) {
                        if (r) return n(r);
                        var i = Array.prototype.slice.call(arguments, 1);
                        t.apply(null, i) ? s.doWhilst(e, t, n) : n()
                    }))
                }, s.until = function(e, t, n) {
                    e() ? n() : t((function(r) {
                        if (r) return n(r);
                        s.until(e, t, n)
                    }))
                }, s.doUntil = function(e, t, n) {
                    e((function(r) {
                        if (r) return n(r);
                        var i = Array.prototype.slice.call(arguments, 1);
                        t.apply(null, i) ? n() : s.doUntil(e, t, n)
                    }))
                }, s.queue = function(e, t) {
                    function n(e, t, n, r) {
                        if (e.started || (e.started = !0), l(t) || (t = [t]), 0 == t.length) return s.setImmediate((function() {
                            e.drain && e.drain()
                        }));
                        d(t, (function(t) {
                            var i = {
                                data: t,
                                callback: "function" == typeof r ? r : null
                            };
                            n ? e.tasks.unshift(i) : e.tasks.push(i), e.saturated && e.tasks.length === e.concurrency && e.saturated(), s.setImmediate(e.process)
                        }))
                    }
                    void 0 === t && (t = 1);
                    var r = 0,
                        i = {
                            tasks: [],
                            concurrency: t,
                            saturated: null,
                            empty: null,
                            drain: null,
                            started: !1,
                            paused: !1,
                            push: function(e, t) {
                                n(i, e, !1, t)
                            },
                            kill: function() {
                                i.drain = null, i.tasks = []
                            },
                            unshift: function(e, t) {
                                n(i, e, !0, t)
                            },
                            process: function() {
                                if (!i.paused && r < i.concurrency && i.tasks.length) {
                                    var t = i.tasks.shift();
                                    i.empty && 0 === i.tasks.length && i.empty(), r += 1;
                                    var n = c((function() {
                                        r -= 1, t.callback && t.callback.apply(t, arguments), i.drain && i.tasks.length + r === 0 && i.drain(), i.process()
                                    }));
                                    e(t.data, n)
                                }
                            },
                            length: function() {
                                return i.tasks.length
                            },
                            running: function() {
                                return r
                            },
                            idle: function() {
                                return i.tasks.length + r === 0
                            },
                            pause: function() {
                                !0 !== i.paused && (i.paused = !0, i.process())
                            },
                            resume: function() {
                                !1 !== i.paused && (i.paused = !1, i.process())
                            }
                        };
                    return i
                }, s.priorityQueue = function(e, t) {
                    function n(e, t) {
                        return e.priority - t.priority
                    }
                    var r = s.queue(e, t);
                    return r.push = function(e, t, i) {
                        ! function(e, t, r, i) {
                            if (e.started || (e.started = !0), l(t) || (t = [t]), 0 == t.length) return s.setImmediate((function() {
                                e.drain && e.drain()
                            }));
                            d(t, (function(t) {
                                var o = {
                                    data: t,
                                    priority: r,
                                    callback: "function" == typeof i ? i : null
                                };
                                e.tasks.splice(function(e, t, n) {
                                    for (var r = -1, i = e.length - 1; r < i;) {
                                        var o = r + (i - r + 1 >>> 1);
                                        n(t, e[o]) >= 0 ? r = o : i = o - 1
                                    }
                                    return r
                                }(e.tasks, o, n) + 1, 0, o), e.saturated && e.tasks.length === e.concurrency && e.saturated(), s.setImmediate(e.process)
                            }))
                        }(r, e, t, i)
                    }, delete r.unshift, r
                }, s.cargo = function(e, t) {
                    var n = !1,
                        r = [],
                        i = {
                            tasks: r,
                            payload: t,
                            saturated: null,
                            empty: null,
                            drain: null,
                            drained: !0,
                            push: function(e, n) {
                                l(e) || (e = [e]), d(e, (function(e) {
                                    r.push({
                                        data: e,
                                        callback: "function" == typeof n ? n : null
                                    }), i.drained = !1, i.saturated && r.length === t && i.saturated()
                                })), s.setImmediate(i.process)
                            },
                            process: function o() {
                                if (!n) {
                                    if (0 === r.length) return i.drain && !i.drained && i.drain(), void(i.drained = !0);
                                    var a = "number" == typeof t ? r.splice(0, t) : r.splice(0, r.length),
                                        s = p(a, (function(e) {
                                            return e.data
                                        }));
                                    i.empty && i.empty(), n = !0, e(s, (function() {
                                        n = !1;
                                        var e = arguments;
                                        d(a, (function(t) {
                                            t.callback && t.callback.apply(null, e)
                                        })), o()
                                    }))
                                }
                            },
                            length: function() {
                                return r.length
                            },
                            running: function() {
                                return n
                            }
                        };
                    return i
                };
                var C = function(e) {
                    return function(t) {
                        var n = Array.prototype.slice.call(arguments, 1);
                        t.apply(null, n.concat([function(t) {
                            var n = Array.prototype.slice.call(arguments, 1);
                            "undefined" != typeof console && (t ? console.error && console.error(t) : console[e] && d(n, (function(t) {
                                console[e](t)
                            })))
                        }]))
                    }
                };
                s.log = C("log"), s.dir = C("dir"), s.memoize = function(e, t) {
                    var n = {},
                        r = {};
                    t = t || function(e) {
                        return e
                    };
                    var i = function() {
                        var i = Array.prototype.slice.call(arguments),
                            o = i.pop(),
                            a = t.apply(null, i);
                        a in n ? s.nextTick((function() {
                            o.apply(null, n[a])
                        })) : a in r ? r[a].push(o) : (r[a] = [o], e.apply(null, i.concat([function() {
                            n[a] = arguments;
                            var e = r[a];
                            delete r[a];
                            for (var t = 0, i = e.length; t < i; t++) e[t].apply(null, arguments)
                        }])))
                    };
                    return i.memo = n, i.unmemoized = e, i
                }, s.unmemoize = function(e) {
                    return function() {
                        return (e.unmemoized || e).apply(null, arguments)
                    }
                }, s.times = function(e, t, n) {
                    for (var r = [], i = 0; i < e; i++) r.push(i);
                    return s.map(r, t, n)
                }, s.timesSeries = function(e, t, n) {
                    for (var r = [], i = 0; i < e; i++) r.push(i);
                    return s.mapSeries(r, t, n)
                }, s.seq = function() {
                    var e = arguments;
                    return function() {
                        var t = this,
                            n = Array.prototype.slice.call(arguments),
                            r = n.pop();
                        s.reduce(e, n, (function(e, n, r) {
                            n.apply(t, e.concat([function() {
                                var e = arguments[0],
                                    t = Array.prototype.slice.call(arguments, 1);
                                r(e, t)
                            }]))
                        }), (function(e, n) {
                            r.apply(t, [e].concat(n))
                        }))
                    }
                }, s.compose = function() {
                    return s.seq.apply(null, Array.prototype.reverse.call(arguments))
                };
                var R = function(e, t) {
                    var n = function() {
                        var n = this,
                            r = Array.prototype.slice.call(arguments),
                            i = r.pop();
                        return e(t, (function(e, t) {
                            e.apply(n, r.concat([t]))
                        }), i)
                    };
                    if (arguments.length > 2) {
                        var r = Array.prototype.slice.call(arguments, 2);
                        return n.apply(this, r)
                    }
                    return n
                };
                s.applyEach = m(R), s.applyEachSeries = v(R), s.forever = function(e, t) {
                    ! function n(r) {
                        if (r) {
                            if (t) return t(r);
                            throw r
                        }
                        e(n)
                    }()
                }, e.exports ? e.exports = s : void 0 === (i = function() {
                    return s
                }.apply(t, [])) || (e.exports = i)
            }()
        }).call(this, n(48), n(126).setImmediate)
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            var r = n(4),
                i = n(1),
                o = n(11),
                a = n.n(o),
                s = Object(r.getLogger)(e),
                c = -1,
                u = /request id \d+.\d+ got 200/,
                l = /request errored, status: (\d+), number of errors: \d+/;
            t.a = function() {
                i.Strophe.log = function(e, t) {
                    switch (s.trace("Strophe", e, t), "string" == typeof t && -1 !== t.indexOf("Request ") && -1 !== t.indexOf("timed out (secondary), restarting") && (e = i.Strophe.LogLevel.WARN), e) {
                        case i.Strophe.LogLevel.DEBUG:
                            -1 !== c && u.test(t) && (s.debug("Reset lastErrorStatus"), c = -1);
                            break;
                        case i.Strophe.LogLevel.WARN:
                            s.warn("Strophe: ".concat(t));
                            var n = l.exec(t);
                            n && 2 === n.length && (c = parseInt(n[1], 10), s.debug("lastErrorStatus set to: ".concat(c)));
                            break;
                        case i.Strophe.LogLevel.ERROR:
                        case i.Strophe.LogLevel.FATAL:
                            t = "Strophe: ".concat(t), a.a.callErrorHandler(new Error(t)), s.error(t)
                    }
                }, i.Strophe.getLastErrorStatus = function() {
                    return c
                }, i.Strophe.getStatusString = function(e) {
                    switch (e) {
                        case i.Strophe.Status.ERROR:
                            return "ERROR";
                        case i.Strophe.Status.CONNECTING:
                            return "CONNECTING";
                        case i.Strophe.Status.CONNFAIL:
                            return "CONNFAIL";
                        case i.Strophe.Status.AUTHENTICATING:
                            return "AUTHENTICATING";
                        case i.Strophe.Status.AUTHFAIL:
                            return "AUTHFAIL";
                        case i.Strophe.Status.CONNECTED:
                            return "CONNECTED";
                        case i.Strophe.Status.DISCONNECTED:
                            return "DISCONNECTED";
                        case i.Strophe.Status.DISCONNECTING:
                            return "DISCONNECTING";
                        case i.Strophe.Status.ATTACHED:
                            return "ATTACHED";
                        default:
                            return "unknown"
                    }
                }
            }
        }).call(this, "modules/xmpp/strophe.util.js")
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            var r = n(4),
                i = n(1),
                o = n(11),
                a = n.n(o),
                s = n(34);

            function c(e) {
                return (c = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                    return typeof e
                } : function(e) {
                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                })(e)
            }

            function u(e, t) {
                for (var n = 0; n < t.length; n++) {
                    var r = t[n];
                    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                }
            }

            function l(e, t) {
                return !t || "object" !== c(t) && "function" != typeof t ? function(e) {
                    if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return e
                }(e) : t
            }

            function d(e, t, n) {
                return (d = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function(e, t, n) {
                    var r = function(e, t) {
                        for (; !Object.prototype.hasOwnProperty.call(e, t) && null !== (e = p(e)););
                        return e
                    }(e, t);
                    if (r) {
                        var i = Object.getOwnPropertyDescriptor(r, t);
                        return i.get ? i.get.call(n) : i.value
                    }
                })(e, t, n || e)
            }

            function p(e) {
                return (p = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
                    return e.__proto__ || Object.getPrototypeOf(e)
                })(e)
            }

            function h(e, t) {
                return (h = Object.setPrototypeOf || function(e, t) {
                    return e.__proto__ = t, e
                })(e, t)
            }
            var f = Object(r.getLogger)(e),
                m = 12,
                v = function(e) {
                    function t(e) {
                        var n;
                        return function(e, t) {
                            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                        }(this, t), (n = l(this, p(t).call(this))).failedPings = 0, n.xmpp = e, n.pingExecIntervals = new Array(m), n
                    }
                    var n, r, o;
                    return function(e, t) {
                        if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
                        e.prototype = Object.create(t && t.prototype, {
                            constructor: {
                                value: e,
                                writable: !0,
                                configurable: !0
                            }
                        }), t && h(e, t)
                    }(t, e), n = t, (r = [{
                        key: "init",
                        value: function(e) {
                            d(p(t.prototype), "init", this).call(this, e), i.Strophe.addNamespace("PING", "urn:xmpp:ping")
                        }
                    }, {
                        key: "ping",
                        value: function(e, t, n, r) {
                            this._addPingExecutionTimestamp();
                            var o = Object(i.$iq)({
                                type: "get",
                                to: e
                            });
                            o.c("ping", {
                                xmlns: i.Strophe.NS.PING
                            }), this.connection.sendIQ(o, t, n, r)
                        }
                    }, {
                        key: "startInterval",
                        value: function(e) {
                            var t = this,
                                n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1e4;
                            if (this.intervalId) {
                                var r = "Ping task scheduled already";
                                return a.a.callErrorHandler(new Error(r)), void f.error(r)
                            }
                            this.intervalId = window.setInterval((function() {
                                t.ping(e, (function() {
                                    t.failedPings = 0
                                }), (function(e) {
                                    t.failedPings += 1;
                                    var n = "Ping ".concat(e ? "error" : "timeout");
                                    t.failedPings >= 3 ? (a.a.callErrorHandler(new Error(n)), f.error(n, e)) : f.warn(n, e)
                                }), 15e3)
                            }), n), f.info("XMPP pings will be sent every ".concat(n, " ms"))
                        }
                    }, {
                        key: "stopInterval",
                        value: function() {
                            this.intervalId && (window.clearInterval(this.intervalId), this.intervalId = null, this.failedPings = 0, f.info("Ping interval cleared"))
                        }
                    }, {
                        key: "_addPingExecutionTimestamp",
                        value: function() {
                            this.pingExecIntervals.push((new Date).getTime()), this.pingExecIntervals.length > m && this.pingExecIntervals.shift()
                        }
                    }, {
                        key: "getPingSuspendTime",
                        value: function() {
                            var e = this.pingExecIntervals.slice();
                            e.push((new Date).getTime());
                            var t = 0,
                                n = e[0];
                            return e.forEach((function(e) {
                                var r = e - n;
                                r > t && (t = r), n = e
                            })), t -= 1e4, Math.max(t, 0)
                        }
                    }]) && u(n.prototype, r), o && u(n, o), t
                }(s.b);
            t.a = function(e) {
                i.Strophe.addConnectionPlugin("ping", new v(e))
            }
        }).call(this, "modules/xmpp/strophe.ping.js")
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            var r = n(4),
                i = n(1),
                o = n(34);

            function a(e) {
                return (a = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                    return typeof e
                } : function(e) {
                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                })(e)
            }

            function s(e, t) {
                for (var n = 0; n < t.length; n++) {
                    var r = t[n];
                    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                }
            }

            function c(e, t) {
                return !t || "object" !== a(t) && "function" != typeof t ? function(e) {
                    if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return e
                }(e) : t
            }

            function u(e, t, n) {
                return (u = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function(e, t, n) {
                    var r = function(e, t) {
                        for (; !Object.prototype.hasOwnProperty.call(e, t) && null !== (e = l(e)););
                        return e
                    }(e, t);
                    if (r) {
                        var i = Object.getOwnPropertyDescriptor(r, t);
                        return i.get ? i.get.call(n) : i.value
                    }
                })(e, t, n || e)
            }

            function l(e) {
                return (l = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
                    return e.__proto__ || Object.getPrototypeOf(e)
                })(e)
            }

            function d(e, t) {
                return (d = Object.setPrototypeOf || function(e, t) {
                    return e.__proto__ = t, e
                })(e, t)
            }
            var p = Object(r.getLogger)(e),
                h = function(e) {
                    function t() {
                        return function(e, t) {
                            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                        }(this, t), c(this, l(t).apply(this, arguments))
                    }
                    var n, r, o;
                    return function(e, t) {
                        if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
                        e.prototype = Object.create(t && t.prototype, {
                            constructor: {
                                value: e,
                                writable: !0,
                                configurable: !0
                            }
                        }), t && d(e, t)
                    }(t, e), n = t, (r = [{
                        key: "init",
                        value: function(e) {
                            u(l(t.prototype), "init", this).call(this, e), this.connection.addHandler(this.onRayo.bind(this), "urn:xmpp:rayo:1", "iq", "set", null, null)
                        }
                    }, {
                        key: "onRayo",
                        value: function(e) {
                            p.info("Rayo IQ", e)
                        }
                    }, {
                        key: "dial",
                        value: function(e, t, n, r, o) {
                            var a = this;
                            return new Promise((function(s, c) {
                                if (o) {
                                    var u = Object(i.$iq)({
                                        type: "set",
                                        to: o
                                    });
                                    u.c("dial", {
                                        xmlns: "urn:xmpp:rayo:1",
                                        to: e,
                                        from: t
                                    }), u.c("header", {
                                        name: "JvbRoomName",
                                        value: n
                                    }).up(), r && r.length && u.c("header", {
                                        name: "JvbRoomPassword",
                                        value: r
                                    }).up(), a.connection.sendIQ(u, (function(e) {
                                        p.info("Dial result ", e);
                                        var t = $(e).find("ref").attr("uri");
                                        a.callResource = t.substr("xmpp:".length), p.info("Received call resource: ".concat(a.callResource)), s()
                                    }), (function(e) {
                                        p.info("Dial error ", e), c(e)
                                    }))
                                } else c(new Error("Internal error!"))
                            }))
                        }
                    }, {
                        key: "hangup",
                        value: function() {
                            var e = this;
                            return new Promise((function(t, n) {
                                if (!e.callResource) return n(new Error("No call in progress")), void p.warn("No call in progress");
                                var r = Object(i.$iq)({
                                    type: "set",
                                    to: e.callResource
                                });
                                r.c("hangup", {
                                    xmlns: "urn:xmpp:rayo:1"
                                }), e.connection.sendIQ(r, (function(n) {
                                    p.info("Hangup result ", n), e.callResource = null, t()
                                }), (function(t) {
                                    p.info("Hangup error ", t), e.callResource = null, n(new Error("Hangup error "))
                                }))
                            }))
                        }
                    }]) && s(n.prototype, r), o && s(n, o), t
                }(o.b);
            t.a = function() {
                i.Strophe.addConnectionPlugin("rayo", new h)
            }
        }).call(this, "modules/xmpp/strophe.rayo.js")
    }, function(e, t, n) {
        "use strict";
        var r = n(1);

        function i(e) {
            return (i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                return typeof e
            } : function(e) {
                return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
            })(e)
        }

        function o(e, t) {
            for (var n = 0; n < t.length; n++) {
                var r = t[n];
                r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
            }
        }

        function a(e, t) {
            return !t || "object" !== i(t) && "function" != typeof t ? function(e) {
                if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return e
            }(e) : t
        }

        function s(e, t, n) {
            return (s = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function(e, t, n) {
                var r = function(e, t) {
                    for (; !Object.prototype.hasOwnProperty.call(e, t) && null !== (e = c(e)););
                    return e
                }(e, t);
                if (r) {
                    var i = Object.getOwnPropertyDescriptor(r, t);
                    return i.get ? i.get.call(n) : i.value
                }
            })(e, t, n || e)
        }

        function c(e) {
            return (c = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
                return e.__proto__ || Object.getPrototypeOf(e)
            })(e)
        }

        function u(e, t) {
            return (u = Object.setPrototypeOf || function(e, t) {
                return e.__proto__ = t, e
            })(e, t)
        }
        var l = function(e) {
            function t() {
                var e;
                return function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, t), (e = a(this, c(t).call(this))).log = [], e
            }
            var n, r, i;
            return function(e, t) {
                if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
                e.prototype = Object.create(t && t.prototype, {
                    constructor: {
                        value: e,
                        writable: !0,
                        configurable: !0
                    }
                }), t && u(e, t)
            }(t, e), n = t, (r = [{
                key: "init",
                value: function(e) {
                    s(c(t.prototype), "init", this).call(this, e), this.connection.rawInput = this.logIncoming.bind(this), this.connection.rawOutput = this.logOutgoing.bind(this)
                }
            }, {
                key: "logIncoming",
                value: function(e) {
                    this.log.push([(new Date).getTime(), "incoming", e])
                }
            }, {
                key: "logOutgoing",
                value: function(e) {
                    this.log.push([(new Date).getTime(), "outgoing", e])
                }
            }]) && o(n.prototype, r), i && o(n, i), t
        }(n(34).b);
        t.a = function() {
            r.Strophe.addConnectionPlugin("logger", new l)
        }
    }, function(e, t, n) {
        "use strict";

        function r(e, t) {
            for (var n = 0; n < t.length; n++) {
                var r = t[n];
                r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
            }
        }
        n.d(t, "a", (function() {
            return i
        }));
        var i = function() {
            function e() {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this._nextValidRid = null, this._lastSuccess = null
            }
            var t, n, i;
            return t = e, (n = [{
                key: "startTracking",
                value: function(e) {
                    var t = this;
                    e.nextValidRid = function(e) {
                        t._nextValidRid === e - 1 && (t._lastSuccess = (new Date).getTime()), t._nextValidRid = e
                    }
                }
            }, {
                key: "getTimeSinceLastSuccess",
                value: function() {
                    return this._lastSuccess ? (new Date).getTime() - this._lastSuccess : null
                }
            }]) && r(t.prototype, n), i && r(t, i), e
        }()
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return y
            }));
            var r = n(1),
                i = n(0),
                o = n.n(i),
                a = n(24);

            function s(e) {
                return (s = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                    return typeof e
                } : function(e) {
                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                })(e)
            }

            function c(e, t) {
                for (var n = 0; n < t.length; n++) {
                    var r = t[n];
                    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                }
            }

            function u(e) {
                return (u = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
                    return e.__proto__ || Object.getPrototypeOf(e)
                })(e)
            }

            function l(e, t) {
                return (l = Object.setPrototypeOf || function(e, t) {
                    return e.__proto__ = t, e
                })(e, t)
            }

            function d(e) {
                if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return e
            }
            var p = n(4).getLogger(e),
                h = ["category", "type", "lang", "name"],
                f = ["category", "type", "lang"];

            function m(e, t) {
                var n = 0;
                return f.some((function(r) {
                    return 0 !== (n = e[r] > t[r] ? 1 : e[r] < t[r] && -1)
                })), n
            }

            function v(e, t) {
                var n = e.sort(m).reduce((function(e, t) {
                        return "".concat(h.reduce((function(e, n, r) {
                            return e + (0 === r ? "" : "/") + (t[n] ? t[n] : "")
                        }), ""), "<")
                    }), ""),
                    i = t.sort().reduce((function(e, t) {
                        return "".concat(e + t, "<")
                    }), "");
                return Object(r.b64_sha1)(n + i)
            }
            var y = function(e) {
                function t() {
                    var e, n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                        i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "http://jitsi.org/jitsimeet";
                    if (function(e, t) {
                            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                        }(this, t), (e = function(e, t) {
                            return !t || "object" !== s(t) && "function" != typeof t ? d(e) : t
                        }(this, u(t).call(this))).node = i, e.disco = n.disco, !e.disco) throw new Error("Missing strophe-plugins (disco plugin is required)!");
                    e.versionToCapabilities = Object.create(null), e.jidToVersion = Object.create(null), e.version = "", e.rooms = new Set;
                    var a = n.emuc;
                    return a.addListener(o.a.EMUC_ROOM_ADDED, (function(t) {
                        return e._addChatRoom(t)
                    })), a.addListener(o.a.EMUC_ROOM_REMOVED, (function(t) {
                        return e._removeChatRoom(t)
                    })), Object.keys(a.rooms).forEach((function(t) {
                        e._addChatRoom(a.rooms[t])
                    })), r.Strophe.addNamespace("CAPS", "http://jabber.org/protocol/caps"), e.disco.addFeature(r.Strophe.NS.CAPS), n.addHandler(e._handleCaps.bind(d(d(e))), r.Strophe.NS.CAPS), e._onMucMemberLeft = e._removeJidToVersionEntry.bind(d(d(e))), e
                }
                var n, i, a;
                return function(e, t) {
                    if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
                    e.prototype = Object.create(t && t.prototype, {
                        constructor: {
                            value: e,
                            writable: !0,
                            configurable: !0
                        }
                    }), t && l(e, t)
                }(t, e), n = t, (i = [{
                    key: "addFeature",
                    value: function(e) {
                        var t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                        this.disco.addFeature(e), this._generateVersion(), t && this.submit()
                    }
                }, {
                    key: "removeFeature",
                    value: function(e) {
                        var t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                        this.disco.removeFeature(e), this._generateVersion(), t && this.submit()
                    }
                }, {
                    key: "submit",
                    value: function() {
                        this.rooms.forEach((function(e) {
                            return e.sendPresence()
                        }))
                    }
                }, {
                    key: "getFeatures",
                    value: function(e) {
                        var t = this,
                            n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 5e3,
                            r = e in this.jidToVersion ? this.jidToVersion[e] : null;
                        if (!(r && r.version in this.versionToCapabilities)) {
                            var i = r ? "".concat(r.node, "#").concat(r.version) : null;
                            return this._getDiscoInfo(e, i, n).then((function(e) {
                                var n = e.features,
                                    o = e.identities;
                                if (r) {
                                    var a = v(Array.from(o), Array.from(n)),
                                        s = "".concat(r.node, "#").concat(a);
                                    return s === i ? (t.versionToCapabilities[s] = n, n) : t.versionToCapabilities[s] ? t.versionToCapabilities[s] : (p.error("Expected node ".concat(i, " but received ").concat(s)), Promise.reject("Feature version mismatch"))
                                }
                            }))
                        }
                        return Promise.resolve(this.versionToCapabilities[r.version])
                    }
                }, {
                    key: "getFeaturesAndIdentities",
                    value: function(e) {
                        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 5e3;
                        return this._getDiscoInfo(e, null, t)
                    }
                }, {
                    key: "_getDiscoInfo",
                    value: function(e, t, n) {
                        var r = this;
                        return new Promise((function(i, o) {
                            return r.disco.info(e, t, (function(e) {
                                var t = new Set,
                                    n = new Set;
                                $(e).find(">query>feature").each((function(e, n) {
                                    return t.add(n.getAttribute("var"))
                                })), $(e).find(">query>identity").each((function(e, t) {
                                    return n.add({
                                        type: t.getAttribute("type"),
                                        name: t.getAttribute("name"),
                                        category: t.getAttribute("category")
                                    })
                                })), i({
                                    features: t,
                                    identities: n
                                })
                            }), o, n)
                        }))
                    }
                }, {
                    key: "_addChatRoom",
                    value: function(e) {
                        this.rooms.add(e), e.addListener(o.a.MUC_MEMBER_LEFT, this._onMucMemberLeft), this._fixChatRoomPresenceMap(e)
                    }
                }, {
                    key: "_removeChatRoom",
                    value: function(e) {
                        this.rooms.delete(e), e.removeListener(o.a.MUC_MEMBER_LEFT, this._onMucMemberLeft)
                    }
                }, {
                    key: "_fixChatRoomPresenceMap",
                    value: function(e) {
                        e.addToPresence("c", {
                            attributes: {
                                xmlns: r.Strophe.NS.CAPS,
                                hash: "sha-1",
                                node: this.node,
                                ver: this.version
                            }
                        })
                    }
                }, {
                    key: "_notifyVersionChanged",
                    value: function() {
                        var e = this;
                        this.rooms.forEach((function(t) {
                            return e._fixChatRoomPresenceMap(t)
                        }))
                    }
                }, {
                    key: "_generateVersion",
                    value: function() {
                        this.version = v(this.disco._identities, this.disco._features), this._notifyVersionChanged()
                    }
                }, {
                    key: "_handleCaps",
                    value: function(e) {
                        var t = e.getAttribute("from"),
                            n = e.querySelector("c"),
                            r = n.getAttribute("ver"),
                            i = n.getAttribute("node"),
                            a = this.jidToVersion[t];
                        return this.jidToVersion[t] = {
                            version: r,
                            node: i
                        }, a && a.version !== r && this.eventEmitter.emit(o.a.PARTCIPANT_FEATURES_CHANGED, t), !0
                    }
                }, {
                    key: "_removeJidToVersionEntry",
                    value: function(e) {
                        e in this.jidToVersion && delete this.jidToVersion[e]
                    }
                }]) && c(n.prototype, i), a && c(n, a), t
            }(a.a)
        }).call(this, "modules/xmpp/Caps.js")
    }, function(e, t, n) {
        "use strict";
        n.d(t, "a", (function() {
            return s
        }));
        var r = n(2),
            i = n(8),
            o = n.n(i);

        function a(e, t) {
            for (var n = 0; n < t.length; n++) {
                var r = t[n];
                r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
            }
        }
        var s = function() {
            function e(t) {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this.conference = t, t.addEventListener(r.TRACK_AUDIO_LEVEL_CHANGED, this._audioLevel.bind(this)), this.myUserID = this.conference.myUserId()
            }
            var t, n, i;
            return t = e, (n = [{
                key: "_audioLevel",
                value: function(e, t) {
                    !this.conference.isP2PActive() || t <= .6 || e === this.myUserID && this.conference.getLocalAudioTrack().isMuted() || this.conference.rtc.eventEmitter.emit(o.a.DOMINANT_SPEAKER_CHANGED, e)
                }
            }]) && a(t.prototype, n), i && a(t, i), e
        }()
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return p
            }));
            var r = n(4),
                i = n(8),
                o = n.n(i),
                a = n(7),
                s = n(5),
                c = n(11),
                u = n.n(c);

            function l(e, t) {
                for (var n = 0; n < t.length; n++) {
                    var r = t[n];
                    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                }
            }
            var d = Object(r.getLogger)(e),
                p = function() {
                    function e(t, n, r) {
                        if (function(e, t) {
                                if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                            }(this, e), !t && !n) throw new TypeError("At least peerconnection or wsUrl must be given");
                        if (t && n) throw new TypeError("Just one of peerconnection or wsUrl must be given");
                        if (t ? d.debug("constructor() with peerconnection") : d.debug('constructor() with wsUrl:"'.concat(n, '"')), this._channel = null, this._eventEmitter = r, this._mode = null, this._areRetriesEnabled = !1, this._closedFromClient = !1, t) {
                            var i = t.createDataChannel("JVB data channel", {
                                protocol: "http://jitsi.org/protocols/colibri"
                            });
                            this._handleChannel(i), this._mode = "datachannel"
                        } else n && (this._areRetriesEnabled = !0, this._wsUrl = n, this._initWebSocket())
                    }
                    var t, n, r;
                    return t = e, (n = [{
                        key: "_initWebSocket",
                        value: function() {
                            var e = new WebSocket(this._wsUrl);
                            this._handleChannel(e), this._mode = "websocket"
                        }
                    }, {
                        key: "_startConnectionRetries",
                        value: function() {
                            var e = this,
                                t = 1;
                            this._retryTimeout = setTimeout((function n() {
                                e.isOpen() || (e._initWebSocket(e._wsUrl), t = Math.min(2 * t, 60), e._retryTimeout = setTimeout(n, 1e3 * t))
                            }), 1e3 * t)
                        }
                    }, {
                        key: "_stopConnectionRetries",
                        value: function() {
                            this._retryTimeout && (clearTimeout(this._retryTimeout), this._retryTimeout = void 0)
                        }
                    }, {
                        key: "_retryWebSocketConnection",
                        value: function(e) {
                            var t = this;
                            if (this._areRetriesEnabled) {
                                var n = e.code,
                                    r = e.reason;
                                s.a.sendAnalytics(Object(a.y)(n, r)), this._areRetriesEnabled = !1, this._eventEmitter.once(o.a.DATA_CHANNEL_OPEN, (function() {
                                    t._stopConnectionRetries(), t._areRetriesEnabled = !0
                                })), this._startConnectionRetries()
                            }
                        }
                    }, {
                        key: "close",
                        value: function() {
                            if (this._closedFromClient = !0, this._stopConnectionRetries(), this._areRetriesEnabled = !1, this._channel) {
                                try {
                                    this._channel.close()
                                } catch (e) {}
                                this._channel = null
                            }
                        }
                    }, {
                        key: "isOpen",
                        value: function() {
                            return this._channel && ("open" === this._channel.readyState || this._channel.readyState === WebSocket.OPEN)
                        }
                    }, {
                        key: "sendMessage",
                        value: function(e, t) {
                            this._send({
                                colibriClass: "EndpointMessage",
                                msgPayload: t,
                                to: e
                            })
                        }
                    }, {
                        key: "sendSetLastNMessage",
                        value: function(e) {
                            var t = {
                                colibriClass: "LastNChangedEvent",
                                lastN: e
                            };
                            this._send(t), d.log("Channel lastN set to: ".concat(e))
                        }
                    }, {
                        key: "sendPinnedEndpointMessage",
                        value: function(e) {
                            d.log("sending pinned changed notification to the bridge for endpoint ", e), this._send({
                                colibriClass: "PinnedEndpointChangedEvent",
                                pinnedEndpoint: e || null
                            })
                        }
                    }, {
                        key: "sendSelectedEndpointsMessage",
                        value: function(e) {
                            d.log("sending selected changed notification to the bridge for endpoints", e), this._send({
                                colibriClass: "SelectedEndpointsChangedEvent",
                                selectedEndpoints: e
                            })
                        }
                    }, {
                        key: "sendReceiverVideoConstraintMessage",
                        value: function(e) {
                            d.log("sending a ReceiverVideoConstraint message with " + "a maxFrameHeight of ".concat(e, " pixels")), this._send({
                                colibriClass: "ReceiverVideoConstraint",
                                maxFrameHeight: e
                            })
                        }
                    }, {
                        key: "_handleChannel",
                        value: function(e) {
                            var t = this,
                                n = this._eventEmitter;
                            e.onopen = function() {
                                d.info("".concat(t._mode, " channel opened")), n.emit(o.a.DATA_CHANNEL_OPEN)
                            }, e.onerror = function(e) {
                                "websocket" !== t._mode && d.error("Channel error: ".concat(e.message))
                            }, e.onmessage = function(e) {
                                var t, r = e.data;
                                try {
                                    t = JSON.parse(r)
                                } catch (e) {
                                    return u.a.callErrorHandler(e), void d.error("Failed to parse channel message as JSON: ", r, e)
                                }
                                var i = t.colibriClass;
                                switch (i) {
                                    case "DominantSpeakerEndpointChangeEvent":
                                        var a = t.dominantSpeakerEndpoint;
                                        d.info("Channel new dominant speaker event: ", a), n.emit(o.a.DOMINANT_SPEAKER_CHANGED, a);
                                        break;
                                    case "EndpointConnectivityStatusChangeEvent":
                                        var s = t.endpoint,
                                            c = "true" === t.active;
                                        d.info("Endpoint connection status changed: ".concat(s, " active ? ").concat(c)), n.emit(o.a.ENDPOINT_CONN_STATUS_CHANGED, s, c);
                                        break;
                                    case "EndpointMessage":
                                        n.emit(o.a.ENDPOINT_MESSAGE_RECEIVED, t.from, t.msgPayload);
                                        break;
                                    case "LastNEndpointsChangeEvent":
                                        var l = t.lastNEndpoints;
                                        d.info("Channel new last-n event: ", l, t), n.emit(o.a.LASTN_ENDPOINT_CHANGED, l, t);
                                        break;
                                    case "SelectedUpdateEvent":
                                        var p = t.isSelected;
                                        d.info("SelectedUpdateEvent isSelected? ".concat(p)), n.emit(o.a.IS_SELECTED_CHANGED, p);
                                        break;
                                    default:
                                        d.debug("Channel JSON-formatted message: ", t), n.emit("rtc.datachannel.".concat(i), t)
                                }
                            }, e.onclose = function(e) {
                                d.info("Channel closed by ".concat(t._closedFromClient ? "client" : "server")), "websocket" === t._mode && (t._closedFromClient || (d.error("Channel closed: ".concat(e.code, " ").concat(e.reason)), t._retryWebSocketConnection(e))), t._channel = null
                            }, this._channel = e
                        }
                    }, {
                        key: "_send",
                        value: function(e) {
                            var t = this._channel;
                            if (!this.isOpen()) throw d.error("Bridge Channel send: no opened channel."), new Error("No opened channel");
                            t.send(JSON.stringify(e))
                        }
                    }, {
                        key: "mode",
                        get: function() {
                            return this._mode
                        }
                    }]) && l(t.prototype, n), r && l(t, r), e
                }()
        }).call(this, "modules/RTC/BridgeChannel.js")
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return w
            }));
            var r = n(4),
                i = n(22),
                o = n.n(i),
                a = n(11),
                s = n(97),
                c = n(9),
                u = n(98),
                l = n(13),
                d = n(10),
                p = n(3),
                h = n(8),
                f = n.n(h),
                m = n(99),
                v = n(18),
                y = n(100),
                g = n(26),
                _ = n(6),
                S = n(37);

            function b(e) {
                return function(e) {
                    if (Array.isArray(e)) {
                        for (var t = 0, n = new Array(e.length); t < e.length; t++) n[t] = e[t];
                        return n
                    }
                }(e) || function(e) {
                    if (Symbol.iterator in Object(e) || "[object Arguments]" === Object.prototype.toString.call(e)) return Array.from(e)
                }(e) || function() {
                    throw new TypeError("Invalid attempt to spread non-iterable instance")
                }()
            }

            function E(e) {
                return (E = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                    return typeof e
                } : function(e) {
                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                })(e)
            }
            var T = Object(r.getLogger)(e),
                C = 3,
                R = ["1", "2", "3"],
                A = [2e5, 7e5, 25e5];

            function w(e, t, r, i, o, a, s) {
                var c = this;
                this.audioTransferActive = !(!0 === s.startSilent), this._dtmfSender = void 0, this._dtmfTonesQueue = [], this.videoTransferActive = !0, this.rtc = e, this.id = t, this.isP2P = a, this.remoteTracks = new Map, this.localTracks = new Map, this._addedStreams = [], this.localSSRCs = new Map, this.localUfrag = null, this.remoteUfrag = null, this.signalingLayer = r, this._peerVideoTypeChanged = this._peerVideoTypeChanged.bind(this), this.signalingLayer.on(S.b, this._peerVideoTypeChanged), this._peerMutedChanged = this._peerMutedChanged.bind(this), this.signalingLayer.on(S.a, this._peerMutedChanged), this.options = s, this.peerconnection = new d.a.RTCPeerConnectionType(i, o), this.updateLog = [], this.stats = {}, this.statsinterval = null, this.maxstats = s.maxstats;
                var l = n(141).Interop;
                this.interop = new l;
                var p = n(145);
                this.simulcast = new p({
                    numOfLayers: C,
                    explodeRemoteSimulcast: !1
                }), this.sdpConsistency = new y.a(this.toString()), this.localSdpMunger = new u.a(this), this.eventEmitter = e.eventEmitter, this.rtxModifier = new m.a, this.trace = function(e, t) {
                    T.debug(e, t), c.updateLog.push({
                        time: new Date,
                        type: e,
                        value: t || ""
                    })
                }, this.onicecandidate = null, this.peerconnection.onicecandidate = function(e) {
                    c.trace("onicecandidate", JSON.stringify(e.candidate, null, " ")), null !== c.onicecandidate && c.onicecandidate(e)
                }, this.peerconnection.onaddstream = function(e) {
                    return c._remoteStreamAdded(e.stream)
                }, this.peerconnection.onremovestream = function(e) {
                    return c._remoteStreamRemoved(e.stream)
                }, this.onsignalingstatechange = null, this.peerconnection.onsignalingstatechange = function(e) {
                    c.trace("onsignalingstatechange", c.signalingState), null !== c.onsignalingstatechange && c.onsignalingstatechange(e)
                }, this.oniceconnectionstatechange = null, this.peerconnection.oniceconnectionstatechange = function(e) {
                    c.trace("oniceconnectionstatechange", c.iceConnectionState), null !== c.oniceconnectionstatechange && c.oniceconnectionstatechange(e)
                }, this.onnegotiationneeded = null, this.peerconnection.onnegotiationneeded = function(e) {
                    c.trace("onnegotiationneeded"), null !== c.onnegotiationneeded && c.onnegotiationneeded(e)
                }, this.ondatachannel = null, this.peerconnection.ondatachannel = function(e) {
                    c.trace("ondatachannel"), null !== c.ondatachannel && c.ondatachannel(e)
                }, this.maxstats && (this.statsinterval = window.setInterval((function() {
                    c.getStats((function(e) {
                        if (e.result && "function" == typeof e.result)
                            for (var t = e.result(), n = function(e) {
                                    var n = t[e];
                                    n.names().forEach((function(e) {
                                        c._processStat(n, e, n.stat(e))
                                    }))
                                }, r = 0; r < t.length; ++r) n(r);
                        else e.forEach((function(e) {
                            return c._processStat(e, "", e)
                        }))
                    }), (function() {}))
                }), 1e3)), T.info("Create new ".concat(this))
            }
            w.prototype._processStat = function(e, t, n) {
                var r = "".concat(e.id, "-").concat(t),
                    i = this.stats[r],
                    o = new Date;
                i || (this.stats[r] = i = {
                    startTime: o,
                    endTime: o,
                    values: [],
                    times: []
                }), i.values.push(n), i.times.push(o.getTime()), i.values.length > this.maxstats && (i.values.shift(), i.times.shift()), i.endTime = o
            };
            var k = function(e) {
                return null == e ? "" : "type: ".concat(e.type, "\r\n").concat(e.sdp)
            };
            w.prototype.getConnectionState = function() {
                var e = this.peerconnection.iceConnectionState;
                return "completed" === e ? "connected" : e
            }, w.prototype._getDesiredMediaDirection = function(e) {
                var t = !0;
                return e === c.a ? t = this.audioTransferActive : e === c.b && (t = this.videoTransferActive), t ? this.hasAnyTracksOfType(e) ? "sendrecv" : "recvonly" : "inactive"
            }, w.prototype.isSimulcastOn = function() {
                return !this.options.disableSimulcast && p.a.supportsSimulcast() && (!p.a.isFirefox() || this.options.enableFirefoxSimulcast)
            }, w.prototype._peerVideoTypeChanged = function(e, t) {
                if (e) {
                    var n = this.getRemoteTracks(e, c.b);
                    n.length && n[0]._setVideoType(t)
                } else T.error("No endpointID on peerVideoTypeChanged ".concat(this))
            }, w.prototype._peerMutedChanged = function(e, t, n) {
                if (e) {
                    var r = this.getRemoteTracks(e, t);
                    r.length && r[0].setMute(n)
                } else T.error("On peerMuteChanged - no endpoint ID")
            }, w.prototype.getLocalTracks = function(e) {
                var t = Array.from(this.localTracks.values());
                return void 0 !== e && (t = t.filter((function(t) {
                    return t.getType() === e
                }))), t
            }, w.prototype.hasAnyTracksOfType = function(e) {
                if (!e) throw new Error('"mediaType" is required');
                return this.getLocalTracks(e).length > 0
            }, w.prototype.getRemoteTracks = function(e, t) {
                var n = [],
                    r = e ? [e] : this.remoteTracks.keys(),
                    i = !0,
                    o = !1,
                    a = void 0;
                try {
                    for (var s, c = r[Symbol.iterator](); !(i = (s = c.next()).done); i = !0) {
                        var u = s.value,
                            l = this.remoteTracks.get(u);
                        if (l) {
                            var d = !0,
                                p = !1,
                                h = void 0;
                            try {
                                for (var f, m = l.keys()[Symbol.iterator](); !(d = (f = m.next()).done); d = !0) {
                                    var v = f.value;
                                    if (!t || t === v) {
                                        var y = l.get(v);
                                        y && n.push(y)
                                    }
                                }
                            } catch (e) {
                                p = !0, h = e
                            } finally {
                                try {
                                    d || null == m.return || m.return()
                                } finally {
                                    if (p) throw h
                                }
                            }
                        }
                    }
                } catch (e) {
                    o = !0, a = e
                } finally {
                    try {
                        i || null == c.return || c.return()
                    } finally {
                        if (o) throw a
                    }
                }
                return n
            }, w.prototype.getTrackBySSRC = function(e) {
                if ("number" != typeof e) throw new Error("SSRC ".concat(e, " is not a number"));
                var t = !0,
                    n = !1,
                    r = void 0;
                try {
                    for (var i, o = this.localTracks.values()[Symbol.iterator](); !(t = (i = o.next()).done); t = !0) {
                        var a = i.value;
                        if (this.getLocalSSRC(a) === e) return a
                    }
                } catch (e) {
                    n = !0, r = e
                } finally {
                    try {
                        t || null == o.return || o.return()
                    } finally {
                        if (n) throw r
                    }
                }
                var s = !0,
                    c = !1,
                    u = void 0;
                try {
                    for (var l, d = this.getRemoteTracks()[Symbol.iterator](); !(s = (l = d.next()).done); s = !0) {
                        var p = l.value;
                        if (p.getSSRC() === e) return p
                    }
                } catch (e) {
                    c = !0, u = e
                } finally {
                    try {
                        s || null == d.return || d.return()
                    } finally {
                        if (c) throw u
                    }
                }
                return null
            }, w.prototype.getSsrcByTrackId = function(e) {
                var t = function(t) {
                        return t.getTrack().id === e
                    },
                    n = this.getLocalTracks().find(t);
                if (n) return this.getLocalSSRC(n);
                var r = this.getRemoteTracks().find(t);
                return r ? r.getSSRC() : null
            }, w.prototype._remoteStreamAdded = function(e) {
                var t = this,
                    n = l.a.getStreamID(e);
                if (l.a.isUserStreamById(n)) {
                    (p.a.isChromiumBased() || p.a.isEdge()) && (e.onaddtrack = function(n) {
                        t._remoteTrackAdded(e, n.track)
                    }, e.onremovetrack = function(n) {
                        t._remoteTrackRemoved(e, n.track)
                    });
                    var r = e.getAudioTracks(),
                        i = !0,
                        o = !1,
                        a = void 0;
                    try {
                        for (var s, c = r[Symbol.iterator](); !(i = (s = c.next()).done); i = !0) {
                            var u = s.value;
                            this._remoteTrackAdded(e, u)
                        }
                    } catch (e) {
                        o = !0, a = e
                    } finally {
                        try {
                            i || null == c.return || c.return()
                        } finally {
                            if (o) throw a
                        }
                    }
                    var d = e.getVideoTracks(),
                        h = !0,
                        f = !1,
                        m = void 0;
                    try {
                        for (var v, y = d[Symbol.iterator](); !(h = (v = y.next()).done); h = !0) {
                            var g = v.value;
                            this._remoteTrackAdded(e, g)
                        }
                    } catch (e) {
                        f = !0, m = e
                    } finally {
                        try {
                            h || null == y.return || y.return()
                        } finally {
                            if (f) throw m
                        }
                    }
                } else T.info("".concat(this, " ignored remote 'stream added' event for non-user stream") + "id: ".concat(n))
            }, w.prototype._remoteTrackAdded = function(e, t) {
                var n = l.a.getStreamID(e),
                    r = t.kind;
                if (T.info("".concat(this, " remote track added:"), n, r), r) {
                    var i = new v.a(this.remoteDescription.sdp).media.filter((function(e) {
                        return e.startsWith("m=".concat(r))
                    }));
                    if (i.length) {
                        var o = _.a.findLines(i[0], "a=ssrc:");
                        if ((o = o.filter((function(e) {
                                return -1 !== e.indexOf("msid:".concat(n))
                            }))).length) {
                            var s = o[0].substring(7).split(" ")[0],
                                c = Number(s),
                                u = this.signalingLayer.getSSRCOwner(c);
                            if (isNaN(c) || c < 0) a.callErrorHandler(new Error("Invalid SSRC: ".concat(s, " for remote track, msid: ").concat(n, " media type: ").concat(r)));
                            else if (u) {
                                T.log("".concat(this, " associated ssrc"), u, c);
                                var d = this.signalingLayer.getPeerMediaInfo(u, r);
                                if (d) {
                                    var p = d.muted,
                                        h = d.videoType;
                                    this._createRemoteTrack(u, e, t, r, h, c, p)
                                } else a.callErrorHandler(new Error("".concat(this, ": no peer media info available for ").concat(u)))
                            } else a.callErrorHandler(new Error("No SSRC owner known for: ".concat(c, " for remote track, msid: ").concat(n, " media type: ").concat(r)))
                        } else a.callErrorHandler(new Error("No SSRC lines for streamId ".concat(n, " for remote track, media type: ").concat(r)))
                    } else a.callErrorHandler(new Error("No media lines for type ".concat(r, " found in remote SDP for remote track: ").concat(n)))
                } else a.callErrorHandler(new Error("MediaType undefined for remote track, stream id: ".concat(n)))
            }, w.prototype._createRemoteTrack = function(e, t, n, r, i, o, a) {
                var c = this.remoteTracks.get(e);
                c || (c = new Map, this.remoteTracks.set(e, c));
                var u = c.get(r);
                if (u && u.getTrack() === n) T.info("".concat(this, " ignored duplicated remote track added event for: ") + "".concat(e, ", ").concat(r));
                else {
                    u && T.error("".concat(this, " overwriting remote track for") + "".concat(e, " ").concat(r));
                    var l = new s.a(this.rtc, this.rtc.conference, e, t, n, r, i, o, a, this.isP2P);
                    c.set(r, l), this.eventEmitter.emit(f.a.REMOTE_TRACK_ADDED, l)
                }
            }, w.prototype._remoteStreamRemoved = function(e) {
                if (l.a.isUserStream(e)) {
                    var t = e.getVideoTracks(),
                        n = !0,
                        r = !1,
                        i = void 0;
                    try {
                        for (var o, a = t[Symbol.iterator](); !(n = (o = a.next()).done); n = !0) {
                            var s = o.value;
                            this._remoteTrackRemoved(e, s)
                        }
                    } catch (e) {
                        r = !0, i = e
                    } finally {
                        try {
                            n || null == a.return || a.return()
                        } finally {
                            if (r) throw i
                        }
                    }
                    var c = e.getAudioTracks(),
                        u = !0,
                        d = !1,
                        p = void 0;
                    try {
                        for (var h, f = c[Symbol.iterator](); !(u = (h = f.next()).done); u = !0) {
                            var m = h.value;
                            this._remoteTrackRemoved(e, m)
                        }
                    } catch (e) {
                        d = !0, p = e
                    } finally {
                        try {
                            u || null == f.return || f.return()
                        } finally {
                            if (d) throw p
                        }
                    }
                } else {
                    var v = l.a.getStreamID(e);
                    T.info("Ignored remote 'stream removed' event for non-user stream ".concat(v))
                }
            }, w.prototype._remoteTrackRemoved = function(e, t) {
                var n = l.a.getStreamID(e),
                    r = t && l.a.getTrackID(t);
                T.info("".concat(this, " - remote track removed: ").concat(n, ", ").concat(r)), n ? r ? this._removeRemoteTrackById(n, r) || T.warn("".concat(this, " Removed track not found for msid: ").concat(n, ",\n             track id: ").concat(r)) : a.callErrorHandler(new Error("".concat(this, " remote track removal failed - no track ID"))) : a.callErrorHandler(new Error("".concat(this, " remote track removal failed - no stream ID")))
            }, w.prototype._getRemoteTrackById = function(e, t) {
                var n = !0,
                    r = !1,
                    i = void 0;
                try {
                    for (var o, a = this.remoteTracks.values()[Symbol.iterator](); !(n = (o = a.next()).done); n = !0) {
                        var s = o.value,
                            c = !0,
                            u = !1,
                            l = void 0;
                        try {
                            for (var d, p = s.values()[Symbol.iterator](); !(c = (d = p.next()).done); c = !0) {
                                var h = d.value;
                                if (h.getStreamId() == e && h.getTrackId() == t) return h
                            }
                        } catch (e) {
                            u = !0, l = e
                        } finally {
                            try {
                                c || null == p.return || p.return()
                            } finally {
                                if (u) throw l
                            }
                        }
                    }
                } catch (e) {
                    r = !0, i = e
                } finally {
                    try {
                        n || null == a.return || a.return()
                    } finally {
                        if (r) throw i
                    }
                }
            }, w.prototype.removeRemoteTracks = function(e) {
                var t = [],
                    n = this.remoteTracks.get(e);
                if (n) {
                    var r = n.get(c.a),
                        i = n.get(c.b);
                    r && t.push(r), i && t.push(i), this.remoteTracks.delete(e)
                }
                return T.debug("".concat(this, " removed remote tracks for ").concat(e, " count: ").concat(t.length)), t
            }, w.prototype._removeRemoteTrack = function(e) {
                e.dispose();
                var t = e.getParticipantId(),
                    n = this.remoteTracks.get(t);
                n ? n.delete(e.getType()) || T.error("Failed to remove ".concat(e, " - type mapping messed up ?")) : T.error("removeRemoteTrack: no remote tracks map for ".concat(t)), this.eventEmitter.emit(f.a.REMOTE_TRACK_REMOVED, e)
            }, w.prototype._removeRemoteTrackById = function(e, t) {
                var n = this._getRemoteTrackById(e, t);
                return n && this._removeRemoteTrack(n), n
            };
            var O = function(e) {
                if ("object" !== E(e) || null === e || "string" != typeof e.sdp) return T.warn("An empty description was passed as an argument."), e;
                var t = n(22),
                    r = t.parse(e.sdp);
                void 0 !== r && void 0 !== r.media && Array.isArray(r.media) && r.media.forEach((function(e) {
                    var t = [],
                        n = [];
                    if (void 0 !== e.ssrcGroups && Array.isArray(e.ssrcGroups) && e.ssrcGroups.forEach((function(e) {
                            void 0 !== e.semantics && "FID" === e.semantics && void 0 !== e.ssrcs && t.push(Number(e.ssrcs.split(" ")[0]))
                        })), Array.isArray(e.ssrcs)) {
                        var r;
                        for (r = 0; r < e.ssrcs.length; r++) "object" === E(e.ssrcs[r]) && void 0 !== e.ssrcs[r].id && t.indexOf(e.ssrcs[r].id) >= 0 && (n.push(e.ssrcs[r]), delete e.ssrcs[r]);
                        for (r = 0; r < e.ssrcs.length; r++) void 0 !== e.ssrcs[r] && n.push(e.ssrcs[r]);
                        e.ssrcs = function() {
                            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
                            if (!p.a.isChrome() || !p.a.isVersionGreaterThan(70)) return e;
                            var t = b(e);
                            return e.filter((function(e) {
                                return e.attribute === "mslabel" && e.value === "-"
                            })).map((function(e) {
                                return e.id
                            })).forEach((function(e) {
                                var n = t.find((function(t) {
                                    return t.id === e && "cname" === t.attribute
                                }));
                                n.value = "recvonly-".concat(e), (t = t.filter((function(t) {
                                    return t.id !== e
                                }))).push(n)
                            })), t
                        }(n)
                    }
                }));
                var i = t.write(r);
                return new RTCSessionDescription({
                    type: e.type,
                    sdp: i
                })
            };
            w.prototype.getLocalSSRC = function(e) {
                var t = this._getSSRC(e.rtcId);
                return t && t.ssrcs[0]
            }, w.prototype._injectSsrcGroupForUnifiedSimulcast = function(e) {
                var t = o.a.parse(e.sdp),
                    n = t.media.find((function(e) {
                        return "video" === e.type
                    }));
                if (n.simulcast_03) {
                    var r = [];
                    if (n.ssrcs.forEach((function(e) {
                            "msid" === e.attribute && r.push(e.id)
                        })), n.ssrcGroups = n.ssrcGroups || [], n.ssrcGroups.find((function(e) {
                            return "SIM" === e.semantics
                        }))) return e;
                    n.ssrcGroups.push({
                        semantics: "SIM",
                        ssrcs: r.join(" ")
                    })
                }
                return new RTCSessionDescription({
                    type: e.type,
                    sdp: o.a.write(t)
                })
            };
            var I = {
                signalingState: function() {
                    return this.peerconnection.signalingState
                },
                iceConnectionState: function() {
                    return this.peerconnection.iceConnectionState
                },
                localDescription: function() {
                    var e = this.peerconnection.localDescription;
                    return e ? (this.trace("getLocalDescription::preTransform", k(e)), p.a.usesUnifiedPlan() && (e = this.interop.toPlanB(e), this.trace("getLocalDescription::postTransform (Plan B)", k(e)), e = this._injectSsrcGroupForUnifiedSimulcast(e), this.trace("getLocalDescription::postTransform (inject ssrc group)", k(e))), p.a.doesVideoMuteByStreamRemove() && (e = this.localSdpMunger.maybeAddMutedLocalVideoTracksToSDP(e), T.debug("getLocalDescription::postTransform (munge local SDP)", e)), e = function(e, t) {
                        if (!e) throw new Error("No local description passed in.");
                        var n = new g.a(e.sdp),
                            r = n.selectMedia("audio"),
                            i = !1;
                        r && "sendrecv" !== r.direction && (t.startSilent ? r.direction = "inactive" : r.direction = "sendrecv", i = !0);
                        var o = n.selectMedia("video");
                        return o && "sendrecv" !== o.direction && (o.direction = "sendrecv", i = !0), i ? new RTCSessionDescription({
                            type: e.type,
                            sdp: n.toRawSDP()
                        }) : e
                    }(e, this.options), e = this.localSdpMunger.transformStreamIdentifiers(e)) : (T.debug("getLocalDescription no localDescription found"), {})
                },
                remoteDescription: function() {
                    var e = this.peerconnection.remoteDescription;
                    return this.trace("getRemoteDescription::preTransform", k(e)), p.a.usesUnifiedPlan() && (e = this.interop.toPlanB(e), this.trace("getRemoteDescription::postTransform (Plan B)", k(e))), e || {}
                }
            };
            Object.keys(I).forEach((function(e) {
                Object.defineProperty(w.prototype, e, {
                    get: I[e]
                })
            })), w.prototype._getSSRC = function(e) {
                return this.localSSRCs.get(e)
            }, w.prototype.addTrack = function(e) {
                var t = e.rtcId;
                if (T.info("add ".concat(e, " to: ").concat(this)), this.localTracks.has(t)) T.error("".concat(e, " is already in ").concat(this));
                else {
                    this.localTracks.set(t, e);
                    var n = e.getOriginalStream();
                    if (n ? this._addStream(n) : (!p.a.doesVideoMuteByStreamRemove() || e.isAudioTrack() || e.isVideoTrack() && !e.isMuted()) && T.error("".concat(this, " no WebRTC stream for: ").concat(e)), p.a.doesVideoMuteByStreamRemove() && e.isVideoTrack() && e.isMuted()) {
                        var r = this.generateNewStreamSSRCInfo(e);
                        this.sdpConsistency.setPrimarySsrc(r.ssrcs[0]);
                        var i = r.groups.find((function(e) {
                            return "SIM" === e.semantics
                        }));
                        i && this.simulcast.setSsrcCache(i.ssrcs);
                        var o = r.groups.filter((function(e) {
                            return "FID" === e.semantics
                        }));
                        if (o) {
                            var a = new Map;
                            o.forEach((function(e) {
                                var t = e.ssrcs[0],
                                    n = e.ssrcs[1];
                                a.set(t, n)
                            })), this.rtxModifier.setSsrcCache(a)
                        }
                    }
                }
            }, w.prototype.addTrackUnmute = function(e) {
                if (!this._assertTrackBelongs("addTrackUnmute", e)) return !1;
                T.info("Adding ".concat(e, " as unmute to ").concat(this));
                var t = e.getOriginalStream();
                return t ? (this._addStream(t), !0) : (T.error("Unable to add ".concat(e, " as unmute to ").concat(this, " - no WebRTC stream")), !1)
            }, w.prototype._addStream = function(e) {
                this.peerconnection.addStream(e), this._addedStreams.push(e)
            }, w.prototype._removeStream = function(e) {
                p.a.supportsRtpSender() ? this._handleSenderRemoveStream(e) : this.peerconnection.removeStream(e), this._addedStreams = this._addedStreams.filter((function(t) {
                    return t !== e
                }))
            }, w.prototype._assertTrackBelongs = function(e, t) {
                var n = this.localTracks.has(t.rtcId);
                return n || T.error("".concat(e, ": ").concat(t, " does not belong to ").concat(this)), n
            }, w.prototype.isMediaStreamInPc = function(e) {
                return this._addedStreams.indexOf(e) > -1
            }, w.prototype.removeTrack = function(e) {
                var t = e.getOriginalStream();
                this.trace("removeStream", e.rtcId, t ? t.id : void 0), this._assertTrackBelongs("removeStream", e) && (this.localTracks.delete(e.rtcId), this.localSSRCs.delete(e.rtcId), t && (p.a.supportsRtpSender() ? this._handleSenderRemoveStream(t) : this.peerconnection.removeStream(t)))
            }, w.prototype.findSenderByStream = function(e) {
                var t = e.getTracks()[0];
                if (t) return this.peerconnection.getSenders().find((function(e) {
                    return e.track === t
                }));
                T.error("Cannot find sender: no tracks.")
            }, w.prototype.replaceTrack = function(e, t) {
                var n = this;
                if (p.a.supportsRtpSender() && e && t) {
                    var r = this.findSenderByStream(e.getOriginalStream()),
                        i = t.getOriginalStream();
                    if (r && i) {
                        var o = i.getTracks()[0];
                        if (o) return r.replaceTrack(o, i).then((function() {
                            var r = n.localSSRCs.get(e.rtcId);
                            return n.localTracks.delete(e.rtcId), n.localSSRCs.delete(e.rtcId), n._addedStreams = n._addedStreams.filter((function(e) {
                                return e !== i
                            })), n.localTracks.set(t.rtcId, t), t.storedMSID = e.storedMSID, n._addedStreams.push(i), n.localSSRCs.set(t.rtcId, r), n.eventEmitter.emit(f.a.LOCAL_TRACK_SSRC_UPDATED, t, D(r)), !1
                        }))
                    }
                }
                return e && this.removeTrack(e), t && this.addTrack(t), Promise.resolve(!0)
            }, w.prototype.removeTrackMute = function(e) {
                var t = e.getOriginalStream();
                return this.trace("removeStreamMute", e.rtcId, t ? t.id : null), !!this._assertTrackBelongs("removeStreamMute", e) && (t ? (T.info("Removing ".concat(e, " as mute from ").concat(this)), this._removeStream(t), !0) : (T.error("removeStreamMute - no WebRTC stream for ".concat(e)), !1))
            }, w.prototype._handleSenderRemoveStream = function(e) {
                if (e) {
                    var t = this.findSenderByStream(e);
                    t ? this.peerconnection.removeTrack(t) : T.log("Cannot remove tracks: no RTPSender.")
                }
            }, w.prototype.createDataChannel = function(e, t) {
                return this.trace("createDataChannel", e, t), this.peerconnection.createDataChannel(e, t)
            }, w.prototype._ensureSimulcastGroupIsLast = function(e) {
                var t = e.sdp,
                    n = t.indexOf("m=video"),
                    r = t.indexOf("a=ssrc-group:SIM", n),
                    i = t.lastIndexOf("a=ssrc-group");
                if (-1 === r || -1 === i || i === r) return e;
                var o = t.indexOf("\r\n", r),
                    a = t.substring(r, o + 2);
                i = (t = t.replace(a, "")).lastIndexOf("a=ssrc-group");
                var s = t.indexOf("\r\n", i),
                    c = t.slice(0, s),
                    u = a.trim(),
                    l = t.slice(s);
                return t = "".concat(c, "\r\n").concat(u).concat(l), new RTCSessionDescription({
                    type: e.type,
                    sdp: t
                })
            }, w.prototype._adjustLocalMediaDirection = function(e) {
                var t = new g.a(e.sdp),
                    n = !1,
                    r = t.selectMedia("audio");
                if (r) {
                    var i = this._getDesiredMediaDirection(c.a);
                    r.direction !== i && (r.direction = i, T.info("Adjusted local audio direction to ".concat(i)), n = !0)
                } else T.warn('No "audio" media found int the local description');
                var o = t.selectMedia("video");
                if (o) {
                    var a = this._getDesiredMediaDirection(c.b);
                    o.direction !== a && (o.direction = a, T.info("Adjusted local video direction to ".concat(a)), n = !0)
                } else T.warn('No "video" media found in the local description');
                return n ? new RTCSessionDescription({
                    type: e.type,
                    sdp: t.toRawSDP()
                }) : e
            }, w.prototype.setLocalDescription = function(e) {
                var t = this,
                    n = e;
                if (this.trace("setLocalDescription::preTransform", k(n)), this.options.disableH264 || this.options.preferH264) {
                    var r = o.a.parse(n.sdp),
                        i = r.media.find((function(e) {
                            return "video" === e.type
                        }));
                    this.options.disableH264 ? _.a.stripVideoCodec(i, "h264") : _.a.preferVideoCodec(i, "h264"), n = new RTCSessionDescription({
                        type: n.type,
                        sdp: o.a.write(r)
                    }), this.trace("setLocalDescription::postTransform (H264)", k(n))
                }
                return n = this._adjustLocalMediaDirection(n), n = this._ensureSimulcastGroupIsLast(n), p.a.usesUnifiedPlan() && (n = this.interop.toUnifiedPlan(n), this.trace("setLocalDescription::postTransform (Unified Plan)", k(n))), new Promise((function(e, r) {
                    t.peerconnection.setLocalDescription(n).then((function() {
                        t.trace("setLocalDescriptionOnSuccess");
                        var r = _.a.getUfrag(n.sdp);
                        r !== t.localUfrag && (t.localUfrag = r, t.eventEmitter.emit(f.a.LOCAL_UFRAG_CHANGED, t, r)), e()
                    }), (function(e) {
                        t.trace("setLocalDescriptionOnFailure", e), t.eventEmitter.emit(f.a.SET_LOCAL_DESCRIPTION_FAILED, e, t), r(e)
                    }))
                }))
            }, w.prototype.setAudioTransferActive = function(e) {
                T.debug("".concat(this, " audio transfer active: ").concat(e));
                var t = this.audioTransferActive !== e;
                return this.audioTransferActive = e, t
            }, w.prototype._insertUnifiedPlanSimulcastReceive = function(e) {
                var t = o.a.parse(e.sdp),
                    n = t.media.find((function(e) {
                        return "video" === e.type
                    }));
                return n.rids = [{
                    id: "1",
                    direction: "recv"
                }, {
                    id: "2",
                    direction: "recv"
                }, {
                    id: "3",
                    direction: "recv"
                }], n.simulcast_03 = {
                    value: "recv rid=".concat(R.join(";"))
                }, new RTCSessionDescription({
                    type: e.type,
                    sdp: o.a.write(t)
                })
            }, w.prototype.setMaxBitRate = function(e) {
                var t = e.type;
                if (this.options.capScreenshareBitrate && t !== c.a)
                    if (this.peerconnection.getSenders) {
                        var n = e.videoType,
                            r = e.track.id;
                        this.peerconnection.getSenders().filter((function(e) {
                            return e.track && e.track.id === r
                        })).forEach((function(e) {
                            try {
                                var t = e.getParameters();
                                if (t.encodings && t.encodings.length) {
                                    for (var r in T.info("Setting max bitrate on video stream"), t.encodings) t.encodings.hasOwnProperty(r) && (t.encodings[r].maxBitrate = "desktop" === n ? 5e5 : A[r]);
                                    e.setParameters(t)
                                }
                            } catch (e) {
                                T.error("Browser does not support getParameters/setParamters or setting max bitrate on the encodings: ", e)
                            }
                        }))
                    } else T.debug("Browser doesn't support RTCRtpSender")
            }, w.prototype.setRemoteDescription = function(e) {
                var t = this;
                if (this.trace("setRemoteDescription::preTransform", k(e)), e = this.simulcast.mungeRemoteDescription(e), this.trace("setRemoteDescription::postTransform (simulcast)", k(e)), this.options.preferH264) {
                    var n = o.a.parse(e.sdp),
                        r = n.media.find((function(e) {
                            return "video" === e.type
                        }));
                    _.a.preferVideoCodec(r, "h264"), e = new RTCSessionDescription({
                        type: e.type,
                        sdp: o.a.write(n)
                    })
                }
                return p.a.usesUnifiedPlan() ? (e = new RTCSessionDescription({
                    type: e.type,
                    sdp: this.rtxModifier.stripRtx(e.sdp)
                }), this.trace("setRemoteDescription::postTransform (stripRtx)", k(e)), e = this.interop.toUnifiedPlan(e), this.trace("setRemoteDescription::postTransform (Plan A)", k(e)), this.isSimulcastOn() && (e = this._insertUnifiedPlanSimulcastReceive(e), this.trace("setRemoteDescription::postTransform (sim receive)", k(e)))) : e = O(e), p.a.isSafariWithWebrtc() && !p.a.isSafariWithVP8() && (T.debug("Maybe injecting H264 into the remote description"), e = this._injectH264IfNotPresent(e)), new Promise((function(n, r) {
                    t.peerconnection.setRemoteDescription(e).then((function() {
                        t.trace("setRemoteDescriptionOnSuccess");
                        var r = _.a.getUfrag(e.sdp);
                        r !== t.remoteUfrag && (t.remoteUfrag = r, t.eventEmitter.emit(f.a.REMOTE_UFRAG_CHANGED, t, r)), n()
                    }), (function(e) {
                        t.trace("setRemoteDescriptionOnFailure", e), t.eventEmitter.emit(f.a.SET_REMOTE_DESCRIPTION_FAILED, e, t), r(e)
                    }))
                }))
            }, w.prototype._injectH264IfNotPresent = function(e) {
                var t = o.a.parse(e.sdp),
                    n = t.media.find((function(e) {
                        return "video" === e.type
                    }));
                if (!n) return T.debug("No videoMLine found, no need to inject H264."), e;
                if (n.rtp.some((function(e) {
                        return "h264" === e.codec.toLowerCase()
                    }))) return T.debug("H264 codec found in video mLine, no need to inject."), e;
                for (var r, i = n.fmtp, a = n.payloads, s = n.rtp, c = a.toString().split(" "), u = 127; u >= 96; u--)
                    if (!c.includes(u)) {
                        r = u, c.push(u), n.payloads = c.join(" ");
                        break
                    } return void 0 === r ? (T.error("Could not find valid payload type to inject."), e) : (s.push({
                    codec: "H264",
                    payload: r,
                    rate: 9e4
                }), i.push({
                    config: "level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=42e01f",
                    payload: r
                }), T.debug("Injecting H264 payload type ".concat(r, " into video mLine.")), new RTCSessionDescription({
                    type: e.type,
                    sdp: o.a.write(t)
                }))
            }, w.prototype.setVideoTransferActive = function(e) {
                T.debug("".concat(this, " video transfer active: ").concat(e));
                var t = this.videoTransferActive !== e;
                return this.videoTransferActive = e, t
            }, w.prototype.sendTones = function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 200,
                    n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 200;
                if (!this._dtmfSender) {
                    if (this.peerconnection.getSenders) {
                        var r = this.peerconnection.getSenders().find((function(e) {
                            return e.dtmf
                        }));
                        this._dtmfSender = r && r.dtmf, this._dtmfSender && T.info("".concat(this, " initialized DTMFSender using getSenders"))
                    }
                    if (!this._dtmfSender) {
                        var i = Array.from(this.localTracks.values()).find((function(e) {
                            return e.isAudioTrack()
                        }));
                        this.peerconnection.createDTMFSender && i && (this._dtmfSender = this.peerconnection.createDTMFSender(i.getTrack())), this._dtmfSender && T.info("".concat(this, " initialized DTMFSender using deprecated createDTMFSender"))
                    }
                    this._dtmfSender && (this._dtmfSender.ontonechange = this._onToneChange.bind(this))
                }
                if (this._dtmfSender) {
                    if (this._dtmfSender.toneBuffer) return void this._dtmfTonesQueue.push({
                        tones: e,
                        duration: t,
                        interToneGap: n
                    });
                    this._dtmfSender.insertDTMF(e, t, n)
                } else T.warn("".concat(this, " sendTones - failed to select DTMFSender"))
            }, w.prototype._onToneChange = function(e) {
                if (this._dtmfSender && "" === e.tone && this._dtmfTonesQueue.length) {
                    var t = this._dtmfTonesQueue.shift(),
                        n = t.tones,
                        r = t.duration,
                        i = t.interToneGap;
                    this._dtmfSender.insertDTMF(n, r, i)
                }
            }, w.prototype.generateRecvonlySsrc = function() {
                var e = _.a.generateSsrc();
                T.info("".concat(this, " generated new recvonly SSRC: ").concat(e)), this.sdpConsistency.setPrimarySsrc(e)
            }, w.prototype.clearRecvonlySsrc = function() {
                T.info("Clearing primary video SSRC!"), this.sdpConsistency.clearVideoSsrcCache()
            }, w.prototype.close = function() {
                this.trace("stop"), this.signalingLayer.off(S.a, this._peerMutedChanged), this.signalingLayer.off(S.b, this._peerVideoTypeChanged);
                var e = !0,
                    t = !1,
                    n = void 0;
                try {
                    for (var r, i = this.remoteTracks.values()[Symbol.iterator](); !(e = (r = i.next()).done); e = !0) {
                        var o = r.value,
                            a = !0,
                            s = !1,
                            c = void 0;
                        try {
                            for (var u, l = o.values()[Symbol.iterator](); !(a = (u = l.next()).done); a = !0) {
                                var d = u.value;
                                this._removeRemoteTrack(d)
                            }
                        } catch (e) {
                            s = !0, c = e
                        } finally {
                            try {
                                a || null == l.return || l.return()
                            } finally {
                                if (s) throw c
                            }
                        }
                    }
                } catch (e) {
                    t = !0, n = e
                } finally {
                    try {
                        e || null == i.return || i.return()
                    } finally {
                        if (t) throw n
                    }
                }
                this.remoteTracks.clear(), this._addedStreams = [], this._dtmfSender = null, this._dtmfTonesQueue = [], this.rtc._removePeerConnection(this) || T.error("RTC._removePeerConnection returned false"), null !== this.statsinterval && (window.clearInterval(this.statsinterval), this.statsinterval = null), T.info("Closing ".concat(this, "...")), this.peerconnection.close()
            };

            function P(e) {
                return e.getLocalTracks().some((function(e) {
                    return "camera" === e.videoType
                }))
            }

            function D(e) {
                return e && e.groups && e.groups.length ? e.groups[0].ssrcs[0] : e && e.ssrcs && e.ssrcs.length ? e.ssrcs[0] : null
            }
            w.prototype.createAnswer = function(e) {
                if (p.a.isFirefox() && this.isSimulcastOn()) {
                    var t = {
                        encodings: [{
                            rid: "1",
                            scaleResolutionDownBy: 4
                        }, {
                            rid: "2",
                            scaleResolutionDownBy: 2
                        }, {
                            rid: "3"
                        }]
                    };
                    this.peerconnection.getSenders().find((function(e) {
                        return null !== e.track && "video" === e.track.kind
                    })).setParameters(t)
                }
                return this._createOfferOrAnswer(!1, e)
            }, w.prototype.createOffer = function(e) {
                return this._createOfferOrAnswer(!0, e)
            }, w.prototype._createOfferOrAnswer = function(e, t) {
                var n = this,
                    r = e ? "Offer" : "Answer";
                this.trace("create".concat(r), JSON.stringify(t, null, " "));
                var i = function(t, i, a) {
                    try {
                        if (n.trace("create".concat(r, "OnSuccess::preTransform"), k(t)), p.a.usesUnifiedPlan() && (t = n.interop.toPlanB(t), n.trace("create".concat(r, "OnSuccess::postTransform (Plan B)"), k(t)), n.isSimulcastOn() && (t = n._injectSsrcGroupForUnifiedSimulcast(t), n.trace("create".concat(r, "OnSuccess::postTransform") + "(inject ssrc group)", k(t)))), p.a.usesUnifiedPlan() || (n.hasAnyTracksOfType(c.b) || n.sdpConsistency.hasPrimarySsrcCached() || n.generateRecvonlySsrc(), t = new RTCSessionDescription({
                                type: t.type,
                                sdp: n.sdpConsistency.makeVideoPrimarySsrcsConsistent(t.sdp)
                            }), n.trace("create".concat(r, "OnSuccess::postTransform ") + "(make primary audio/video ssrcs consistent)", k(t))), n.isSimulcastOn() && (!n.options.capScreenshareBitrate || n.options.capScreenshareBitrate && P(n)) && (t = n.simulcast.mungeLocalDescription(t), n.trace("create".concat(r) + "OnSuccess::postTransform (simulcast)", k(t))), !n.options.disableRtx && p.a.supportsRtx() && (t = new RTCSessionDescription({
                                type: t.type,
                                sdp: n.rtxModifier.modifyRtxSsrcs(t.sdp)
                            }), n.trace("create".concat(r) + "OnSuccess::postTransform (rtx modifier)", k(t))), !e) {
                            var s = new v.a(n.remoteDescription.sdp),
                                u = new v.a(t.sdp);
                            d = s, h = u, (p.a.isChromiumBased() || p.a.isReactNative()) && d && h && d.media && h.media && d.media.length === h.media.length && (h.media.forEach((function(e, t) {
                                _.a.findLine(d.media[t], "a=setup:actpass", d.session) && (h.media[t] = e.replace(/a=setup:active/g, "a=setup:passive"))
                            })), h.raw = h.session + h.media.join("")), t = new RTCSessionDescription({
                                type: t.type,
                                sdp: u.raw
                            })
                        }
                        var l = function(e) {
                            var t = new Map,
                                n = new Map;
                            if ("object" !== E(e) || null === e || "string" != typeof e.sdp) return T.warn("An empty description was passed as an argument."), t;
                            var r = o.a.parse(e.sdp);
                            if (!Array.isArray(r.media)) return t;
                            var i = !0,
                                a = !1,
                                s = void 0;
                            try {
                                for (var c, u = r.media[Symbol.iterator](); !(i = (c = u.next()).done); i = !0) {
                                    var l = c.value;
                                    if (Array.isArray(l.ssrcs)) {
                                        if (Array.isArray(l.ssrcGroups)) {
                                            var d = !0,
                                                p = !1,
                                                h = void 0;
                                            try {
                                                for (var f, m = l.ssrcGroups[Symbol.iterator](); !(d = (f = m.next()).done); d = !0) {
                                                    var v = f.value;
                                                    if (void 0 !== v.semantics && void 0 !== v.ssrcs) {
                                                        var y = v.ssrcs.split(" ").map((function(e) {
                                                                return parseInt(e, 10)
                                                            })),
                                                            g = y[0];
                                                        v.ssrcs = y, n.has(g) || n.set(g, []), n.get(g).push(v)
                                                    }
                                                }
                                            } catch (e) {
                                                p = !0, h = e
                                            } finally {
                                                try {
                                                    d || null == m.return || m.return()
                                                } finally {
                                                    if (p) throw h
                                                }
                                            }
                                        }
                                        var _ = !0,
                                            S = !1,
                                            b = void 0;
                                        try {
                                            for (var C, R = l.ssrcs[Symbol.iterator](); !(_ = (C = R.next()).done); _ = !0) {
                                                var A = C.value;
                                                if ("msid" === A.attribute) {
                                                    var w = A.value,
                                                        k = t.get(w);
                                                    k || (k = {
                                                        ssrcs: [],
                                                        groups: [],
                                                        msid: w
                                                    }, t.set(w, k));
                                                    var O = A.id;
                                                    if (k.ssrcs.push(O), n.has(O)) {
                                                        var I = n.get(O),
                                                            P = !0,
                                                            D = !1,
                                                            N = void 0;
                                                        try {
                                                            for (var L, M = I[Symbol.iterator](); !(P = (L = M.next()).done); P = !0) {
                                                                var x = L.value;
                                                                k.groups.push(x)
                                                            }
                                                        } catch (e) {
                                                            D = !0, N = e
                                                        } finally {
                                                            try {
                                                                P || null == M.return || M.return()
                                                            } finally {
                                                                if (D) throw N
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        } catch (e) {
                                            S = !0, b = e
                                        } finally {
                                            try {
                                                _ || null == R.return || R.return()
                                            } finally {
                                                if (S) throw b
                                            }
                                        }
                                    }
                                }
                            } catch (e) {
                                a = !0, s = e
                            } finally {
                                try {
                                    i || null == u.return || u.return()
                                } finally {
                                    if (a) throw s
                                }
                            }
                            return t
                        }(t);
                        T.debug("Got local SSRCs MAP: ", l), n._processLocalSSRCsMap(l), i(t)
                    } catch (e) {
                        n.trace("create".concat(r, "OnError"), e), n.trace("create".concat(r, "OnError"), k(t)), T.error("create".concat(r, "OnError"), e, k(t)), a(e)
                    }
                    var d, h
                };
                return new Promise((function(o, a) {
                    (e ? n.peerconnection.createOffer(t) : n.peerconnection.createAnswer(t)).then((function(e) {
                        return i(e, o, a)
                    }), (function(t) {
                        return function(t, i) {
                            n.trace("create".concat(r, "OnFailure"), t);
                            var o = e ? f.a.CREATE_OFFER_FAILED : f.a.CREATE_ANSWER_FAILED;
                            n.eventEmitter.emit(o, t, n), i(t)
                        }(t, a)
                    }))
                }))
            }, w.prototype._processLocalSSRCsMap = function(e) {
                var t = !0,
                    n = !1,
                    r = void 0;
                try {
                    for (var i, o = this.localTracks.values()[Symbol.iterator](); !(t = (i = o.next()).done); t = !0) {
                        var a = i.value,
                            s = a.storedMSID;
                        if (e.has(s)) {
                            var c = e.get(s);
                            if (!c) return void T.error("No SSRC found for: ".concat(s, " in ").concat(this));
                            var u = this.localSSRCs.get(a.rtcId),
                                l = D(c),
                                d = D(u);
                            l !== d ? (null === d ? T.info("Storing new local SSRC for ".concat(a, " in ").concat(this), c) : T.error("Overwriting SSRC for ".concat(a, " ").concat(s, " in ").concat(this, " with: "), c), this.localSSRCs.set(a.rtcId, c), this.eventEmitter.emit(f.a.LOCAL_TRACK_SSRC_UPDATED, a, l)) : T.debug("The local SSRC(".concat(l, ") for ").concat(a, " ").concat(s) + "is still up to date in ".concat(this))
                        } else a.isVideoTrack() || a.isMuted() || T.warn("No SSRCs found in the local SDP for ".concat(a, " MSID: ").concat(s, " in ").concat(this))
                    }
                } catch (e) {
                    n = !0, r = e
                } finally {
                    try {
                        t || null == o.return || o.return()
                    } finally {
                        if (n) throw r
                    }
                }
            }, w.prototype.addIceCandidate = function(e) {
                return this.trace("addIceCandidate", JSON.stringify({
                    candidate: e.candidate,
                    sdpMid: e.sdpMid,
                    sdpMLineIndex: e.sdpMLineIndex,
                    usernameFragment: e.usernameFragment
                }, null, " ")), this.peerconnection.addIceCandidate(e)
            }, w.prototype.getStats = function(e, t) {
                p.a.isSafariWithWebrtc() || p.a.isFirefox() || p.a.isReactNative() ? this.peerconnection.getStats().then(e).catch(t || function() {}) : this.peerconnection.getStats(e)
            }, w.prototype.generateNewStreamSSRCInfo = function(e) {
                var t = e.rtcId,
                    n = this._getSSRC(t);
                if (n && T.error("Will overwrite local SSRCs for track ID: ".concat(t)), this.isSimulcastOn() && (!this.options.capScreenshareBitrate || this.options.capScreenshareBitrate && P(this))) {
                    n = {
                        ssrcs: [],
                        groups: []
                    };
                    for (var r = 0; r < C; r++) n.ssrcs.push(_.a.generateSsrc());
                    n.groups.push({
                        ssrcs: n.ssrcs.slice(),
                        semantics: "SIM"
                    })
                } else n = {
                    ssrcs: [_.a.generateSsrc()],
                    groups: []
                };
                if (!this.options.disableRtx && p.a.supportsRtx())
                    for (var i = n.ssrcs.length, o = 0; o < i; ++o) {
                        var a = n.ssrcs[o],
                            s = _.a.generateSsrc();
                        n.ssrcs.push(s), n.groups.push({
                            ssrcs: [a, s],
                            semantics: "FID"
                        })
                    }
                return n.msid = e.storedMSID, this.localSSRCs.set(t, n), n
            };
            w.prototype.setIsSelected = function(e) {
                this.options.enableLayerSuspension && (T.debug("Layer suspension enabled," + "currently selected? ".concat(e)), function(e, t) {
                    if (e.getSenders) {
                        var n = e.getSenders().find((function(e) {
                            return "video" === e.track.kind
                        }));
                        if (n)
                            if (n.getParameters) {
                                var r = n.getParameters();
                                t ? (T.debug("Currently selected, enabling all sim layers"), r.encodings.forEach((function(e) {
                                    e.active = !0
                                }))) : (T.debug("Not currently selected, disabling upper layers"), [1, 2].forEach((function(e) {
                                    r.encodings[e] && (r.encodings[e].active = !1)
                                }))), n.setParameters(r)
                            } else T.debug("Browser doesn't support RTPSender parameters");
                        else T.warn("handleLayerSuspension unable to find video sender")
                    } else T.debug("Browser doesn't support RTPSender")
                }(this.peerconnection, e))
            }, w.prototype.toString = function() {
                return "TPC[".concat(this.id, ",p2p:").concat(this.isP2P, "]")
            }
        }).call(this, "modules/RTC/TraceablePeerConnection.js")
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return y
            }));
            var r = n(7),
                i = n(53),
                o = n(16),
                a = n(5);

            function s(e) {
                return (s = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                    return typeof e
                } : function(e) {
                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                })(e)
            }

            function c(e, t) {
                for (var n = 0; n < t.length; n++) {
                    var r = t[n];
                    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                }
            }

            function u(e) {
                return (u = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
                    return e.__proto__ || Object.getPrototypeOf(e)
                })(e)
            }

            function l(e, t) {
                return (l = Object.setPrototypeOf || function(e, t) {
                    return e.__proto__ = t, e
                })(e, t)
            }

            function d(e) {
                if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return e
            }
            var p = n(4).getLogger(e),
                h = n(8),
                f = !1,
                m = !1,
                v = ["abort", "canplay", "canplaythrough", "emptied", "ended", "error", "loadeddata", "loadedmetadata", "loadstart", "pause", "play", "playing", "ratechange", "stalled", "suspend", "waiting"],
                y = function(e) {
                    function t(e, n, r, i, o, a, c, l, h, f) {
                        var m;
                        if (function(e, t) {
                                if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                            }(this, t), (m = function(e, t) {
                                return !t || "object" !== s(t) && "function" != typeof t ? d(e) : t
                            }(this, u(t).call(this, n, i, o, (function() {}), a, c))).rtc = e, "number" != typeof l) throw new TypeError("SSRC ".concat(l, " is not a number"));
                        return m.ssrc = l, m.ownerEndpointId = r, m.muted = h, m.isP2P = f, p.debug("New remote track added: ".concat(d(d(m)))), m.hasBeenMuted = h, m.rtc && m.track && m._bindTrackHandlers(), m._containerHandlers = {}, v.forEach((function(e) {
                            m._containerHandlers[e] = m._containerEventHandler.bind(d(d(m)), e)
                        })), m
                    }
                    var n, i, y;
                    return function(e, t) {
                        if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
                        e.prototype = Object.create(t && t.prototype, {
                            constructor: {
                                value: e,
                                writable: !0,
                                configurable: !0
                            }
                        }), t && l(e, t)
                    }(t, e), n = t, (i = [{
                        key: "_bindTrackHandlers",
                        value: function() {
                            var e = this;
                            this.track.addEventListener("mute", (function() {
                                return e._onTrackMute()
                            })), this.track.addEventListener("unmute", (function() {
                                return e._onTrackUnmute()
                            })), this.track.addEventListener("ended", (function() {
                                p.debug('"onended" event('.concat(Date.now(), "): ").concat(e))
                            }))
                        }
                    }, {
                        key: "_onTrackMute",
                        value: function() {
                            p.debug('"onmute" event('.concat(Date.now(), "): ").concat(this)), this.rtc.eventEmitter.emit(h.REMOTE_TRACK_MUTE, this)
                        }
                    }, {
                        key: "_onTrackUnmute",
                        value: function() {
                            p.debug('"onunmute" event('.concat(Date.now(), "): ").concat(this)), this.rtc.eventEmitter.emit(h.REMOTE_TRACK_UNMUTE, this)
                        }
                    }, {
                        key: "setMute",
                        value: function(e) {
                            this.muted !== e && (e && (this.hasBeenMuted = !0), this.stream && (this.stream.muted = e), this.muted = e, this.emit(o.TRACK_MUTE_CHANGED, this))
                        }
                    }, {
                        key: "isMuted",
                        value: function() {
                            return this.muted
                        }
                    }, {
                        key: "getParticipantId",
                        value: function() {
                            return this.ownerEndpointId
                        }
                    }, {
                        key: "isLocal",
                        value: function() {
                            return !1
                        }
                    }, {
                        key: "getSSRC",
                        value: function() {
                            return this.ssrc
                        }
                    }, {
                        key: "_setVideoType",
                        value: function(e) {
                            this.videoType !== e && (this.videoType = e, this.emit(o.TRACK_VIDEOTYPE_CHANGED, e))
                        }
                    }, {
                        key: "_playCallback",
                        value: function() {
                            var e = this.isVideoTrack() ? "video" : "audio",
                                t = window.performance.now();
                            console.debug("(TIME) Render ".concat(e, ":\t"), t), this.conference.getConnectionTimes()["".concat(e, ".render")] = t;
                            var n = window.connectionTimes["obtainPermissions.start"],
                                i = window.connectionTimes["obtainPermissions.end"],
                                o = isNaN(i) || isNaN(n) ? 0 : i - n,
                                s = t - (this.conference.getConnectionTimes()["session.initiate"] - this.conference.getConnectionTimes()["muc.joined"]) - o;
                            this.conference.getConnectionTimes()["".concat(e, ".ttfm")] = s, console.debug("(TIME) TTFM ".concat(e, ":\t"), s), a.a.sendAnalytics(Object(r.M)({
                                media_type: e,
                                muted: this.hasBeenMuted,
                                value: s
                            }))
                        }
                    }, {
                        key: "_attachTTFMTracker",
                        value: function(e) {
                            f && this.isAudioTrack() || m && this.isVideoTrack() || (this.isAudioTrack() && (f = !0), this.isVideoTrack() && (m = !0), e.addEventListener("canplay", this._playCallback.bind(this)))
                        }
                    }, {
                        key: "_onTrackAttach",
                        value: function(e) {
                            var t = this;
                            p.debug("Track has been attached to a container: ".concat(this)), v.forEach((function(n) {
                                e.addEventListener(n, t._containerHandlers[n])
                            }))
                        }
                    }, {
                        key: "_onTrackDetach",
                        value: function(e) {
                            var t = this;
                            p.debug("Track has been detached from a container: ".concat(this)), v.forEach((function(n) {
                                e.removeEventListener(n, t._containerHandlers[n])
                            }))
                        }
                    }, {
                        key: "_containerEventHandler",
                        value: function(e) {
                            p.debug("".concat(e, " handler was called for a container with attached ").concat(this))
                        }
                    }, {
                        key: "_getStatus",
                        value: function() {
                            var e = this.track,
                                t = e.enabled,
                                n = e.muted,
                                r = e.readyState;
                            return "readyState: ".concat(r, ", muted: ").concat(n, ", enabled: ").concat(t)
                        }
                    }, {
                        key: "toString",
                        value: function() {
                            return "RemoteTrack[userID: ".concat(this.getParticipantId(), ", type: ").concat(this.getType(), ", ssrc: ").concat(this.getSSRC(), ", p2p: ").concat(this.isP2P, ", status: ").concat(this._getStatus(), "]")
                        }
                    }]) && c(n.prototype, i), y && c(n, y), t
                }(i.a)
        }).call(this, "modules/RTC/JitsiRemoteTrack.js")
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return c
            }));
            var r = n(4),
                i = n(9),
                o = n(26);

            function a(e, t) {
                for (var n = 0; n < t.length; n++) {
                    var r = t[n];
                    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                }
            }
            var s = Object(r.getLogger)(e),
                c = function() {
                    function e(t) {
                        ! function(e, t) {
                            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                        }(this, e), this.tpc = t
                    }
                    var t, n, r;
                    return t = e, (n = [{
                        key: "_addMutedLocalVideoTracksToSDP",
                        value: function(e) {
                            var t = this.tpc.getLocalTracks(i.b);
                            if (!t.length) return !1;
                            1 !== t.length && s.error("".concat(this.tpc, " there is more than 1 video track ! ") + "Strange things may happen !", t);
                            var n = e.selectMedia("video");
                            if (!n) return s.debug("".concat(this.tpc, " unable to hack local video track SDP") + '- no "video" media'), !1;
                            var r = !1,
                                o = !0,
                                a = !1,
                                c = void 0;
                            try {
                                for (var u, l = t[Symbol.iterator](); !(o = (u = l.next()).done); o = !0) {
                                    var d = u.value,
                                        p = d.isMuted(),
                                        h = d.getOriginalStream(),
                                        f = h && this.tpc.isMediaStreamInPc(h),
                                        m = p || !f;
                                    if (s.debug("".concat(this.tpc, " ").concat(d, " muted: ").concat(p, ", is in PeerConnection: ").concat(f, " => should fake sdp ? : ").concat(m)), m) {
                                        var v = this.tpc.isSimulcastOn() ? this.tpc.simulcast.ssrcCache : [this.tpc.sdpConsistency.cachedPrimarySsrc];
                                        if (v.length) {
                                            r = !0, n.direction = "sendrecv";
                                            var y = v[0],
                                                g = "injected-".concat(y),
                                                _ = !0,
                                                S = !1,
                                                b = void 0;
                                            try {
                                                for (var E, T = v[Symbol.iterator](); !(_ = (E = T.next()).done); _ = !0) {
                                                    var C = E.value;
                                                    n.removeSSRC(C), s.debug("".concat(this.tpc, " injecting video SSRC: ").concat(C, " for ").concat(d)), n.addSSRCAttribute({
                                                        id: C,
                                                        attribute: "cname",
                                                        value: g
                                                    }), n.addSSRCAttribute({
                                                        id: C,
                                                        attribute: "msid",
                                                        value: d.storedMSID
                                                    })
                                                }
                                            } catch (e) {
                                                S = !0, b = e
                                            } finally {
                                                try {
                                                    _ || null == T.return || T.return()
                                                } finally {
                                                    if (S) throw b
                                                }
                                            }
                                            if (v.length > 1) {
                                                var R = {
                                                    ssrcs: v.join(" "),
                                                    semantics: "SIM"
                                                };
                                                n.findGroup(R.semantics, R.ssrcs) || (s.debug("".concat(this.tpc, " injecting SIM group for ").concat(d), R), n.addSSRCGroup(R))
                                            }
                                            this.tpc.options.disableRtx || this.tpc.rtxModifier.modifyRtxSsrcs2(n)
                                        } else s.error("No SSRCs stored for: ".concat(d, " in ").concat(this.tpc))
                                    }
                                }
                            } catch (e) {
                                a = !0, c = e
                            } finally {
                                try {
                                    o || null == l.return || l.return()
                                } finally {
                                    if (a) throw c
                                }
                            }
                            return r
                        }
                    }, {
                        key: "_transformMediaIdentifiers",
                        value: function(e) {
                            var t = this.tpc.id,
                                n = !0,
                                r = !1,
                                i = void 0;
                            try {
                                for (var o, a = e.ssrcs[Symbol.iterator](); !(n = (o = a.next()).done); n = !0) {
                                    var c = o.value;
                                    switch (c.attribute) {
                                        case "cname":
                                        case "label":
                                        case "mslabel":
                                            c.value = c.value && "".concat(c.value, "-").concat(t);
                                            break;
                                        case "msid":
                                            if (c.value) {
                                                var u = c.value.split(" ");
                                                if (2 === u.length) {
                                                    var l = u[0],
                                                        d = u[1];
                                                    c.value = "".concat(l, "-").concat(t, " ").concat(d, "-").concat(t)
                                                } else s.warn("Unable to munge local MSID" + "- weird format detected: ".concat(c.value))
                                            }
                                    }
                                }
                            } catch (e) {
                                r = !0, i = e
                            } finally {
                                try {
                                    n || null == a.return || a.return()
                                } finally {
                                    if (r) throw i
                                }
                            }
                        }
                    }, {
                        key: "maybeAddMutedLocalVideoTracksToSDP",
                        value: function(e) {
                            if (!e) throw new Error("No local description passed in.");
                            var t = new o.a(e.sdp);
                            return this._addMutedLocalVideoTracksToSDP(t) ? new RTCSessionDescription({
                                type: e.type,
                                sdp: t.toRawSDP()
                            }) : e
                        }
                    }, {
                        key: "transformStreamIdentifiers",
                        value: function(e) {
                            if (!e || !e.sdp || !e.type) return e;
                            var t = new o.a(e.sdp),
                                n = t.selectMedia("audio");
                            n && this._transformMediaIdentifiers(n);
                            var r = t.selectMedia("video");
                            return r && this._transformMediaIdentifiers(r), new RTCSessionDescription({
                                type: e.type,
                                sdp: t.toRawSDP()
                            })
                        }
                    }]) && a(t.prototype, n), r && a(t, r), e
                }()
        }).call(this, "modules/RTC/LocalSdpMunger.js")
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return u
            }));
            var r = n(4),
                i = n(26),
                o = n(6);

            function a(e, t) {
                for (var n = 0; n < t.length; n++) {
                    var r = t[n];
                    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                }
            }
            var s = Object(r.getLogger)(e);

            function c(e, t, n) {
                s.debug("Updating mline to associate ".concat(n) + "rtx ssrc with primary stream, ".concat(t.id));
                var r = t.id,
                    i = t.msid,
                    o = t.cname,
                    a = e.getRtxSSRC(r);
                a !== n ? (a && (s.debug("".concat(r, " was previously associated with rtx") + "".concat(a, ", removing all references to it")), e.removeSSRC(a), s.debug("groups before filtering for ".concat(a)), s.debug(e.dumpSSRCGroups()), e.removeGroupsWithSSRC(a)), e.addSSRCAttribute({
                    id: n,
                    attribute: "cname",
                    value: o
                }), e.addSSRCAttribute({
                    id: n,
                    attribute: "msid",
                    value: i
                }), e.addSSRCGroup({
                    semantics: "FID",
                    ssrcs: "".concat(r, " ").concat(n)
                })) : s.debug("".concat(n, " was already associated with ").concat(r))
            }
            var u = function() {
                function e() {
                    ! function(e, t) {
                        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                    }(this, e), this.correspondingRtxSsrcs = new Map
                }
                var t, n, r;
                return t = e, (n = [{
                    key: "clearSsrcCache",
                    value: function() {
                        this.correspondingRtxSsrcs.clear()
                    }
                }, {
                    key: "setSsrcCache",
                    value: function(e) {
                        s.debug("Setting ssrc cache to ", e), this.correspondingRtxSsrcs = e
                    }
                }, {
                    key: "modifyRtxSsrcs",
                    value: function(e) {
                        var t = new i.a(e),
                            n = t.selectMedia("video");
                        return n ? this.modifyRtxSsrcs2(n) ? t.toRawSDP() : e : (s.debug("No 'video' media found in the sdp: ".concat(e)), e)
                    }
                }, {
                    key: "modifyRtxSsrcs2",
                    value: function(e) {
                        if ("recvonly" === e.direction) return s.debug("RtxModifier doing nothing, video m line is recvonly"), !1;
                        if (e.getSSRCCount() < 1) return s.debug("RtxModifier doing nothing, no video ssrcs present"), !1;
                        s.debug("Current ssrc mapping: ", this.correspondingRtxSsrcs);
                        var t = e.getPrimaryVideoSSRCs();
                        s.debug("Parsed primary video ssrcs ", t, " making sure all have rtx streams");
                        var n = !0,
                            r = !1,
                            i = void 0;
                        try {
                            for (var a, u = t[Symbol.iterator](); !(n = (a = u.next()).done); n = !0) {
                                var l = a.value,
                                    d = e.getSSRCAttrValue(l, "msid"),
                                    p = e.getSSRCAttrValue(l, "cname"),
                                    h = this.correspondingRtxSsrcs.get(l);
                                if (h) s.debug("Already have an associated rtx ssrc for" + "video ssrc ".concat(l, ": ").concat(h));
                                else {
                                    s.debug("No previously associated rtx ssrc for video ssrc ".concat(l));
                                    var f = e.getRtxSSRC(l);
                                    f ? (s.debug("Rtx stream ".concat(f, " ") + "already existed in the sdp as an rtx stream for " + "".concat(l)), h = f) : (h = o.a.generateSsrc(), s.debug("Generated rtx ssrc ".concat(h, " ") + "for ssrc ".concat(l))), s.debug("Caching rtx ssrc ".concat(h, " ") + "for video ssrc ".concat(l)), this.correspondingRtxSsrcs.set(l, h)
                                }
                                c(e, {
                                    id: l,
                                    cname: p,
                                    msid: d
                                }, h)
                            }
                        } catch (e) {
                            r = !0, i = e
                        } finally {
                            try {
                                n || null == u.return || u.return()
                            } finally {
                                if (r) throw i
                            }
                        }
                        return !0
                    }
                }, {
                    key: "stripRtx",
                    value: function(e) {
                        var t = new i.a(e),
                            n = t.selectMedia("video");
                        if (!n) return s.debug("No 'video' media found in the sdp: ".concat(e)), e;
                        if ("recvonly" === n.direction) return s.debug("RtxModifier doing nothing, video m line is recvonly"), e;
                        if (n.getSSRCCount() < 1) return s.debug("RtxModifier doing nothing, no video ssrcs present"), e;
                        if (!n.containsAnySSRCGroups()) return s.debug("RtxModifier doing nothing, no video ssrcGroups present"), e;
                        var r = n.findGroups("FID");
                        n.removeGroupsBySemantics("FID");
                        var o = !0,
                            a = !1,
                            c = void 0;
                        try {
                            for (var u, l = r[Symbol.iterator](); !(o = (u = l.next()).done); o = !0) {
                                var d = u.value,
                                    p = Object(i.c)(d);
                                n.removeSSRC(p)
                            }
                        } catch (e) {
                            a = !0, c = e
                        } finally {
                            try {
                                o || null == l.return || l.return()
                            } finally {
                                if (a) throw c
                            }
                        }
                        return t.toRawSDP()
                    }
                }]) && a(t.prototype, n), r && a(t, r), e
            }()
        }).call(this, "modules/xmpp/RtxModifier.js")
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return s
            }));
            var r = n(4),
                i = n(26);

            function o(e, t) {
                for (var n = 0; n < t.length; n++) {
                    var r = t[n];
                    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                }
            }
            var a = Object(r.getLogger)(e),
                s = function() {
                    function e(t) {
                        ! function(e, t) {
                            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                        }(this, e), this.clearVideoSsrcCache(), this.logPrefix = t
                    }
                    var t, n, r;
                    return t = e, (n = [{
                        key: "clearVideoSsrcCache",
                        value: function() {
                            this.cachedPrimarySsrc = null, this.injectRecvOnly = !1
                        }
                    }, {
                        key: "setPrimarySsrc",
                        value: function(e) {
                            if ("number" != typeof e) throw new Error("Primary SSRC must be a number!");
                            this.cachedPrimarySsrc = e
                        }
                    }, {
                        key: "hasPrimarySsrcCached",
                        value: function() {
                            return Boolean(this.cachedPrimarySsrc)
                        }
                    }, {
                        key: "makeVideoPrimarySsrcsConsistent",
                        value: function(e) {
                            var t = new i.a(e),
                                n = t.selectMedia("video");
                            if (!n) return a.debug("".concat(this.logPrefix, " no 'video' media found in the sdp: ") + "".concat(e)), e;
                            if ("recvonly" === n.direction) this.cachedPrimarySsrc && this.injectRecvOnly ? n.addSSRCAttribute({
                                id: this.cachedPrimarySsrc,
                                attribute: "cname",
                                value: "recvonly-".concat(this.cachedPrimarySsrc)
                            }) : a.info("".concat(this.logPrefix, " no SSRC found for the recvonly video") + "stream!");
                            else {
                                var r = n.getPrimaryVideoSsrc();
                                if (!r) return a.info("".concat(this.logPrefix, " sdp-consistency couldn't") + " parse new primary ssrc"), e;
                                if (this.cachedPrimarySsrc) {
                                    a.info("".concat(this.logPrefix, " sdp-consistency replacing new ssrc") + "".concat(r, " with cached ") + "".concat(this.cachedPrimarySsrc)), n.replaceSSRC(r, this.cachedPrimarySsrc);
                                    var o = !0,
                                        s = !1,
                                        c = void 0;
                                    try {
                                        for (var u, l = n.ssrcGroups[Symbol.iterator](); !(o = (u = l.next()).done); o = !0) {
                                            var d = u.value;
                                            if ("FID" === d.semantics) {
                                                var p = Object(i.b)(d),
                                                    h = Object(i.c)(d);
                                                p === r && (d.ssrcs = "".concat(this.cachedPrimarySsrc, " ").concat(h))
                                            }
                                        }
                                    } catch (e) {
                                        s = !0, c = e
                                    } finally {
                                        try {
                                            o || null == l.return || l.return()
                                        } finally {
                                            if (s) throw c
                                        }
                                    }
                                } else this.cachedPrimarySsrc = r, a.info("".concat(this.logPrefix, " sdp-consistency caching primary ssrc") + "".concat(this.cachedPrimarySsrc));
                                this.injectRecvOnly = !0
                            }
                            return t.toRawSDP()
                        }
                    }]) && o(t.prototype, n), r && o(t, r), e
                }()
        }).call(this, "modules/xmpp/SdpConsistency.js")
    }, function(e, t, n) {
        "use strict";
        n.d(t, "a", (function() {
            return o
        }));
        var r = n(2);

        function i(e, t) {
            for (var n = 0; n < t.length; n++) {
                var r = t[n];
                r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
            }
        }
        var o = function() {
            function e(t, n) {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this._callback = n, this._eventFired = !1, t.statistics.addAudioLevelListener(this._audioLevel.bind(this)), t.on(r.TRACK_MUTE_CHANGED, this._trackMuteChanged.bind(this)), t.on(r.TRACK_ADDED, this._trackAdded.bind(this))
            }
            var t, n, o;
            return t = e, (n = [{
                key: "_audioLevel",
                value: function(e, t, n, r) {
                    r && this.audioTrack && !this._eventFired && this.audioTrack.isMuted() && n > .6 && (this._eventFired = !0, this._callback())
                }
            }, {
                key: "_isLocalAudioTrack",
                value: function(e) {
                    return e.isAudioTrack() && e.isLocal()
                }
            }, {
                key: "_trackAdded",
                value: function(e) {
                    this._isLocalAudioTrack(e) && (this.audioTrack = e)
                }
            }, {
                key: "_trackMuteChanged",
                value: function(e) {
                    this._isLocalAudioTrack(e) && e.isMuted() && (this._eventFired = !1)
                }
            }]) && i(t.prototype, n), o && i(t, o), e
        }()
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return v
            }));
            var r = n(25),
                i = n(2),
                o = n(4);

            function a(e, t) {
                for (var n = 0; n < t.length; n++) {
                    var r = t[n];
                    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                }
            }
            var s = n(0),
                c = n(14),
                u = n(29),
                l = Object(o.getLogger)(e),
                d = "stats",
                p = [{
                    width: 1920,
                    height: 1080,
                    layers: 3,
                    max: 5e3,
                    target: 4e3,
                    min: 800
                }, {
                    width: 1280,
                    height: 720,
                    layers: 3,
                    max: 2500,
                    target: 2500,
                    min: 600
                }, {
                    width: 960,
                    height: 540,
                    layers: 3,
                    max: 900,
                    target: 900,
                    min: 450
                }, {
                    width: 640,
                    height: 360,
                    layers: 2,
                    max: 700,
                    target: 500,
                    min: 150
                }, {
                    width: 480,
                    height: 270,
                    layers: 2,
                    max: 450,
                    target: 350,
                    min: 150
                }, {
                    width: 320,
                    height: 180,
                    layers: 1,
                    max: 200,
                    target: 150,
                    min: 30
                }],
                h = 800,
                f = null;

            function m(e, t, n) {
                if (n < 15e3) return 1;
                var r = 0,
                    i = Math.min(t.height, t.width);
                if (e) {
                    var o = p.find((function(e) {
                        return e.height <= i
                    }));
                    if (o) {
                        var a = function() {
                            var e = i;
                            if (!(o = p.find((function(t) {
                                    return t.height === e
                                })))) return "break";
                            r += o.target
                        };
                        for (i = o.height; i >= 180; i /= 2) {
                            if ("break" === a()) break
                        }
                    }
                } else {
                    var s = t.width * t.height;
                    r = s <= 76800 ? 600 : s <= 307200 ? 1700 : s <= 518400 ? 2e3 : 2500
                }
                return Math.min(r, function(e) {
                    if (e > 6e4) return Number.MAX_SAFE_INTEGER;
                    return h * Math.pow(1.08, e / 1e3)
                }(Math.max(0, n - 1e3)))
            }
            var v = function() {
                function e(t, n, o) {
                    var a = this;
                    ! function(e, t) {
                        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                    }(this, e), this.eventEmitter = n, this._conference = t, this._localStats = {
                        connectionQuality: 100,
                        jvbRTT: void 0
                    }, this._lastConnectionQualityUpdate = -1, this._remoteStats = {}, this._timeIceConnected = -1, this._timeVideoUnmuted = -1, this._timeLastBwCapRemoved = -1, o.config.startBitrate && o.config.startBitrate > 0 && (h = o.config.startBitrate), t.on(i.CONNECTION_INTERRUPTED, (function() {
                        a._updateLocalConnectionQuality(0), a.eventEmitter.emit(r.LOCAL_STATS_UPDATED, a._localStats), a._broadcastLocalStats()
                    })), t.room.addListener(s.ICE_CONNECTION_STATE_CHANGED, (function(e, t) {
                        e.isP2P || "connected" !== t || (a._timeIceConnected = window.performance.now())
                    })), t.on(i.ENDPOINT_MESSAGE_RECEIVED, (function(e, t) {
                        t.type === d && a._updateRemoteStats(e.getId(), t.values)
                    })), t.statistics.addConnectionStatsListener(this._updateLocalStats.bind(this)), t.on(i.TRACK_MUTE_CHANGED, (function(e) {
                        e.isVideoTrack() && (e.isMuted() ? a._timeVideoUnmuted = -1 : a._maybeUpdateUnmuteTime())
                    })), t.on(i.TRACK_ADDED, (function(e) {
                        e.isVideoTrack() && !e.isMuted() && a._maybeUpdateUnmuteTime()
                    })), t.on(i.SERVER_REGION_CHANGED, (function(e) {
                        a._localStats.serverRegion = e
                    })), t.on(i.PROPERTIES_CHANGED, (function(e) {
                        a._localStats.bridgeCount = Number((e || {})["bridge-count"])
                    }))
                }
                var t, n, o;
                return t = e, (n = [{
                    key: "_maybeUpdateUnmuteTime",
                    value: function() {
                        this._timeVideoUnmuted < 0 && (this._timeVideoUnmuted = window.performance.now())
                    }
                }, {
                    key: "_calculateConnectionQuality",
                    value: function(e, t, n) {
                        var r, i = u[n],
                            o = 100;
                        if (this._localStats.packetLoss && (r = this._localStats.packetLoss.upload, t && (r *= .5)), t || !i || e === c.DESKTOP || this._timeIceConnected < 0 || this._timeVideoUnmuted < 0) void 0 === r ? (l.error("Cannot calculate connection quality, unknown packet loss."), o = 100) : o = r <= 2 ? 100 : r <= 4 ? 70 : r <= 6 ? 50 : r <= 8 ? 30 : r <= 12 ? 10 : 0;
                        else {
                            var a = this._conference.getActivePeerConnection(),
                                s = Boolean(a && a.isSimulcastOn()),
                                d = a && a.bandwidthLimiter && a.bandwidthLimiter.getBandwidthLimit("video");
                            !d && f && (this._timeLastBwCapRemoved = window.performance.now(), h = f), f = d;
                            var p = m(s, i, window.performance.now() - Math.max(this._timeVideoUnmuted, this._timeIceConnected, this._timeLastBwCapRemoved));
                            p = Math.min(.9 * p, 2500), f && (p = Math.min(p, f)), o = 100 * this._localStats.bitrate.upload / p, r && r >= 10 && (o = Math.min(o, 30))
                        }
                        if (this._lastConnectionQualityUpdate > 0) {
                            var v = this._localStats.connectionQuality,
                                y = (window.performance.now() - this._lastConnectionQualityUpdate) / 1e3;
                            o = Math.min(o, v + 2 * y)
                        }
                        return Math.min(100, o)
                    }
                }, {
                    key: "_updateLocalConnectionQuality",
                    value: function(e) {
                        this._localStats.connectionQuality = e, this._lastConnectionQualityUpdate = window.performance.now()
                    }
                }, {
                    key: "_broadcastLocalStats",
                    value: function() {
                        var e = {
                            bitrate: this._localStats.bitrate,
                            packetLoss: this._localStats.packetLoss,
                            connectionQuality: this._localStats.connectionQuality,
                            jvbRTT: this._localStats.jvbRTT,
                            serverRegion: this._localStats.serverRegion,
                            avgAudioLevels: this._localStats.localAvgAudioLevels
                        };
                        try {
                            this._conference.broadcastEndpointMessage({
                                type: d,
                                values: e
                            })
                        } catch (e) {}
                    }
                }, {
                    key: "_updateLocalStats",
                    value: function(e, t) {
                        if (!e.isP2P) {
                            var n = t.transport && t.transport.length && t.transport[0].rtt;
                            this._localStats.jvbRTT = n || void 0
                        }
                        if (e === this._conference.getActivePeerConnection()) {
                            var i, o = !this._conference.isConnectionInterrupted(),
                                a = this._conference.getLocalVideoTrack(),
                                s = a ? a.videoType : void 0,
                                c = !a || a.isMuted(),
                                u = a ? a.resolution : null;
                            for (i in c || this._maybeUpdateUnmuteTime(), t) t.hasOwnProperty(i) && (this._localStats[i] = t[i]);
                            o && this._updateLocalConnectionQuality(this._calculateConnectionQuality(s, c, u)), this.eventEmitter.emit(r.LOCAL_STATS_UPDATED, this._localStats), this._broadcastLocalStats()
                        }
                    }
                }, {
                    key: "_updateRemoteStats",
                    value: function(e, t) {
                        this._remoteStats[e] = {
                            bitrate: t.bitrate,
                            packetLoss: t.packetLoss,
                            connectionQuality: t.connectionQuality,
                            jvbRTT: t.jvbRTT,
                            serverRegion: t.serverRegion,
                            avgAudioLevels: t.avgAudioLevels
                        }, this.eventEmitter.emit(r.REMOTE_STATS_UPDATED, e, this._remoteStats[e])
                    }
                }, {
                    key: "getStats",
                    value: function() {
                        return this._localStats
                    }
                }]) && a(t.prototype, n), o && a(t, o), e
            }()
        }).call(this, "modules/connectivity/ConnectionQuality.js")
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return a
            }));
            var r = n(4);

            function i(e, t) {
                for (var n = 0; n < t.length; n++) {
                    var r = t[n];
                    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                }
            }
            var o = Object(r.getLogger)(e),
                a = function() {
                    function e(t) {
                        ! function(e, t) {
                            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                        }(this, e), this._conference = t
                    }
                    var t, n, r;
                    return t = e, (n = [{
                        key: "start",
                        value: function(e) {
                            var t = this;
                            this._conference.xmpp.ping(65e3).then((function() {
                                t._canceled || (t._conference.isJvbConnectionInterrupted ? t._iceFailedTimeout = window.setTimeout((function() {
                                    o.info("Sending ICE failed - the connection has not recovered"), t._iceFailedTimeout = void 0, e.sendIceFailedNotification()
                                }), 2e3) : o.info("ICE connection restored - not sending ICE failed"))
                            }), (function(e) {
                                o.error("PING error/timeout - not sending ICE failed", e)
                            }))
                        }
                    }, {
                        key: "cancel",
                        value: function() {
                            this._canceled = !0, this._iceFailedTimeout && window.clearTimeout(this._iceFailedTimeout)
                        }
                    }]) && i(t.prototype, n), r && i(t, r), e
                }()
        }).call(this, "modules/connectivity/IceFailedNotification.js")
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return h
            }));
            var r = n(4),
                i = n(7),
                o = n(49),
                a = n(2),
                s = n(5);

            function c(e, t) {
                if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
            }

            function u(e, t) {
                for (var n = 0; n < t.length; n++) {
                    var r = t[n];
                    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                }
            }

            function l(e, t, n) {
                return t && u(e.prototype, t), n && u(e, n), e
            }
            var d = Object(r.getLogger)(e),
                p = function() {
                    function e(t, n) {
                        c(this, e), this.participant = t, this.e2eping = n, this.id = t.getId(), this.requests = {}, this.lastRequestId = 1, this.clearIntervals = this.clearIntervals.bind(this), this.sendRequest = this.sendRequest.bind(this), this.handleResponse = this.handleResponse.bind(this), this.maybeSendAnalytics = this.maybeSendAnalytics.bind(this), this.sendAnalytics = this.sendAnalytics.bind(this), n.isDataChannelOpen && this.sendRequest(), this.pingInterval = window.setInterval(this.sendRequest, n.pingIntervalMs), this.analyticsInterval = window.setTimeout(this.maybeSendAnalytics, this.e2eping.analyticsIntervalMs)
                    }
                    return l(e, [{
                        key: "clearIntervals",
                        value: function() {
                            this.pingInterval && window.clearInterval(this.pingInterval), this.analyticsInterval && window.clearInterval(this.analyticsInterval)
                        }
                    }, {
                        key: "sendRequest",
                        value: function() {
                            var e = this.lastRequestId++,
                                t = {
                                    type: "e2e-ping-request",
                                    id: e
                                };
                            this.e2eping.sendMessage(t, this.id), this.requests[e] = {
                                id: e,
                                timeSent: window.performance.now()
                            }
                        }
                    }, {
                        key: "handleResponse",
                        value: function(e) {
                            var t = this.requests[e.id];
                            t && (t.rtt = window.performance.now() - t.timeSent, this.e2eping.eventEmitter.emit(o.E2E_RTT_CHANGED, this.participant, t.rtt)), this.maybeSendAnalytics()
                        }
                    }, {
                        key: "maybeSendAnalytics",
                        value: function() {
                            var e, t, n = window.performance.now(),
                                r = 1 / 0;
                            for (t in this.requests) this.requests.hasOwnProperty(t) && ((e = this.requests[t]).timeSent < n - this.e2eping.analyticsIntervalMs ? delete this.requests[t] : e.rtt && (r = Math.min(r, e.rtt)));
                            r < 1 / 0 && this.sendAnalytics(r)
                        }
                    }, {
                        key: "sendAnalytics",
                        value: function(e) {
                            s.a.sendAnalytics(Object(i.C)(this.id, this.participant.getProperty("region"), e))
                        }
                    }]), e
                }(),
                h = function() {
                    function e(t, n, r) {
                        c(this, e), this.conference = t, this.eventEmitter = t.eventEmitter, this.sendMessage = r, this.pingIntervalMs = 1e4, this.analyticsIntervalMs = 6e4, this.participants = {}, this.isDataChannelOpen = !1, n && n.e2eping && ("number" == typeof n.e2eping.pingInterval && (this.pingIntervalMs = n.e2eping.pingInterval), "number" == typeof n.e2eping.analyticsInterval && (this.analyticsIntervalMs = n.e2eping.analyticsInterval), this.analyticsIntervalMs > 0 && this.analyticsIntervalMs < this.pingIntervalMs && (this.analyticsIntervalMs = this.pingIntervalMs)), d.info("Initializing e2e ping; pingInterval=".concat(this.pingIntervalMs, ", analyticsInterval=").concat(this.analyticsIntervalMs, ".")), this.participantJoined = this.participantJoined.bind(this), t.on(a.USER_JOINED, this.participantJoined), this.participantLeft = this.participantLeft.bind(this), t.on(a.USER_LEFT, this.participantLeft), this.messageReceived = this.messageReceived.bind(this), t.on(a.ENDPOINT_MESSAGE_RECEIVED, this.messageReceived), this.dataChannelOpened = this.dataChannelOpened.bind(this), t.on(a.DATA_CHANNEL_OPENED, this.dataChannelOpened)
                    }
                    return l(e, [{
                        key: "dataChannelOpened",
                        value: function() {
                            for (var e in this.isDataChannelOpen = !0, this.participants)
                                if (this.participants.hasOwnProperty(e)) {
                                    var t = this.participants[e];
                                    window.setTimeout(t.sendRequest, 200)
                                }
                        }
                    }, {
                        key: "messageReceived",
                        value: function(e, t) {
                            "e2e-ping-request" === t.type ? this.handleRequest(e.getId(), t) : "e2e-ping-response" === t.type && this.handleResponse(e.getId(), t)
                        }
                    }, {
                        key: "participantJoined",
                        value: function(e, t) {
                            this.pingIntervalMs <= 0 || (this.participants[e] && (d.info("Participant wrapper already exists for ".concat(e, ". Clearing.")), this.participants[e].clearIntervals(), delete this.participants[e]), this.participants[e] = new p(t, this))
                        }
                    }, {
                        key: "participantLeft",
                        value: function(e) {
                            this.pingIntervalMs <= 0 || this.participants[e] && (this.participants[e].clearIntervals(), delete this.participants[e])
                        }
                    }, {
                        key: "handleRequest",
                        value: function(e, t) {
                            if (t && t.id) {
                                var n = {
                                    type: "e2e-ping-response",
                                    id: t.id
                                };
                                this.sendMessage(n, e)
                            } else d.info("Received an invalid e2e ping request from ".concat(e, "."))
                        }
                    }, {
                        key: "handleResponse",
                        value: function(e, t) {
                            var n = this.participants[e];
                            n && n.handleResponse(t)
                        }
                    }, {
                        key: "stop",
                        value: function() {
                            for (var e in d.info("Stopping e2eping"), this.conference.off(a.USER_JOINED, this.participantJoined), this.conference.off(a.USER_LEFT, this.participantLeft), this.conference.off(a.ENDPOINT_MESSAGE_RECEIVED, this.messageReceived), this.conference.off(a.DATA_CHANNEL_OPENED, this.dataChannelOpened), this.participants) this.participants.hasOwnProperty(e) && this.participants[e].clearIntervals();
                            this.participants = {}
                        }
                    }]), e
                }()
        }).call(this, "modules/e2eping/e2eping.js")
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return s
            }));
            var r = n(4),
                i = n(2);

            function o(e, t) {
                for (var n = 0; n < t.length; n++) {
                    var r = t[n];
                    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                }
            }
            var a = Object(r.getLogger)(e),
                s = function() {
                    function e(t) {
                        var n = this;
                        ! function(e, t) {
                            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                        }(this, e), this._conference = t, this._jvb121 = !0, this._conference.addEventListener(i.USER_JOINED, (function() {
                            return n.evaluateStatus()
                        })), this._conference.addEventListener(i.USER_LEFT, (function() {
                            return n.evaluateStatus()
                        })), this._conference.addEventListener(i.P2P_STATUS, (function() {
                            return n.evaluateStatus()
                        }))
                    }
                    var t, n, r;
                    return t = e, (n = [{
                        key: "evaluateStatus",
                        value: function() {
                            var e = this._jvb121,
                                t = !this._conference.isP2PActive() && this._conference.getParticipantCount() <= 2;
                            e !== t && (this._jvb121 = t, a.debug("JVB121 status ".concat(e, " => ").concat(t)), this._conference.eventEmitter.emit(i.JVB121_STATUS, e, t))
                        }
                    }]) && o(t.prototype, n), r && o(t, r), e
                }()
        }).call(this, "modules/event/Jvb121EventGenerator.js")
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            var r = n(4),
                i = n(0),
                o = n.n(i),
                a = n(58),
                s = n(42);

            function c(e, t, n) {
                return t in e ? Object.defineProperty(e, t, {
                    value: n,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : e[t] = n, e
            }

            function u(e, t) {
                for (var n = 0; n < t.length; n++) {
                    var r = t[n];
                    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                }
            }
            var l = Object(r.getLogger)(e),
                d = function() {
                    function e(t) {
                        ! function(e, t) {
                            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                        }(this, e), this._sessions = {}, this._chatRoom = t, this.onPresence = this.onPresence.bind(this), this._chatRoom.eventEmitter.addListener(o.a.PRESENCE_RECEIVED, this.onPresence)
                    }
                    var t, n, r;
                    return t = e, (n = [{
                        key: "getSession",
                        value: function(e) {
                            return this._sessions[e]
                        }
                    }, {
                        key: "onPresence",
                        value: function(e) {
                            var t = e.fromHiddenDomain,
                                n = e.presence;
                            s.a.isFromFocus(n) ? this._handleFocusPresence(n) : t && this._handleJibriPresence(n)
                        }
                    }, {
                        key: "startRecording",
                        value: function(e) {
                            var t = this,
                                n = new a.a(function(e) {
                                    for (var t = 1; t < arguments.length; t++) {
                                        var n = null != arguments[t] ? arguments[t] : {},
                                            r = Object.keys(n);
                                        "function" == typeof Object.getOwnPropertySymbols && (r = r.concat(Object.getOwnPropertySymbols(n).filter((function(e) {
                                            return Object.getOwnPropertyDescriptor(n, e).enumerable
                                        })))), r.forEach((function(t) {
                                            c(e, t, n[t])
                                        }))
                                    }
                                    return e
                                }({}, e, {
                                    connection: this._chatRoom.connection
                                }));
                            return n.start({
                                appData: e.appData,
                                broadcastId: e.broadcastId,
                                focusMucJid: this._chatRoom.focusMucJid,
                                streamId: e.streamId
                            }).then((function() {
                                return t.getSession(n.getID()) || (t._addSession(n), t._emitSessionUpdate(n)), n
                            })).catch((function(e) {
                                return t._emitSessionUpdate(n), Promise.reject(e)
                            }))
                        }
                    }, {
                        key: "stopRecording",
                        value: function(e) {
                            var t = this.getSession(e);
                            return t ? t.stop({
                                focusMucJid: this._chatRoom.focusMucJid
                            }) : Promise.reject(new Error("Could not find session"))
                        }
                    }, {
                        key: "_addSession",
                        value: function(e) {
                            this._sessions[e.getID()] = e
                        }
                    }, {
                        key: "_createSession",
                        value: function(e, t, n) {
                            var r = new a.a({
                                connection: this._chatRoom.connection,
                                focusMucJid: this._chatRoom.focusMucJid,
                                mode: n,
                                sessionID: e,
                                status: t
                            });
                            return this._addSession(r), r
                        }
                    }, {
                        key: "_emitSessionUpdate",
                        value: function(e, t) {
                            this._chatRoom.eventEmitter.emit(o.a.RECORDER_STATE_CHANGED, e, t)
                        }
                    }, {
                        key: "_handleFocusPresence",
                        value: function(e) {
                            var t = s.a.getFocusRecordingUpdate(e);
                            if (t) {
                                var n = t.error,
                                    r = t.initiator,
                                    i = t.recordingMode,
                                    o = t.sessionID,
                                    a = t.status,
                                    c = this.getSession(o);
                                c || "off" !== a ? c && c.getStatus() === a && c.getError() === n ? l.warn("Ignoring duplicate presence update: ", JSON.stringify(t)) : (c || (c = this._createSession(o, a, i)), c.setStatus(a), n && c.setError(n), this._emitSessionUpdate(c, r)) : l.warn("Ignoring recording presence update", "Received a new session with status off.")
                            }
                        }
                    }, {
                        key: "_handleJibriPresence",
                        value: function(e) {
                            var t = s.a.getHiddenDomainUpdate(e),
                                n = t.liveStreamViewURL,
                                r = t.mode,
                                i = t.sessionID;
                            if (i) {
                                var o = this.getSession(i);
                                o || (o = this._createSession(i, "", r)), o.setLiveStreamViewURL(n), this._emitSessionUpdate(o)
                            } else l.warn("Ignoring potential jibri presence due to no session id.")
                        }
                    }]) && u(t.prototype, n), r && u(t, r), e
                }();
            t.a = d
        }).call(this, "modules/recording/RecordingManager.js")
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return m
            }));
            var r = n(3),
                i = n(7),
                o = n(4),
                a = n(10),
                s = n(5);

            function c(e) {
                return function(e) {
                    if (Array.isArray(e)) {
                        for (var t = 0, n = new Array(e.length); t < e.length; t++) n[t] = e[t];
                        return n
                    }
                }(e) || function(e) {
                    if (Symbol.iterator in Object(e) || "[object Arguments]" === Object.prototype.toString.call(e)) return Array.from(e)
                }(e) || function() {
                    throw new TypeError("Invalid attempt to spread non-iterable instance")
                }()
            }

            function u(e, t) {
                if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
            }

            function l(e, t) {
                for (var n = 0; n < t.length; n++) {
                    var r = t[n];
                    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                }
            }

            function d(e, t, n) {
                return t && l(e.prototype, t), n && l(e, n), e
            }
            var p = Object(o.getLogger)(e),
                h = {
                    offerToReceiveAudio: 1,
                    offerToReceiveVideo: 0
                },
                f = function() {
                    function e(t, n, r, i) {
                        u(this, e), this.region = t, this.getStatsIntervalMs = r, this.getStatsInterval = null, this.rtt = 1 / 0, this.rtts = [];
                        var o = [{
                            url: "stun:".concat(n)
                        }];
                        this.pc = new a.a.RTCPeerConnectionType({
                            iceServers: o
                        }), this.candidates = {}, this.stopped = !1, this.start = this.start.bind(this), this.stop = this.stop.bind(this), this.startStatsInterval = this.startStatsInterval.bind(this), this.handleCandidateRtt = this.handleCandidateRtt.bind(this), window.setTimeout(this.start, i)
                    }
                    return d(e, [{
                        key: "start",
                        value: function() {
                            var e = this;
                            this.stopped || this.pc.createOffer(h).then((function(t) {
                                e.pc.setLocalDescription(t, (function() {
                                    p.info("setLocalDescription success for ".concat(e.region)), e.startStatsInterval()
                                }), (function(t) {
                                    p.warn("setLocalDescription failed for ".concat(e.region, ": ").concat(t))
                                }))
                            }))
                        }
                    }, {
                        key: "startStatsInterval",
                        value: function() {
                            var e = this;
                            this.getStatsInterval = window.setInterval((function() {
                                e.pc.getStats((function(t) {
                                    for (var n = t.result(), r = 0; r < n.length; ++r) {
                                        var i = n[r],
                                            o = Number(i.stat("stunKeepaliveRttTotal"));
                                        if (o > 0) {
                                            var a = "".concat(i.stat("ipAddress"), "_").concat(i.stat("portNumber"), "_").concat(i.stat("priority"));
                                            e.handleCandidateRtt(a, o, Number(i.stat("stunKeepaliveResponsesReceived")), Number(i.stat("stunKeepaliveRequestsSent")))
                                        }
                                    }
                                    var s = 1 / 0;
                                    for (var u in e.candidates) e.candidates.hasOwnProperty(u) && e.candidates[u].rtt > 0 && (s = Math.min(s, e.candidates[u].rtt));
                                    e.rtts.push(s), e.rtts.length > 6 && (e.rtts = e.rtts.splice(1, 7)), e.rtt = Math.min.apply(Math, c(e.rtts))
                                }))
                            }), this.getStatsIntervalMs)
                        }
                    }, {
                        key: "handleCandidateRtt",
                        value: function(e, t, n, r) {
                            this.candidates[e] || (this.candidates[e] = {
                                rttTotal: 0,
                                responsesReceived: 0,
                                requestsSent: 0,
                                rtt: NaN
                            });
                            var i = t - this.candidates[e].rttTotal,
                                o = n - this.candidates[e].responsesReceived,
                                a = r - n - (this.candidates[e].requestsSent - this.candidates[e].responsesReceived),
                                s = NaN;
                            o > 0 && 0 === a && (s = i / o), this.candidates[e].rttTotal = t, this.candidates[e].responsesReceived = n, this.candidates[e].requestsSent = r, this.candidates[e].rtt = s
                        }
                    }, {
                        key: "stop",
                        value: function() {
                            this.getStatsInterval && window.clearInterval(this.getStatsInterval), this.pc.close(), this.stopped = !0
                        }
                    }]), e
                }(),
                m = function() {
                    function e(t) {
                        var n = this;
                        if (u(this, e), t && t.enabled && r.a.supportsLocalCandidateRttStatistics()) {
                            this.pcMonitors = {}, this.startPCMonitors = this.startPCMonitors.bind(this), this.sendAnalytics = this.sendAnalytics.bind(this), this.stop = this.stop.bind(this), this.analyticsInterval = null, this.stopped = !1;
                            var i = t.initialDelay || 6e4;
                            p.info("Starting RTT monitor with an initial delay of ".concat(i)), window.setTimeout((function() {
                                return n.startPCMonitors(t)
                            }), i)
                        }
                    }
                    return d(e, [{
                        key: "startPCMonitors",
                        value: function(e) {
                            var t = this;
                            if (e.stunServers) {
                                if (!this.stopped) {
                                    var n = e.getStatsInterval || 1e4,
                                        r = e.analyticsInterval || n,
                                        i = n / Object.keys(e.stunServers).length,
                                        o = 0;
                                    for (var a in e.stunServers)
                                        if (e.stunServers.hasOwnProperty(a)) {
                                            var s = e.stunServers[a];
                                            this.pcMonitors[a] = new f(a, s, n, i * o), o++
                                        } window.setTimeout((function() {
                                        t.stopped || (t.analyticsInterval = window.setInterval(t.sendAnalytics, r))
                                    }), 1e3)
                                }
                            } else p.warn("No stun servers configured.")
                        }
                    }, {
                        key: "sendAnalytics",
                        value: function() {
                            var e = {};
                            for (var t in this.pcMonitors)
                                if (this.pcMonitors.hasOwnProperty(t)) {
                                    var n = this.pcMonitors[t].rtt;
                                    isNaN(n) || n === 1 / 0 || (e[t.replace("-", "_")] = n)
                                } e && s.a.sendAnalytics(Object(i.L)(e))
                        }
                    }, {
                        key: "stop",
                        value: function() {
                            for (var e in p.info("Stopping RttMonitor."), this.stopped = !0, this.pcMonitors) this.pcMonitors.hasOwnProperty(e) && this.pcMonitors[e].stop();
                            this.pcMonitors = {}, this.analyticsInterval && window.clearInterval(this.analyticsInterval)
                        }
                    }]), e
                }()
        }).call(this, "modules/rttmonitor/rttmonitor.js")
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return y
            }));
            var r = n(7),
                i = n(4),
                o = n(25),
                a = n(2),
                s = n(9),
                c = n(3),
                u = n(5),
                l = n(14);

            function d(e, t) {
                if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
            }

            function p(e, t) {
                for (var n = 0; n < t.length; n++) {
                    var r = t[n];
                    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                }
            }

            function h(e, t, n) {
                return t && p(e.prototype, t), n && p(e, n), e
            }
            var f = Object(i.getLogger)(e),
                m = function() {
                    function e(t) {
                        d(this, e), this.name = t, this.count = 0, this.sum = 0, this.samples = []
                    }
                    return h(e, [{
                        key: "addNext",
                        value: function(e) {
                            "number" != typeof e ? f.error("".concat(this.name, " - invalid value for idx: ").concat(this.count), e) : isNaN(e) || (this.sum += e, this.samples.push(e), this.count += 1)
                        }
                    }, {
                        key: "calculate",
                        value: function() {
                            return this.sum / this.count
                        }
                    }, {
                        key: "appendReport",
                        value: function(e) {
                            e["".concat(this.name, "_avg")] = this.calculate(), e["".concat(this.name, "_samples")] = JSON.stringify(this.samples)
                        }
                    }, {
                        key: "reset",
                        value: function() {
                            this.samples = [], this.sum = 0, this.count = 0
                        }
                    }]), e
                }(),
                v = function() {
                    function e(t, n, r) {
                        var i = this;
                        d(this, e), this.isP2P = n, this._n = r, this._sampleIdx = 0, this._avgRTT = new m("rtt"), this._avgRemoteRTTMap = new Map, this._avgRtpStatsReporter = t, this._avgEnd2EndRTT = void 0, this._onConnectionStats = function(e, t) {
                            i.isP2P === e.isP2P && i._calculateAvgStats(t)
                        };
                        var s = t._conference;
                        s.statistics.addConnectionStatsListener(this._onConnectionStats), this.isP2P || (this._onUserLeft = function(e) {
                            return i._avgRemoteRTTMap.delete(e)
                        }, s.on(a.USER_LEFT, this._onUserLeft), this._onRemoteStatsUpdated = function(e, t) {
                            return i._processRemoteStats(e, t)
                        }, s.on(o.REMOTE_STATS_UPDATED, this._onRemoteStatsUpdated))
                    }
                    return h(e, [{
                        key: "_calculateAvgStats",
                        value: function(e) {
                            if (e) {
                                if (c.a.supportsRTTStatistics() && e.transport && e.transport.length && this._avgRTT.addNext(e.transport[0].rtt), this._sampleIdx += 1, this._sampleIdx >= this._n) {
                                    if (c.a.supportsRTTStatistics()) {
                                        var t = this._avgRtpStatsReporter._conference,
                                            n = {
                                                p2p: this.isP2P,
                                                conference_size: t.getParticipantCount()
                                            };
                                        if (e.transport && e.transport.length && Object.assign(n, {
                                                local_candidate_type: e.transport[0].localCandidateType,
                                                remote_candidate_type: e.transport[0].remoteCandidateType,
                                                transport_type: e.transport[0].type
                                            }), this._avgRTT.appendReport(n), this.isP2P) {
                                            var i = this._avgRtpStatsReporter.jvbStatsMonitor._avgEnd2EndRTT;
                                            isNaN(i) || (n.rtt_diff = this._avgRTT.calculate() - i)
                                        } else {
                                            var o = this._calculateAvgRemoteRTT(),
                                                a = this._avgRTT.calculate();
                                            this._avgEnd2EndRTT = a + o, isNaN(a) || isNaN(o) || (n.end2end_rtt_avg = this._avgEnd2EndRTT)
                                        }
                                        u.a.sendAnalytics(Object(r.K)(n))
                                    }
                                    this._resetAvgStats()
                                }
                            } else f.error("No stats")
                        }
                    }, {
                        key: "_calculateAvgRemoteRTT",
                        value: function() {
                            var e = 0,
                                t = 0,
                                n = !0,
                                r = !1,
                                i = void 0;
                            try {
                                for (var o, a = this._avgRemoteRTTMap.values()[Symbol.iterator](); !(n = (o = a.next()).done); n = !0) {
                                    var s = o.value,
                                        c = s.calculate();
                                    isNaN(c) || (t += c, e += 1, s.reset())
                                }
                            } catch (e) {
                                r = !0, i = e
                            } finally {
                                try {
                                    n || null == a.return || a.return()
                                } finally {
                                    if (r) throw i
                                }
                            }
                            return t / e
                        }
                    }, {
                        key: "_processRemoteStats",
                        value: function(e, t) {
                            var n = "number" == typeof t.jvbRTT,
                                r = this._avgRemoteRTTMap.get(e);
                            !r && n && (r = new m("".concat(e, "_stat_rtt")), this._avgRemoteRTTMap.set(e, r)), n ? r.addNext(t.jvbRTT) : r && this._avgRemoteRTTMap.delete(e)
                        }
                    }, {
                        key: "_resetAvgStats",
                        value: function() {
                            this._avgRTT.reset(), this._avgRemoteRTTMap && this._avgRemoteRTTMap.clear(), this._sampleIdx = 0
                        }
                    }, {
                        key: "dispose",
                        value: function() {
                            var e = this._avgRtpStatsReporter._conference;
                            e.statistics.removeConnectionStatsListener(this._onConnectionStats), this.isP2P || (e.off(o.REMOTE_STATS_UPDATED, this._onRemoteStatsUpdated), e.off(a.USER_LEFT, this._onUserLeft))
                        }
                    }]), e
                }(),
                y = function() {
                    function e(t, n) {
                        var r = this;
                        d(this, e), this._n = n, n > 0 ? (f.info("Avg RTP stats will be calculated every ".concat(n, " samples")), this._sampleIdx = 0, this._conference = t, this._avgAudioBitrateUp = new m("bitrate_audio_upload"), this._avgAudioBitrateDown = new m("bitrate_audio_download"), this._avgVideoBitrateUp = new m("bitrate_video_upload"), this._avgVideoBitrateDown = new m("bitrate_video_download"), this._avgBandwidthUp = new m("bandwidth_upload"), this._avgBandwidthDown = new m("bandwidth_download"), this._avgPacketLossTotal = new m("packet_loss_total"), this._avgPacketLossUp = new m("packet_loss_upload"), this._avgPacketLossDown = new m("packet_loss_download"), this._avgRemoteFPS = new m("framerate_remote"), this._avgRemoteScreenFPS = new m("framerate_screen_remote"), this._avgLocalFPS = new m("framerate_local"), this._avgLocalScreenFPS = new m("framerate_screen_local"), this._avgRemoteCameraPixels = new m("pixels_remote"), this._avgRemoteScreenPixels = new m("pixels_screen_remote"), this._avgLocalCameraPixels = new m("pixels_local"), this._avgLocalScreenPixels = new m("pixels_screen_local"), this._avgCQ = new m("connection_quality"), this._onLocalStatsUpdated = function(e) {
                            return r._calculateAvgStats(e)
                        }, t.on(o.LOCAL_STATS_UPDATED, this._onLocalStatsUpdated), this._onP2PStatusChanged = function() {
                            f.debug("Resetting average stats calculation"), r._resetAvgStats(), r.jvbStatsMonitor._resetAvgStats(), r.p2pStatsMonitor._resetAvgStats()
                        }, t.on(a.P2P_STATUS, this._onP2PStatusChanged), this._onJvb121StatusChanged = function(e, t) {
                            !0 === t && (f.info("Resetting JVB avg RTP stats"), r._resetAvgJvbStats())
                        }, t.on(a.JVB121_STATUS, this._onJvb121StatusChanged), this.jvbStatsMonitor = new v(this, !1, n), this.p2pStatsMonitor = new v(this, !0, n)) : f.info("Avg RTP stats reports are disabled.")
                    }
                    return h(e, [{
                        key: "_calculateAvgStats",
                        value: function(e) {
                            if (e) {
                                var t = this._conference.isP2PActive(),
                                    n = this._conference.getParticipantCount();
                                if (t || !(n < 2)) {
                                    var i = e.bitrate,
                                        o = e.bandwidth,
                                        a = e.packetLoss,
                                        s = e.framerate,
                                        d = e.resolution;
                                    if (i)
                                        if (o)
                                            if (a)
                                                if (s)
                                                    if (d) {
                                                        if (this._avgAudioBitrateUp.addNext(i.audio.upload), this._avgAudioBitrateDown.addNext(i.audio.download), this._avgVideoBitrateUp.addNext(i.video.upload), this._avgVideoBitrateDown.addNext(i.video.download), c.a.supportsBandwidthStatistics() && (this._avgBandwidthUp.addNext(o.upload), this._avgBandwidthDown.addNext(o.download)), this._avgPacketLossUp.addNext(a.upload), this._avgPacketLossDown.addNext(a.download), this._avgPacketLossTotal.addNext(a.total), this._avgCQ.addNext(e.connectionQuality), s && (this._avgRemoteFPS.addNext(this._calculateAvgVideoFps(s, !1, l.CAMERA)), this._avgRemoteScreenFPS.addNext(this._calculateAvgVideoFps(s, !1, l.DESKTOP)), this._avgLocalFPS.addNext(this._calculateAvgVideoFps(s, !0, l.CAMERA)), this._avgLocalScreenFPS.addNext(this._calculateAvgVideoFps(s, !0, l.DESKTOP))), d && (this._avgRemoteCameraPixels.addNext(this._calculateAvgVideoPixels(d, !1, l.CAMERA)), this._avgRemoteScreenPixels.addNext(this._calculateAvgVideoPixels(d, !1, l.DESKTOP)), this._avgLocalCameraPixels.addNext(this._calculateAvgVideoPixels(d, !0, l.CAMERA)), this._avgLocalScreenPixels.addNext(this._calculateAvgVideoPixels(d, !0, l.DESKTOP))), this._sampleIdx += 1, this._sampleIdx >= this._n) {
                                                            var p = {
                                                                p2p: t,
                                                                conference_size: n
                                                            };
                                                            e.transport && e.transport.length && Object.assign(p, {
                                                                local_candidate_type: e.transport[0].localCandidateType,
                                                                remote_candidate_type: e.transport[0].remoteCandidateType,
                                                                transport_type: e.transport[0].type
                                                            }), this._avgAudioBitrateUp.appendReport(p), this._avgAudioBitrateDown.appendReport(p), this._avgVideoBitrateUp.appendReport(p), this._avgVideoBitrateDown.appendReport(p), c.a.supportsBandwidthStatistics() && (this._avgBandwidthUp.appendReport(p), this._avgBandwidthDown.appendReport(p)), this._avgPacketLossUp.appendReport(p), this._avgPacketLossDown.appendReport(p), this._avgPacketLossTotal.appendReport(p), this._avgRemoteFPS.appendReport(p), isNaN(this._avgRemoteScreenFPS.calculate()) || this._avgRemoteScreenFPS.appendReport(p), this._avgLocalFPS.appendReport(p), isNaN(this._avgLocalScreenFPS.calculate()) || this._avgLocalScreenFPS.appendReport(p), this._avgRemoteCameraPixels.appendReport(p), isNaN(this._avgRemoteScreenPixels.calculate()) || this._avgRemoteScreenPixels.appendReport(p), this._avgLocalCameraPixels.appendReport(p), isNaN(this._avgLocalScreenPixels.calculate()) || this._avgLocalScreenPixels.appendReport(p), this._avgCQ.appendReport(p), u.a.sendAnalytics(Object(r.K)(p)), this._resetAvgStats()
                                                        }
                                                    } else f.error("No resolution");
                                    else f.error('No "framerate"');
                                    else f.error('No "packetloss"');
                                    else f.error('No "bandwidth"');
                                    else f.error('No "bitrate"')
                                }
                            } else f.error("No stats")
                        }
                    }, {
                        key: "_calculateAvgVideoPixels",
                        value: function(e, t, n) {
                            for (var r = 0, i = 0, o = this._conference.myUserId(), a = Object.keys(e), s = 0; s < a.length; s++) {
                                var c = a[s];
                                if (t ? c === o : c !== o) {
                                    var u = t ? null : this._conference.getParticipantById(c),
                                        l = e[c];
                                    if ((t || u) && l) {
                                        var d = this._calculatePeerAvgVideoPixels(l, u, n);
                                        isNaN(d) || (r += d, i += 1)
                                    }
                                }
                            }
                            return r / i
                        }
                    }, {
                        key: "_calculatePeerAvgVideoPixels",
                        value: function(e, t, n) {
                            var r = Object.keys(e).map((function(e) {
                                    return Number(e)
                                })),
                                i = null,
                                o = this._conference.getActivePeerConnection();
                            t ? (i = t.getTracksByMediaType(s.b)) && (r = r.filter((function(e) {
                                return i.find((function(t) {
                                    return !t.isMuted() && t.getSSRC() === e && t.videoType === n
                                }))
                            }))) : (i = this._conference.getLocalTracks(s.b), r = r.filter((function(e) {
                                return i.find((function(t) {
                                    return !t.isMuted() && o.getLocalSSRC(t) === e && t.videoType === n
                                }))
                            })));
                            var a = 0,
                                c = 0,
                                u = !0,
                                l = !1,
                                d = void 0;
                            try {
                                for (var p, h = r[Symbol.iterator](); !(u = (p = h.next()).done); u = !0) {
                                    var f = p.value,
                                        m = Number(e[f].height) * Number(e[f].width);
                                    !isNaN(m) && m > 0 && (a += m, c += 1)
                                }
                            } catch (e) {
                                l = !0, d = e
                            } finally {
                                try {
                                    u || null == h.return || h.return()
                                } finally {
                                    if (l) throw d
                                }
                            }
                            return a / c
                        }
                    }, {
                        key: "_calculateAvgVideoFps",
                        value: function(e, t, n) {
                            for (var r = 0, i = 0, o = this._conference.myUserId(), a = Object.keys(e), s = 0; s < a.length; s++) {
                                var c = a[s];
                                if (t ? c === o : c !== o) {
                                    var u = t ? null : this._conference.getParticipantById(c),
                                        l = e[c];
                                    if ((t || u) && l) {
                                        var d = this._calculatePeerAvgVideoFps(l, u, n);
                                        isNaN(d) || (r += d, i += 1)
                                    }
                                }
                            }
                            return r / i
                        }
                    }, {
                        key: "_calculatePeerAvgVideoFps",
                        value: function(e, t, n) {
                            var r = Object.keys(e).map((function(e) {
                                    return Number(e)
                                })),
                                i = null,
                                o = this._conference.getActivePeerConnection();
                            t ? (i = t.getTracksByMediaType(s.b)) && (r = r.filter((function(e) {
                                return i.find((function(t) {
                                    return !t.isMuted() && t.getSSRC() === e && t.videoType === n
                                }))
                            }))) : (i = this._conference.getLocalTracks(s.b), r = r.filter((function(e) {
                                return i.find((function(t) {
                                    return !t.isMuted() && o.getLocalSSRC(t) === e && t.videoType === n
                                }))
                            })));
                            var a = 0,
                                c = 0,
                                u = !0,
                                l = !1,
                                d = void 0;
                            try {
                                for (var p, h = r[Symbol.iterator](); !(u = (p = h.next()).done); u = !0) {
                                    var f = p.value,
                                        m = Number(e[f]);
                                    !isNaN(m) && m > 0 && (a += m, c += 1)
                                }
                            } catch (e) {
                                l = !0, d = e
                            } finally {
                                try {
                                    u || null == h.return || h.return()
                                } finally {
                                    if (l) throw d
                                }
                            }
                            return a / c
                        }
                    }, {
                        key: "_resetAvgJvbStats",
                        value: function() {
                            this._resetAvgStats(), this.jvbStatsMonitor._resetAvgStats()
                        }
                    }, {
                        key: "_resetAvgStats",
                        value: function() {
                            this._avgAudioBitrateUp.reset(), this._avgAudioBitrateDown.reset(), this._avgVideoBitrateUp.reset(), this._avgVideoBitrateDown.reset(), this._avgBandwidthUp.reset(), this._avgBandwidthDown.reset(), this._avgPacketLossUp.reset(), this._avgPacketLossDown.reset(), this._avgPacketLossTotal.reset(), this._avgRemoteFPS.reset(), this._avgRemoteScreenFPS.reset(), this._avgLocalFPS.reset(), this._avgLocalScreenFPS.reset(), this._avgRemoteCameraPixels.reset(), this._avgRemoteScreenPixels.reset(), this._avgLocalCameraPixels.reset(), this._avgLocalScreenPixels.reset(), this._avgCQ.reset(), this._sampleIdx = 0
                        }
                    }, {
                        key: "dispose",
                        value: function() {
                            this._conference.off(a.P2P_STATUS, this._onP2PStatusChanged), this._conference.off(o.LOCAL_STATS_UPDATED, this._onLocalStatsUpdated), this._conference.off(a.JVB121_STATUS, this._onJvb121StatusChanged), this.jvbStatsMonitor.dispose(), this.p2pStatsMonitor.dispose()
                        }
                    }]), e
                }()
        }).call(this, "modules/statistics/AvgRTPStatsReporter.js")
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return d
            }));
            var r = n(4),
                i = n(2),
                o = n(25),
                a = n(9),
                s = n(7),
                c = n(5);

            function u(e, t) {
                for (var n = 0; n < t.length; n++) {
                    var r = t[n];
                    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                }
            }
            var l = Object(r.getLogger)(e),
                d = function() {
                    function e(t) {
                        ! function(e, t) {
                            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                        }(this, e), this._conference = t, this._localAudioLevelCache = {}, this._reportedParticipants = [], this._audioProblemCandidates = {}, this._numberOfRemoteAudioLevelsReceived = {}, this._onLocalAudioLevelsReport = this._onLocalAudioLevelsReport.bind(this), this._onRemoteAudioLevelReceived = this._onRemoteAudioLevelReceived.bind(this), this._clearUserData = this._clearUserData.bind(this), this._conference.on(o.REMOTE_STATS_UPDATED, this._onRemoteAudioLevelReceived), this._conference.statistics.addConnectionStatsListener(this._onLocalAudioLevelsReport), this._conference.on(i.USER_LEFT, this._clearUserData)
                    }
                    var t, n, r;
                    return t = e, (n = [{
                        key: "_onRemoteAudioLevelReceived",
                        value: function(e, t) {
                            var n = t.avgAudioLevels,
                                r = this._numberOfRemoteAudioLevelsReceived[e] + 1 || 0;
                            if (this._numberOfRemoteAudioLevelsReceived[e] = r, !(-1 !== this._reportedParticipants.indexOf(e) || e in this._audioProblemCandidates || n <= 0 || r < 3)) {
                                var i = this._conference.getParticipantById(e);
                                if (i && i.getTracksByMediaType(a.a).length > 0 && i.isAudioMuted()) return;
                                var o = this._localAudioLevelCache[e];
                                Array.isArray(o) && !o.every((function(e) {
                                    return 0 === e
                                })) || (this._audioProblemCandidates[e] = {
                                    remoteAudioLevels: n,
                                    localAudioLevels: []
                                })
                            }
                        }
                    }, {
                        key: "_onLocalAudioLevelsReport",
                        value: function(e, t) {
                            var n = this,
                                r = t.avgAudioLevels;
                            e === this._conference.getActivePeerConnection() && (Object.keys(r).forEach((function(e) {
                                if (-1 === n._reportedParticipants.indexOf(e)) {
                                    var t = n._localAudioLevelCache[e];
                                    Array.isArray(t) ? t.length >= 2 && t.shift() : n._localAudioLevelCache[e] = [], n._localAudioLevelCache[e].push(r[e])
                                }
                            })), Object.keys(this._audioProblemCandidates).forEach((function(e) {
                                var t = n._audioProblemCandidates[e],
                                    i = t.localAudioLevels,
                                    o = t.remoteAudioLevels;
                                if (i.push(r[e]), 2 === i.length) {
                                    if (i.every((function(e) {
                                            return void 0 === e || 0 === e
                                        }))) {
                                        var a = JSON.stringify(i);
                                        c.a.sendAnalytics(Object(s.x)(e, a, o)), l.warn("A potential problem is detected with the audio output for participant ".concat(e, ", local audio levels: ").concat(a, ", remote audio levels: ").concat(o)), n._reportedParticipants.push(e), n._clearUserData(e)
                                    }
                                    delete n._audioProblemCandidates[e]
                                }
                            })))
                        }
                    }, {
                        key: "_clearUserData",
                        value: function(e) {
                            delete this._localAudioLevelCache[e]
                        }
                    }, {
                        key: "dispose",
                        value: function() {
                            this._conference.off(o.REMOTE_STATS_UPDATED, this._onRemoteAudioLevelReceived), this._conference.off(i.USER_LEFT, this._clearUserData), this._conference.statistics.removeConnectionStatsListener(this._onLocalAudioLevelsReport), this._localAudioLevelCache = void 0, this._audioProblemCandidates = void 0, this._reportedParticipants = void 0, this._numberOfRemoteAudioLevelsReceived = void 0, this._conference = void 0
                        }
                    }]) && u(t.prototype, n), r && u(t, r), e
                }()
        }).call(this, "modules/statistics/AudioOutputProblemDetector.js")
    }, function(e, t, n) {
        "use strict";
        n.d(t, "a", (function() {
            return u
        }));
        var r = n(2),
            i = n(55),
            o = n.n(i),
            a = n(0),
            s = n.n(a);

        function c(e, t) {
            for (var n = 0; n < t.length; n++) {
                var r = t[n];
                r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
            }
        }
        var u = function() {
            function e(t) {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this.stats = {
                    users: {},
                    dominantSpeakerId: null
                };
                var n = t.myUserId();
                this.stats.users[n] = new o.a(n, null, !0), t.addEventListener(r.DOMINANT_SPEAKER_CHANGED, this._onDominantSpeaker.bind(this)), t.addEventListener(r.USER_JOINED, this._onUserJoin.bind(this)), t.addEventListener(r.USER_LEFT, this._onUserLeave.bind(this)), t.addEventListener(r.DISPLAY_NAME_CHANGED, this._onDisplayNameChange.bind(this)), t.xmpp && t.xmpp.addListener(s.a.SPEAKER_STATS_RECEIVED, this._updateStats.bind(this))
            }
            var t, n, i;
            return t = e, (n = [{
                key: "_onDominantSpeaker",
                value: function(e) {
                    var t = this.stats.users[this.stats.dominantSpeakerId],
                        n = this.stats.users[e];
                    t && t.setDominantSpeaker(!1), n && n.setDominantSpeaker(!0), this.stats.dominantSpeakerId = e
                }
            }, {
                key: "_onUserJoin",
                value: function(e, t) {
                    var n = this.stats.users[e];
                    n || (n = this.stats.users[e] = new o.a(e, t.getDisplayName()))
                }
            }, {
                key: "_onUserLeave",
                value: function(e) {
                    var t = this.stats.users[e];
                    t && t.markAsHasLeft()
                }
            }, {
                key: "_onDisplayNameChange",
                value: function(e, t) {
                    var n = this.stats.users[e];
                    n && n.setDisplayName(t)
                }
            }, {
                key: "getStats",
                value: function() {
                    return this.stats.users
                }
            }, {
                key: "_updateStats",
                value: function(e) {
                    for (var t in e) {
                        var n = void 0;
                        this.stats.users[t] ? (n = this.stats.users[t]).getDisplayName() || n.setDisplayName(e[t].displayName) : (n = new o.a(t, e[t].displayName), this.stats.users[t] = n, n.markAsHasLeft()), n.totalDominantSpeakerTime = e[t].totalDominantSpeakerTime
                    }
                }
            }]) && c(t.prototype, n), i && c(t, i), e
        }()
    }, function(e, t, n) {
        var r = n(64),
            i = n(148),
            o = "before";

        function a() {
            this.audioRecorder = new r, this.transcriptionService = new i, this.counter = null, this.startTime = null, this.transcription = null, this.callback = null, this.results = [], this.state = o, this.lineLength = 0
        }

        function s(e, t) {
            if (console.debug("retrieved an answer from the transcription service. The answer has an" + " array of length: ".concat(t.wordArray.length)), t.wordArray.length > 0) {
                var n = t.startTime.getUTCMilliseconds() - e.startTime.getUTCMilliseconds();
                n < 0 && (n = 0);
                var r = "[";
                t.wordArray.forEach((function(e) {
                    e.begin += n, e.end += n, r += "".concat(e.word, ",")
                })), r += "]", console.debug(r), t.wordArray.name = t.name
            }
            e.results.push(t.wordArray), e.counter--, console.debug("current counter: ".concat(e.counter)), e.maybeMerge()
        }

        function c(e) {
            for (var t = 0; t < e.length; t++) 0 === e[t].length && e.splice(t, 1);
            return e.length > 0
        }
        a.prototype.start = function() {
            if (this.state !== o) throw new Error("The transcription can only start when it's in the \"".concat(o, '" state. It\'s currently in the "').concat(this.state, '" state'));
            this.state = "recording", this.audioRecorder.start(), this.startTime = new Date
        }, a.prototype.stop = function(e) {
            var t = this;
            if ("recording" !== this.state) throw new Error("The transcription can only stop when it's in the \"".concat("recording", '" state. It\'s currently in the "').concat(this.state, '" state'));
            console.debug("stopping recording and sending audio files"), this.audioRecorder.stop();
            var n = s.bind(null, this);
            this.audioRecorder.getRecordingResults().forEach((function(e) {
                t.transcriptionService.send(e, n), t.counter++
            })), this.state = "transcribing", this.callback = e
        }, a.prototype.maybeMerge = function() {
            "transcribing" === this.state && 0 === this.counter && this.merge()
        }, a.prototype.merge = function() {
            var e = this;
            console.debug("starting merge process!\n The length of the array: ".concat(this.results.length)), this.transcription = "";
            var t = this.results,
                n = [];
            c(t), t.forEach((function(e) {
                return function(e, t) {
                    if (0 === e.length) e.push(t);
                    else {
                        if (e[e.length - 1].begin <= t.begin) return void e.push(t);
                        for (var n = 0; n < e.length; n++)
                            if (t.begin < e[n].begin) return void e.splice(n, 0, t);
                        e.push(t)
                    }
                }(n, e)
            }));
            for (var r = function() {
                    var n = t[0];
                    t.forEach((function(e) {
                        e[0].begin < n[0].begin && (n = e)
                    }));
                    var r = n.shift();
                    e.updateTranscription(r, n.name);
                    for (var i = function() {
                            var i = !1,
                                o = n[0].begin;
                            if (t.forEach((function(e) {
                                    e[0].begin < o && (i = !0)
                                })), i) return "break";
                            r = n.shift(), e.updateTranscription(r, null)
                        }; n.length > 0;) {
                        if ("break" === i()) break
                    }
                }; c(t);) r();
            this.state = "finished", this.callback && this.callback(this.transcription)
        }, a.prototype.updateTranscription = function(e, t) {
            null != t && (this.transcription += "\n".concat(t, ":"), this.lineLength = t.length + 1), this.lineLength + e.word.length > 80 && (this.transcription += "\n    ", this.lineLength = 4), this.transcription += " ".concat(e.word), this.lineLength += e.word.length + 1
        }, a.prototype.addTrack = function(e) {
            this.audioRecorder.addTrack(e)
        }, a.prototype.removeTrack = function(e) {
            this.audioRecorder.removeTrack(e)
        }, a.prototype.getTranscription = function() {
            if ("finished" !== this.state) throw new Error("The transcription can only be retrieved when it's in the \"".concat("finished", '" state. It\'s currently in the "').concat(this.state, '" state'));
            return this.transcription
        }, a.prototype.getState = function() {
            return this.state
        }, a.prototype.reset = function() {
            this.state = o, this.counter = null, this.transcription = null, this.startTime = null, this.callback = null, this.results = [], this.lineLength = 0
        }, e.exports = a
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return o
            }));
            var r = n(5),
                i = n(4).getLogger(e);

            function o(e) {
                this.versions = {}, this.conference = e, this.conference.addCommandListener("versions", this.processVersions.bind(this))
            }
            o.prototype.processVersions = function(e, t, n) {
                var o = this;
                if (this.conference._isFocus(n)) {
                    var a = [];
                    e.children.forEach((function(e) {
                        var t = e.attributes.name,
                            n = e.value;
                        o.versions[t] !== n && (o.versions[t] = n, i.info("Got ".concat(t, " version: ").concat(n)), a.push({
                            id: "component_version",
                            component: t,
                            version: n
                        }))
                    })), a.length > 0 && r.a.sendLog(JSON.stringify(a))
                } else i.warn("Received versions not from the focus user: ".concat(e), n)
            }, o.prototype.getComponentVersion = function(e) {
                return this.versions[e]
            }
        }).call(this, "modules/version/ComponentsVersions.js")
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return l
            }));
            var r = n(4),
                i = n(114),
                o = n(20),
                a = n(0),
                s = n.n(a);

            function c(e, t) {
                for (var n = 0; n < t.length; n++) {
                    var r = t[n];
                    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                }
            }
            var u = Object(r.getLogger)(e),
                l = function() {
                    function e(t) {
                        ! function(e, t) {
                            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                        }(this, e), this.chatRoom = t, this.eventEmitter = t.eventEmitter, u.debug("creating VideoSIPGW"), this.sessions = {}, this.sessionStateChangeListener = this.sessionStateChanged.bind(this), t.addPresenceListener("jibri-sip-call-state", this.handleJibriSIPState.bind(this))
                    }
                    var t, n, r;
                    return t = e, (n = [{
                        key: "handleJibriSIPState",
                        value: function(e) {
                            var t = e.attributes;
                            if (t) {
                                u.debug("Handle video sip gw state : ", t);
                                var n = t.state;
                                if (n !== this.state) switch (n) {
                                    case o.STATE_ON:
                                    case o.STATE_OFF:
                                    case o.STATE_PENDING:
                                    case o.STATE_RETRYING:
                                    case o.STATE_FAILED:
                                        var r = t.sipaddress;
                                        if (!r) return;
                                        var i = this.sessions[r];
                                        i ? i.setState(n, t.failure_reason) : u.warn("Video SIP GW session not found:", r)
                                }
                            }
                        }
                    }, {
                        key: "createVideoSIPGWSession",
                        value: function(e, t) {
                            if (this.sessions[e]) return u.warn("There was already a Video SIP GW session for address", e), new Error(o.ERROR_SESSION_EXISTS);
                            var n = new i.a(e, t, this.chatRoom);
                            return n.addStateListener(this.sessionStateChangeListener), this.sessions[e] = n, n
                        }
                    }, {
                        key: "sessionStateChanged",
                        value: function(e) {
                            var t = e.address;
                            if (e.newState === o.STATE_OFF || e.newState === o.STATE_FAILED) {
                                var n = this.sessions[t];
                                if (!n) return void u.error("Missing Video SIP GW session with address:", t);
                                n.removeStateListener(this.sessionStateChangeListener), delete this.sessions[t]
                            }
                            this.eventEmitter.emit(s.a.VIDEO_SIP_GW_SESSION_STATE_CHANGED, e)
                        }
                    }]) && c(t.prototype, n), r && c(t, r), e
                }()
        }).call(this, "modules/videosipgw/VideoSIPGW.js")
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return h
            }));
            var r = n(4),
                i = n(1),
                o = n(24),
                a = n(20);

            function s(e) {
                return (s = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                    return typeof e
                } : function(e) {
                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                })(e)
            }

            function c(e, t) {
                for (var n = 0; n < t.length; n++) {
                    var r = t[n];
                    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                }
            }

            function u(e, t) {
                return !t || "object" !== s(t) && "function" != typeof t ? function(e) {
                    if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return e
                }(e) : t
            }

            function l(e) {
                return (l = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
                    return e.__proto__ || Object.getPrototypeOf(e)
                })(e)
            }

            function d(e, t) {
                return (d = Object.setPrototypeOf || function(e, t) {
                    return e.__proto__ = t, e
                })(e, t)
            }
            var p = Object(r.getLogger)(e),
                h = function(e) {
                    function t(e, n, r) {
                        var i;
                        return function(e, t) {
                            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                        }(this, t), (i = u(this, l(t).call(this))).sipAddress = e, i.displayName = n, i.chatRoom = r, i.state = void 0, i
                    }
                    var n, r, o;
                    return function(e, t) {
                        if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
                        e.prototype = Object.create(t && t.prototype, {
                            constructor: {
                                value: e,
                                writable: !0,
                                configurable: !0
                            }
                        }), t && d(e, t)
                    }(t, e), n = t, (r = [{
                        key: "stop",
                        value: function() {
                            this.state !== a.STATE_OFF && this.state !== a.STATE_FAILED ? this._sendJibriIQ("stop") : p.warn("Video SIP GW session already stopped or failed!")
                        }
                    }, {
                        key: "start",
                        value: function() {
                            this.state !== a.STATE_ON && this.state !== a.STATE_OFF && this.state !== a.STATE_PENDING && this.state !== a.STATE_RETRYING ? this._sendJibriIQ("start") : p.warn("Video SIP GW session already started!")
                        }
                    }, {
                        key: "setState",
                        value: function(e, t) {
                            if (e !== this.state) {
                                var n = this.state;
                                this.state = e, this.eventEmitter.emit("STATE_CHANGED", {
                                    address: this.sipAddress,
                                    failureReason: t,
                                    oldState: n,
                                    newState: this.state,
                                    displayName: this.displayName
                                })
                            }
                        }
                    }, {
                        key: "addStateListener",
                        value: function(e) {
                            this.addListener("STATE_CHANGED", e)
                        }
                    }, {
                        key: "removeStateListener",
                        value: function(e) {
                            this.removeListener("STATE_CHANGED", e)
                        }
                    }, {
                        key: "_sendJibriIQ",
                        value: function(e) {
                            var t = this,
                                n = {
                                    xmlns: "http://jitsi.org/protocol/jibri",
                                    action: e,
                                    sipaddress: this.sipAddress
                                };
                            n.displayname = this.displayName;
                            var r = Object(i.$iq)({
                                to: this.chatRoom.focusMucJid,
                                type: "set"
                            }).c("jibri", n).up();
                            p.debug("".concat(e, " video SIP GW session"), r.nodeTree), this.chatRoom.connection.sendIQ(r, (function() {}), (function(n) {
                                p.error("Failed to ".concat(e, " video SIP GW session, error: "), n), t.setState(a.STATE_FAILED)
                            }))
                        }
                    }]) && c(n.prototype, r), o && c(n, o), t
                }(o.a)
        }).call(this, "modules/videosipgw/JitsiVideoSIPGWSession.js")
    }, function(e, t, n) {
        "use strict";
        t.a = {
            error: {
                BUSY: "busy",
                ERROR: "error",
                RESOURCE_CONSTRAINT: "resource-constraint",
                SERVICE_UNAVAILABLE: "service-unavailable"
            },
            mode: {
                FILE: "file",
                STREAM: "stream"
            },
            status: {
                OFF: "off",
                ON: "on",
                PENDING: "pending"
            }
        }
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return v
            }));
            var r = n(4),
                i = n(1),
                o = n(9),
                a = n(14),
                s = n.n(a),
                c = n(13),
                u = n(117),
                l = n(27);

            function d(e) {
                for (var t = 1; t < arguments.length; t++) {
                    var n = null != arguments[t] ? arguments[t] : {},
                        r = Object.keys(n);
                    "function" == typeof Object.getOwnPropertySymbols && (r = r.concat(Object.getOwnPropertySymbols(n).filter((function(e) {
                        return Object.getOwnPropertyDescriptor(n, e).enumerable
                    })))), r.forEach((function(t) {
                        p(e, t, n[t])
                    }))
                }
                return e
            }

            function p(e, t, n) {
                return t in e ? Object.defineProperty(e, t, {
                    value: n,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : e[t] = n, e
            }

            function h(e, t) {
                if (null == e) return {};
                var n, r, i = function(e, t) {
                    if (null == e) return {};
                    var n, r, i = {},
                        o = Object.keys(e);
                    for (r = 0; r < o.length; r++) n = o[r], t.indexOf(n) >= 0 || (i[n] = e[n]);
                    return i
                }(e, t);
                if (Object.getOwnPropertySymbols) {
                    var o = Object.getOwnPropertySymbols(e);
                    for (r = 0; r < o.length; r++) n = o[r], t.indexOf(n) >= 0 || Object.prototype.propertyIsEnumerable.call(e, n) && (i[n] = e[n])
                }
                return i
            }

            function f(e, t) {
                for (var n = 0; n < t.length; n++) {
                    var r = t[n];
                    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                }
            }
            var m = Object(r.getLogger)(e),
                v = function() {
                    function e() {
                        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                        ! function(e, t) {
                            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                        }(this, e);
                        var n = t.jitsiConnection,
                            r = h(t, ["jitsiConnection"]);
                        this._options = d({
                            iceConfig: n && n.xmpp.connection.jingle.p2pIceConfig
                        }, r), this._peerConnection = null, this._onFatalError = this._onFatalError.bind(this), this._onSendMessage = this._onSendMessage.bind(this), this._onRemoteStream = this._onRemoteStream.bind(this)
                    }
                    var t, n, r;
                    return t = e, (n = [{
                        key: "processMessage",
                        value: function(e) {
                            var t = e.from;
                            if (t)
                                if (this._peerConnection && this._peerConnection.getPeerJid() !== t) this._onFatalError(t, l.a.CONNECTION_ERROR, "rejected");
                                else {
                                    var n = this._convertStringToXML(e.data.iq),
                                        r = n && n.find("jingle"),
                                        i = r && r.attr("action");
                                    i === l.a.INITIATE && (this._peerConnection = this._createPeerConnection(t, {
                                        isInitiator: !1,
                                        receiveVideo: !0
                                    })), this._peerConnection && this._peerConnection.processMessage(r), i !== l.a.CONNECTION_ERROR && i !== l.a.UNAVAILABLE && i !== l.a.TERMINATE || this._selfCloseConnection()
                                }
                        }
                    }, {
                        key: "start",
                        value: function(e) {
                            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
                            this._peerConnection = this._createPeerConnection(e, {
                                isInitiator: !0,
                                receiveVideo: !1
                            }), this._peerConnection.start(t)
                        }
                    }, {
                        key: "stop",
                        value: function() {
                            this._peerConnection && this._peerConnection.stop(), this._peerConnection = null
                        }
                    }, {
                        key: "_convertStringToXML",
                        value: function(e) {
                            try {
                                var t = (new DOMParser).parseFromString(e, "text/xml");
                                return $(t)
                            } catch (e) {
                                return m.error("Attempted to convert incorrectly formatted xml"), null
                            }
                        }
                    }, {
                        key: "_createPeerConnection",
                        value: function(e) {
                            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                            if (!e) throw new Error("Cannot create ProxyConnectionPC without a peer.");
                            var n = d({
                                iceConfig: this._options.iceConfig,
                                onError: this._onFatalError,
                                onRemoteStream: this._onRemoteStream,
                                onSendMessage: this._onSendMessage,
                                peerJid: e
                            }, t);
                            return new u.a(n)
                        }
                    }, {
                        key: "_onFatalError",
                        value: function(e, t) {
                            var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "";
                            m.error("Received a proxy connection error", e, t, n);
                            var r = Object(i.$iq)({
                                to: e,
                                type: "set"
                            }).c("jingle", {
                                xmlns: "urn:xmpp:jingle:1",
                                action: t
                            }).c("details").t(n).up();
                            this._onSendMessage(e, r), this._peerConnection && this._peerConnection.getPeerJid() === e && this._selfCloseConnection()
                        }
                    }, {
                        key: "_onRemoteStream",
                        value: function(e) {
                            if (!this._options.onRemoteStream) return m.error("Remote track received without callback."), void e.dispose();
                            var t, n = e.isVideoTrack();
                            n && (t = this._options.convertVideoToDesktop ? s.a.DESKTOP : s.a.CAMERA);
                            var r = e.getOriginalStream(),
                                i = c.a.newCreateLocalTracks([{
                                    deviceId: "proxy:".concat(this._peerConnection.getPeerJid()),
                                    mediaType: n ? o.b : o.a,
                                    sourceType: "proxy",
                                    stream: r,
                                    track: r.getVideoTracks()[0],
                                    videoType: t
                                }]);
                            this._options.onRemoteStream(i[0])
                        }
                    }, {
                        key: "_onSendMessage",
                        value: function(e, t) {
                            if (this._options.onSendMessage) try {
                                var n = (new XMLSerializer).serializeToString(t.nodeTree || t);
                                this._options.onSendMessage(e, {
                                    iq: n
                                })
                            } catch (e) {
                                m.error("Attempted to send an incorrectly formatted iq.")
                            }
                        }
                    }, {
                        key: "_selfCloseConnection",
                        value: function() {
                            this.stop(), this._options.onConnectionClosed && this._options.onConnectionClosed()
                        }
                    }]) && f(t.prototype, n), r && f(t, r), e
                }()
        }).call(this, "modules/proxyconnection/ProxyConnectionService.js")
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return v
            }));
            var r = n(4),
                i = n(13),
                o = n(8),
                a = n.n(o),
                s = n(0),
                c = n.n(s),
                u = n(44),
                l = n(35),
                d = n(27);

            function p(e) {
                for (var t = 1; t < arguments.length; t++) {
                    var n = null != arguments[t] ? arguments[t] : {},
                        r = Object.keys(n);
                    "function" == typeof Object.getOwnPropertySymbols && (r = r.concat(Object.getOwnPropertySymbols(n).filter((function(e) {
                        return Object.getOwnPropertyDescriptor(n, e).enumerable
                    })))), r.forEach((function(t) {
                        h(e, t, n[t])
                    }))
                }
                return e
            }

            function h(e, t, n) {
                return t in e ? Object.defineProperty(e, t, {
                    value: n,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : e[t] = n, e
            }

            function f(e, t) {
                for (var n = 0; n < t.length; n++) {
                    var r = t[n];
                    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                }
            }
            var m = Object(r.getLogger)(e),
                v = function() {
                    function e() {
                        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                        ! function(e, t) {
                            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                        }(this, e), this._options = p({
                            iceConfig: {},
                            isInitiator: !1,
                            receiveAudio: !1,
                            receiveVideo: !1
                        }, t), this._tracks = [], this._peerConnection = null, this._onError = this._onError.bind(this), this._onRemoteStream = this._onRemoteStream.bind(this), this._onSendMessage = this._onSendMessage.bind(this)
                    }
                    var t, n, r;
                    return t = e, (n = [{
                        key: "getPeerJid",
                        value: function() {
                            return this._options.peerJid
                        }
                    }, {
                        key: "processMessage",
                        value: function(e) {
                            switch (e.attr("action")) {
                                case d.a.ACCEPT:
                                    this._onSessionAccept(e);
                                    break;
                                case d.a.INITIATE:
                                    this._onSessionInitiate(e);
                                    break;
                                case d.a.TERMINATE:
                                    this._onSessionTerminate(e);
                                    break;
                                case d.a.TRANSPORT_INFO:
                                    this._onTransportInfo(e)
                            }
                        }
                    }, {
                        key: "start",
                        value: function() {
                            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
                            this._peerConnection || (this._tracks = this._tracks.concat(e), this._peerConnection = this._createPeerConnection(), this._peerConnection.invite(e))
                        }
                    }, {
                        key: "stop",
                        value: function() {
                            this._peerConnection && this._peerConnection.terminate(), this._onSessionTerminate()
                        }
                    }, {
                        key: "_createPeerConnection",
                        value: function() {
                            var e = this,
                                t = {
                                    jingle: {
                                        terminate: function() {}
                                    },
                                    sendIQ: this._onSendMessage
                                },
                                n = p({
                                    iceServers: l.a
                                }, this._options.iceConfig),
                                r = {
                                    addPresenceListener: function() {},
                                    connectionTimes: [],
                                    eventEmitter: {
                                        emit: function(t) {
                                            switch (t) {
                                                case c.a.CONNECTION_ICE_FAILED:
                                                case c.a.CONNECTION_FAILED:
                                                    e._onError(d.a.CONNECTION_ERROR, t)
                                            }
                                        }
                                    },
                                    getMediaPresenceInfo: function() {
                                        return {}
                                    },
                                    removePresenceListener: function() {}
                                };
                            this._rtc = new i.a(this, {}), this._rtc.addListener(a.a.REMOTE_TRACK_ADDED, this._onRemoteStream);
                            var o = new u.a(void 0, void 0, this._options.peerJid, t, {
                                offerToReceiveAudio: this._options.receiveAudio,
                                offerToReceiveVideo: this._options.receiveVideo
                            }, n, !0, this._options.isInitiator);
                            return o.initialize(r, this._rtc, {}), o
                        }
                    }, {
                        key: "_onError",
                        value: function(e) {
                            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "";
                            this._options.onError(this._options.peerJid, e, t)
                        }
                    }, {
                        key: "_onRemoteStream",
                        value: function(e) {
                            this._tracks.push(e), this._options.onRemoteStream(e)
                        }
                    }, {
                        key: "_onSendMessage",
                        value: function(e) {
                            this._options.onSendMessage(this._options.peerJid, e)
                        }
                    }, {
                        key: "_onSessionAccept",
                        value: function(e) {
                            this._peerConnection ? this._peerConnection.setAnswer(e) : m.error("Received an answer when no peer connection exists.")
                        }
                    }, {
                        key: "_onSessionInitiate",
                        value: function(e) {
                            var t = this;
                            this._peerConnection ? m.error("Received an offer when an offer was already sent.") : (this._peerConnection = this._createPeerConnection(), this._peerConnection.acceptOffer(e, (function() {}), (function() {
                                return t._onError(t._options.peerJid, d.a.CONNECTION_ERROR, "session initiate error")
                            })))
                        }
                    }, {
                        key: "_onSessionTerminate",
                        value: function() {
                            this._tracks.forEach((function(e) {
                                return e.dispose()
                            })), this._tracks = [], this._peerConnection && this._peerConnection.onTerminated(), this._rtc && (this._rtc.removeListener(a.a.REMOTE_TRACK_ADDED, this._onRemoteStream), this._rtc.destroy())
                        }
                    }, {
                        key: "_onTransportInfo",
                        value: function(e) {
                            this._peerConnection.addIceCandidates(e)
                        }
                    }]) && f(t.prototype, n), r && f(t, r), e
                }()
        }).call(this, "modules/proxyconnection/ProxyConnectionPC.js")
    }, function(e, t, n) {
        e.exports = n(119).default
    }, function(e, t, n) {
        "use strict";
        n.r(t),
            function(e) {
                var r = n(7),
                    i = n(65),
                    o = n.n(i),
                    a = n(25),
                    s = n(49),
                    c = n(11),
                    u = n.n(c),
                    l = n(17),
                    d = n(2),
                    p = n(66),
                    h = n(36),
                    f = n(21),
                    m = n(59),
                    v = n(45),
                    y = n(15),
                    g = n(12),
                    _ = n(16),
                    S = n(52),
                    b = n(50),
                    E = n(4),
                    T = n.n(E),
                    C = n(9),
                    R = n(29),
                    A = n.n(R),
                    w = n(41),
                    k = n(13),
                    O = n(3),
                    I = n(51),
                    P = n.n(I),
                    D = n(115),
                    N = n(116),
                    L = n(5),
                    M = n(20);

                function x(e) {
                    return (x = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                        return typeof e
                    } : function(e) {
                        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                    })(e)
                }
                var j = T.a.getLogger(e);

                function F(e) {
                    if (!A.a[e]) return null;
                    var t = A.a[e].order,
                        n = null,
                        r = null;
                    return Object.keys(A.a).forEach((function(e) {
                        var i = A.a[e];
                        (!n || n.order < i.order && i.order < t) && (r = e, n = i)
                    })), r === e && (r = null), r
                }

                function U(e) {
                    var t = {
                        audio_requested: e.devices.includes("audio"),
                        video_requested: e.devices.includes("video"),
                        screen_sharing_requested: e.devices.includes("desktop")
                    };
                    return t.video_requested && (t.resolution = e.resolution), t
                }
                t.default = function(e) {
                    return "object" === x(window.JitsiMeetJS) ? Object.assign({}, window.JitsiMeetJS, e) : e
                }({
                    version: "dd31f0aff0",
                    JitsiConnection: p.a,
                    ProxyConnectionService: N.a,
                    constants: {
                        participantConnectionStatus: w.a,
                        recording: D.a,
                        sipVideoGW: M,
                        transcriptionStatus: S
                    },
                    events: {
                        conference: d,
                        connection: f,
                        track: _,
                        mediaDevices: v,
                        connectionQuality: a,
                        e2eping: s
                    },
                    errors: {
                        conference: l,
                        connection: h,
                        track: g
                    },
                    errorTypes: {
                        JitsiTrackError: y.a
                    },
                    logLevels: T.a.levels,
                    mediaDevices: m.a,
                    analytics: L.a.analytics,
                    init: function() {
                        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                        L.a.init(e), window.connectionTimes || (window.connectionTimes = {}), !0 !== e.enableAnalyticsLogging && (j.warn("Analytics disabled, disposing."), this.analytics.dispose()), e.enableWindowOnErrorHandler && u.a.addHandler(this.getGlobalOnErrorHandler.bind(this));
                        var t = e.deploymentInfo;
                        if (t && Object.keys(t).length > 0) {
                            var n = {};
                            for (var r in t) t.hasOwnProperty(r) && (n[r] = t[r]);
                            n.id = "deployment_info", L.a.sendLog(JSON.stringify(n))
                        }
                        if (this.version) {
                            var i = {
                                id: "component_version",
                                component: "lib-jitsi-meet",
                                version: this.version
                            };
                            L.a.sendLog(JSON.stringify(i))
                        }
                        return k.a.init(e)
                    },
                    isDesktopSharingEnabled: function() {
                        return k.a.isDesktopSharingEnabled()
                    },
                    isWebRtcSupported: function() {
                        return k.a.isWebRtcSupported()
                    },
                    setLogLevel: function(e) {
                        T.a.setLogLevel(e)
                    },
                    setLogLevelById: function(e, t) {
                        T.a.setLogLevelById(e, t)
                    },
                    addGlobalLogTransport: function(e) {
                        T.a.addGlobalTransport(e)
                    },
                    removeGlobalLogTransport: function(e) {
                        T.a.removeGlobalTransport(e)
                    },
                    setGlobalLogOptions: function(e) {
                        T.a.setGlobalOptions(e)
                    },
                    createLocalTracks: function() {
                        var e = this,
                            t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                            n = arguments.length > 1 ? arguments[1] : void 0,
                            i = arguments.length > 2 ? arguments[2] : void 0,
                            o = !1;
                        return !0 === n && window.setTimeout((function() {
                            o || m.a.emitEvent(v.PERMISSION_PROMPT_IS_SHOWN, O.a.getName())
                        }), 1e3), window.connectionTimes || (window.connectionTimes = {}), window.connectionTimes["obtainPermissions.start"] = window.performance.now(), k.a.obtainAudioAndVideoPermissions(t).then((function(n) {
                            if (o = !0, window.connectionTimes["obtainPermissions.end"] = window.performance.now(), L.a.sendAnalytics(Object(r.E)("success", U(t))), !k.a.options.disableAudioLevels)
                                for (var i = function(e) {
                                        var t = n[e],
                                            r = t.getOriginalStream();
                                        t.getType() === C.a && (L.a.startLocalStats(r, t.setAudioLevel.bind(t)), t.addEventListener(_.LOCAL_TRACK_STOPPED, (function() {
                                            L.a.stopLocalStats(r)
                                        })))
                                    }, a = 0; a < n.length; a++) i(a);
                            var s = k.a.getCurrentlyAvailableMediaDevices();
                            if (s)
                                for (a = 0; a < n.length; a++) {
                                    n[a]._setRealDeviceIdFromDeviceList(s)
                                }
                            var c = !0,
                                u = !1,
                                l = void 0;
                            try {
                                for (var d, p = n[Symbol.iterator](); !(c = (d = p.next()).done); c = !0) {
                                    var h = d.value;
                                    h.type === C.b && "desktop" === h.videoType && e.setVideoTrackContentHints(h.track, "detail")
                                }
                            } catch (e) {
                                u = !0, l = e
                            } finally {
                                try {
                                    c || null == p.return || p.return()
                                } finally {
                                    if (u) throw l
                                }
                            }
                            return n
                        })).catch((function(n) {
                            if (o = !0, n.name === g.UNSUPPORTED_RESOLUTION && !O.a.usesNewGumFlow()) {
                                var a = t.resolution || "720",
                                    s = F(a);
                                if (null !== s) return t.resolution = s, j.debug("Retry createLocalTracks with resolution", s), L.a.sendAnalytics(Object(r.E)("warning", {
                                    old_resolution: a,
                                    new_resolution: s,
                                    reason: "unsupported resolution"
                                })), e.createLocalTracks(t, void 0, i || Object.assign({}, t));
                                if (i && n.gum.constraints && n.gum.constraints.video && n.gum.constraints.video.mandatory && n.gum.constraints.video.mandatory.sourceId) return i.cameraDeviceId = void 0, e.createLocalTracks(i)
                            }
                            if (n.name === g.CHROME_EXTENSION_USER_CANCELED) {
                                var c = {
                                    id: "chrome_extension_user_canceled",
                                    message: n.message
                                };
                                L.a.sendLog(JSON.stringify(c)), L.a.sendAnalytics(Object(r.E)("warning", {
                                    reason: "extension install user canceled"
                                }))
                            } else if (n.name === g.NOT_FOUND) {
                                var u = {
                                    id: "usermedia_missing_device",
                                    status: n.gum.devices
                                };
                                L.a.sendLog(JSON.stringify(u));
                                var l = U(t);
                                l.reason = "device not found", l.devices = n.gum.devices.join("."), L.a.sendAnalytics(Object(r.E)("error", l))
                            } else {
                                L.a.sendGetUserMediaFailed(n);
                                var d = U(t);
                                d.reason = n.name, L.a.sendAnalytics(Object(r.E)("error", d))
                            }
                            return window.connectionTimes["obtainPermissions.end"] = window.performance.now(), Promise.reject(n)
                        }))
                    },
                    isDeviceListAvailable: function() {
                        return j.warn("This method is deprecated, use JitsiMeetJS.mediaDevices.isDeviceListAvailable instead"), this.mediaDevices.isDeviceListAvailable()
                    },
                    isDeviceChangeAvailable: function(e) {
                        return j.warn("This method is deprecated, use JitsiMeetJS.mediaDevices.isDeviceChangeAvailable instead"), this.mediaDevices.isDeviceChangeAvailable(e)
                    },
                    isMultipleAudioInputSupported: function() {
                        return this.mediaDevices.isMultipleAudioInputSupported()
                    },
                    isCollectingLocalStats: function() {
                        return L.a.audioLevelsEnabled && b.a.isLocalStatsSupported()
                    },
                    enumerateDevices: function(e) {
                        j.warn("This method is deprecated, use JitsiMeetJS.mediaDevices.enumerateDevices instead"), this.mediaDevices.enumerateDevices(e)
                    },
                    getGlobalOnErrorHandler: function(e, t, n, r, i) {
                        j.error("UnhandledError: ".concat(e), "Script: ".concat(t), "Line: ".concat(n), "Column: ".concat(r), "StackTrace: ", i), L.a.reportGlobalError(i)
                    },
                    setVideoTrackContentHints: function(e, t) {
                        "contentHint" in e ? (e.contentHint = t, e.contentHint !== t && j.debug("Invalid video track contentHint")) : j.debug("MediaStreamTrack contentHint attribute not supported")
                    },
                    util: {
                        AuthUtil: o.a,
                        ScriptUtil: P.a,
                        browser: O.a
                    }
                })
            }.call(this, "JitsiMeetJS.js")
    }, function(e, t, n) {
        function r(e) {
            return (r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                return typeof e
            } : function(e) {
                return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
            })(e)
        }
        var i = n(60);

        function o(e, t) {
            this.logStorage = e, this.stringifyObjects = !(!t || !t.stringifyObjects) && t.stringifyObjects, this.storeInterval = t && t.storeInterval ? t.storeInterval : 3e4, this.maxEntryLength = t && t.maxEntryLength ? t.maxEntryLength : 1e4, Object.keys(i.levels).forEach(function(e) {
                this[i.levels[e]] = function() {
                    this._log.apply(this, arguments)
                }.bind(this, e)
            }.bind(this)), this.storeLogsIntervalID = null, this.queue = [], this.totalLen = 0, this.outputCache = []
        }
        o.prototype.stringify = function(e) {
            try {
                return JSON.stringify(e)
            } catch (e) {
                return "[object with circular refs?]"
            }
        }, o.prototype.formatLogMessage = function(e) {
            for (var t = "", n = 1, o = arguments.length; n < o; n++) {
                var a = arguments[n];
                !this.stringifyObjects && e !== i.levels.ERROR || "object" !== r(a) || (a = this.stringify(a)), t += a, n !== o - 1 && (t += " ")
            }
            return t.length ? t : null
        }, o.prototype._log = function() {
            var e = arguments[1],
                t = this.formatLogMessage.apply(this, arguments);
            if (t) {
                var n = this.queue[this.queue.length - 1],
                    r = n && n.text;
                r === t ? n.count += 1 : (this.queue.push({
                    text: t,
                    timestamp: e,
                    count: 1
                }), this.totalLen += t.length)
            }
            this.totalLen >= this.maxEntryLength && this._flush(!0, !0)
        }, o.prototype.start = function() {
            this._reschedulePublishInterval()
        }, o.prototype._reschedulePublishInterval = function() {
            this.storeLogsIntervalID && (window.clearTimeout(this.storeLogsIntervalID), this.storeLogsIntervalID = null), this.storeLogsIntervalID = window.setTimeout(this._flush.bind(this, !1, !0), this.storeInterval)
        }, o.prototype.flush = function() {
            this._flush(!1, !0)
        }, o.prototype._flush = function(e, t) {
            this.totalLen > 0 && (this.logStorage.isReady() || e) && (this.logStorage.isReady() ? (this.outputCache.length && (this.outputCache.forEach(function(e) {
                this.logStorage.storeLogs(e)
            }.bind(this)), this.outputCache = []), this.logStorage.storeLogs(this.queue)) : this.outputCache.push(this.queue), this.queue = [], this.totalLen = 0), t && this._reschedulePublishInterval()
        }, o.prototype.stop = function() {
            this._flush(!1, !1)
        }, e.exports = o
    }, function(e, t) {
        e.exports = function() {
            throw new Error("define cannot be used indirect")
        }
    }, function(e, t) {
        (function(t) {
            e.exports = t
        }).call(this, {})
    }, function(e, t, n) {
        var r, i, o;
        this || window, i = [], void 0 === (o = "function" == typeof(r = function() {
            var e = /^(interactive|loaded|complete)$/,
                t = window.location ? window.location.href : null,
                n = t && t.replace(/#.*$/, "").replace(/\?.*$/, "") || null,
                r = document.getElementsByTagName("script"),
                i = "readyState" in (r[0] || document.createElement("script")),
                o = !window.opera || "[object Opera]" !== window.opera.toString(),
                a = "currentScript" in document;
            "stackTraceLimit" in Error && Error.stackTraceLimit !== 1 / 0 && (Error.stackTraceLimit, Error.stackTraceLimit = 1 / 0);
            var s = !1,
                c = !1;

            function u() {
                if (0 === r.length) return null;
                var t, l, d, p, h, f = [],
                    m = u.skipStackDepth || 1;
                for (t = 0; t < r.length; t++) o && i ? e.test(r[t].readyState) && f.push(r[t]) : f.push(r[t]);
                if (l = new Error, s && (d = l.stack), !d && c) try {
                    throw l
                } catch (e) {
                    d = e.stack
                }
                if (d && !(h = function(e, t) {
                        var n, i = null;
                        if (t = t || r, "string" == typeof e && e)
                            for (n = t.length; n--;)
                                if (t[n].src === e) {
                                    i = t[n];
                                    break
                                } return i
                    }(p = function e(t, n) {
                        var r, i = null,
                            o = "number" == typeof n;
                        return n = o ? Math.round(n) : 0, "string" == typeof t && t && (o ? r = t.match(/(data:text\/javascript(?:;[^,]+)?,.+?|(?:|blob:)(?:http[s]?|file):\/\/[\/]?.+?\/[^:\)]*?)(?::\d+)(?::\d+)?/) : (r = t.match(/^(?:|[^:@]*@|.+\)@(?=data:text\/javascript|blob|http[s]?|file)|.+?\s+(?: at |@)(?:[^:\(]+ )*[\(]?)(data:text\/javascript(?:;[^,]+)?,.+?|(?:|blob:)(?:http[s]?|file):\/\/[\/]?.+?\/[^:\)]*?)(?::\d+)(?::\d+)?/)) && r[1] || (r = t.match(/\)@(data:text\/javascript(?:;[^,]+)?,.+?|(?:|blob:)(?:http[s]?|file):\/\/[\/]?.+?\/[^:\)]*?)(?::\d+)(?::\d+)?/)), r && r[1] && (i = n > 0 ? e(t.slice(t.indexOf(r[0]) + r[0].length), n - 1) : r[1])), i
                    }(d, m), f)) && n && p === n && (h = function(e) {
                        var t, n, i = null;
                        for (t = 0, n = (e = e || r).length; t < n; t++)
                            if (!e[t].hasAttribute("src")) {
                                if (i) {
                                    i = null;
                                    break
                                }
                                i = e[t]
                            } return i
                    }(f)), h || 1 === f.length && (h = f[0]), h || a && (h = document.currentScript), !h && o && i)
                    for (t = f.length; t--;)
                        if ("interactive" === f[t].readyState) {
                            h = f[t];
                            break
                        } return h || (h = f[f.length - 1] || null), h
            }(function() {
                try {
                    var e = new Error;
                    throw s = "string" == typeof e.stack && !!e.stack, e
                } catch (e) {
                    c = "string" == typeof e.stack && !!e.stack
                }
            })(), u.skipStackDepth = 1;
            var l = u;
            return l.near = u, l.far = function() {
                return null
            }, l.origin = function() {
                return null
            }, l
        }) ? r.apply(t, i) : r) || (e.exports = o)
    }, function(e, t) {
        e.exports = {
            LOCAL_JID: "local"
        }
    }, function(e, t, n) {
        var r, i, o, a;

        function s(e) {
            return (s = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                return typeof e
            } : function(e) {
                return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
            })(e)
        }
        a = function(e) {
            "use strict";
            // BAO

            e.Strophe.addConnectionPlugin("disco", {
                _connection: null,
                _identities: [],
                _features: [],
                _items: [],
                init: function(t) {
                    this._connection = t, this._identities = [], this._features = [], this._items = [], t.addHandler(this._onDiscoInfo.bind(this), e.Strophe.NS.DISCO_INFO, "iq", "get", null, null), t.addHandler(this._onDiscoItems.bind(this), e.Strophe.NS.DISCO_ITEMS, "iq", "get", null, null)
                },
                addIdentity: function(e, t, n, r) {
                    for (var i = 0; i < this._identities.length; i++)
                        if (this._identities[i].category == e && this._identities[i].type == t && this._identities[i].name == n && this._identities[i].lang == r) return !1;
                    return this._identities.push({
                        category: e,
                        type: t,
                        name: n,
                        lang: r
                    }), !0
                },
                addFeature: function(e) {
                    for (var t = 0; t < this._features.length; t++)
                        if (this._features[t] == e) return !1;
                    return this._features.push(e), !0
                },
                removeFeature: function(e) {
                    for (var t = 0; t < this._features.length; t++)
                        if (this._features[t] === e) return this._features.splice(t, 1), !0;
                    return !1
                },
                addItem: function(e, t, n, r) {
                    return !(n && !r || (this._items.push({
                        jid: e,
                        name: t,
                        node: n,
                        call_back: r
                    }), 0))
                },
                info: function(t, n, r, i, o) {
                    var a = {
                        xmlns: e.Strophe.NS.DISCO_INFO
                    };
                    n && (a.node = n);
                    var s = e.$iq({
                        from: this._connection.jid,
                        to: t,
                        type: "get"
                    }).c("query", a);
                    this._connection.sendIQ(s, r, i, o)
                },
                items: function(t, n, r, i, o) {
                    var a = {
                        xmlns: e.Strophe.NS.DISCO_ITEMS
                    };
                    n && (a.node = n);
                    var s = e.$iq({
                        from: this._connection.jid,
                        to: t,
                        type: "get"
                    }).c("query", a);
                    this._connection.sendIQ(s, r, i, o)
                },
                _buildIQResult: function(t, n) {
                    var r = t.getAttribute("id"),
                        i = t.getAttribute("from"),
                        o = e.$iq({
                            type: "result",
                            id: r
                        });
                    return null !== i && o.attrs({
                        to: i
                    }), o.c("query", n)
                },
                _onDiscoInfo: function(t) {
                    var n, r = t.getElementsByTagName("query")[0].getAttribute("node"),
                        i = {
                            xmlns: e.Strophe.NS.DISCO_INFO
                        };
                    r && (i.node = r);
                    var o = this._buildIQResult(t, i);
                    for (n = 0; n < this._identities.length; n++) i = {
                        category: this._identities[n].category,
                        type: this._identities[n].type
                    }, this._identities[n].name && (i.name = this._identities[n].name), this._identities[n].lang && (i["xml:lang"] = this._identities[n].lang), o.c("identity", i).up();
                    for (n = 0; n < this._features.length; n++) o.c("feature", {
                        var: this._features[n]
                    }).up();
                    return this._connection.send(o.tree()), !0
                },
                _onDiscoItems: function(t) {
                    var n, r, i = {
                            xmlns: e.Strophe.NS.DISCO_ITEMS
                        },
                        o = t.getElementsByTagName("query")[0].getAttribute("node");
                    if (o) {
                        for (i.node = o, n = [], r = 0; r < this._items.length; r++)
                            if (this._items[r].node == o) {
                                n = this._items[r].call_back(t);
                                break
                            }
                    } else n = this._items;
                    var a = this._buildIQResult(t, i);
                    for (r = 0; r < n.length; r++) {
                        var s = {
                            jid: n[r].jid
                        };
                        n[r].name && (s.name = n[r].name), n[r].node && (s.node = n[r].node), a.c("item", s).up()
                    }
                    return this._connection.send(a.tree()), !0
                }
            })
        }, "object" === s(t) && void 0 !== e ? a(n(1)) : (i = [n(1)], void 0 === (o = "function" == typeof(r = a) ? r.apply(t, i) : r) || (e.exports = o))
    }, function(e, t, n) {
        (function(e) {
            var r = void 0 !== e && e || "undefined" != typeof self && self || window,
                i = Function.prototype.apply;

            function o(e, t) {
                this._id = e, this._clearFn = t
            }
            t.setTimeout = function() {
                return new o(i.call(setTimeout, r, arguments), clearTimeout)
            }, t.setInterval = function() {
                return new o(i.call(setInterval, r, arguments), clearInterval)
            }, t.clearTimeout = t.clearInterval = function(e) {
                e && e.close()
            }, o.prototype.unref = o.prototype.ref = function() {}, o.prototype.close = function() {
                this._clearFn.call(r, this._id)
            }, t.enroll = function(e, t) {
                clearTimeout(e._idleTimeoutId), e._idleTimeout = t
            }, t.unenroll = function(e) {
                clearTimeout(e._idleTimeoutId), e._idleTimeout = -1
            }, t._unrefActive = t.active = function(e) {
                clearTimeout(e._idleTimeoutId);
                var t = e._idleTimeout;
                t >= 0 && (e._idleTimeoutId = setTimeout((function() {
                    e._onTimeout && e._onTimeout()
                }), t))
            }, n(127), t.setImmediate = "undefined" != typeof self && self.setImmediate || void 0 !== e && e.setImmediate || this && this.setImmediate, t.clearImmediate = "undefined" != typeof self && self.clearImmediate || void 0 !== e && e.clearImmediate || this && this.clearImmediate
        }).call(this, n(43))
    }, function(e, t, n) {
        (function(e, t) {
            ! function(e, n) {
                "use strict";
                if (!e.setImmediate) {
                    var r, i, o, a, s, c = 1,
                        u = {},
                        l = !1,
                        d = e.document,
                        p = Object.getPrototypeOf && Object.getPrototypeOf(e);
                    p = p && p.setTimeout ? p : e, "[object process]" === {}.toString.call(e.process) ? r = function(e) {
                        t.nextTick((function() {
                            f(e)
                        }))
                    } : ! function() {
                        if (e.postMessage && !e.importScripts) {
                            var t = !0,
                                n = e.onmessage;
                            return e.onmessage = function() {
                                t = !1
                            }, e.postMessage("", "*"), e.onmessage = n, t
                        }
                    }() ? e.MessageChannel ? ((o = new MessageChannel).port1.onmessage = function(e) {
                        f(e.data)
                    }, r = function(e) {
                        o.port2.postMessage(e)
                    }) : d && "onreadystatechange" in d.createElement("script") ? (i = d.documentElement, r = function(e) {
                        var t = d.createElement("script");
                        t.onreadystatechange = function() {
                            f(e), t.onreadystatechange = null, i.removeChild(t), t = null
                        }, i.appendChild(t)
                    }) : r = function(e) {
                        setTimeout(f, 0, e)
                    } : (a = "setImmediate$" + Math.random() + "$", s = function(t) {
                        t.source === e && "string" == typeof t.data && 0 === t.data.indexOf(a) && f(+t.data.slice(a.length))
                    }, e.addEventListener ? e.addEventListener("message", s, !1) : e.attachEvent("onmessage", s), r = function(t) {
                        e.postMessage(a + t, "*")
                    }), p.setImmediate = function(e) {
                        "function" != typeof e && (e = new Function("" + e));
                        for (var t = new Array(arguments.length - 1), n = 0; n < t.length; n++) t[n] = arguments[n + 1];
                        var i = {
                            callback: e,
                            args: t
                        };
                        return u[c] = i, r(c), c++
                    }, p.clearImmediate = h
                }

                function h(e) {
                    delete u[e]
                }

                function f(e) {
                    if (l) setTimeout(f, 0, e);
                    else {
                        var t = u[e];
                        if (t) {
                            l = !0;
                            try {
                                ! function(e) {
                                    var t = e.callback,
                                        r = e.args;
                                    switch (r.length) {
                                        case 0:
                                            t();
                                            break;
                                        case 1:
                                            t(r[0]);
                                            break;
                                        case 2:
                                            t(r[0], r[1]);
                                            break;
                                        case 3:
                                            t(r[0], r[1], r[2]);
                                            break;
                                        default:
                                            t.apply(n, r)
                                    }
                                }(t)
                            } finally {
                                h(e), l = !1
                            }
                        }
                    }
                }
            }("undefined" == typeof self ? void 0 === e ? this : e : self)
        }).call(this, n(43), n(48))
    }, function(e, t, n) {
        "use strict";
        (function(t) {
            var r = n(129);
            e.exports = r({
                window: t.window
            })
        }).call(this, n(43))
    }, function(e, t, n) {
        "use strict";
        var r = n(38);
        e.exports = function(e, t) {
            var i = e && e.window,
                o = {
                    shimChrome: !0,
                    shimFirefox: !0,
                    shimEdge: !0,
                    shimSafari: !0
                };
            for (var a in t) hasOwnProperty.call(t, a) && (o[a] = t[a]);
            var s = r.log,
                c = r.detectBrowser(i),
                u = {
                    browserDetails: c,
                    extractVersion: r.extractVersion,
                    disableLog: r.disableLog,
                    disableWarnings: r.disableWarnings
                },
                l = n(130) || null,
                d = n(132) || null,
                p = n(135) || null,
                h = n(137) || null,
                f = n(138) || null;
            switch (c.browser) {
                case "chrome":
                    if (!l || !l.shimPeerConnection || !o.shimChrome) return s("Chrome shim is not included in this adapter release."), u;
                    s("adapter.js shimming chrome."), u.browserShim = l, f.shimCreateObjectURL(i), l.shimGetUserMedia(i), l.shimMediaStream(i), l.shimSourceObject(i), l.shimPeerConnection(i), l.shimOnTrack(i), l.shimAddTrackRemoveTrack(i), l.shimGetSendersWithDtmf(i), f.shimRTCIceCandidate(i);
                    break;
                case "firefox":
                    if (!p || !p.shimPeerConnection || !o.shimFirefox) return s("Firefox shim is not included in this adapter release."), u;
                    s("adapter.js shimming firefox."), u.browserShim = p, f.shimCreateObjectURL(i), p.shimGetUserMedia(i), p.shimSourceObject(i), p.shimPeerConnection(i), p.shimOnTrack(i), f.shimRTCIceCandidate(i);
                    break;
                case "edge":
                    if (!d || !d.shimPeerConnection || !o.shimEdge) return s("MS edge shim is not included in this adapter release."), u;
                    s("adapter.js shimming edge."), u.browserShim = d, f.shimCreateObjectURL(i), d.shimGetUserMedia(i), d.shimPeerConnection(i), d.shimReplaceTrack(i);
                    break;
                case "safari":
                    if (!h || !o.shimSafari) return s("Safari shim is not included in this adapter release."), u;
                    s("adapter.js shimming safari."), u.browserShim = h, f.shimCreateObjectURL(i), h.shimRTCIceServerUrls(i), h.shimCallbacksAPI(i), h.shimLocalStreamsAPI(i), h.shimRemoteStreamsAPI(i), h.shimTrackEventTransceiver(i), h.shimGetUserMedia(i), h.shimCreateOfferLegacy(i), f.shimRTCIceCandidate(i);
                    break;
                default:
                    s("Unsupported browser!")
            }
            return u
        }
    }, function(e, t, n) {
        "use strict";

        function r(e) {
            return (r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                return typeof e
            } : function(e) {
                return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
            })(e)
        }
        var i = n(38),
            o = i.log,
            a = {
                shimMediaStream: function(e) {
                    e.MediaStream = e.MediaStream || e.webkitMediaStream
                },
                shimOnTrack: function(e) {
                    if ("object" === r(e) && e.RTCPeerConnection && !("ontrack" in e.RTCPeerConnection.prototype)) {
                        Object.defineProperty(e.RTCPeerConnection.prototype, "ontrack", {
                            get: function() {
                                return this._ontrack
                            },
                            set: function(e) {
                                this._ontrack && this.removeEventListener("track", this._ontrack), this.addEventListener("track", this._ontrack = e)
                            }
                        });
                        var t = e.RTCPeerConnection.prototype.setRemoteDescription;
                        e.RTCPeerConnection.prototype.setRemoteDescription = function() {
                            var n = this;
                            return n._ontrackpoly || (n._ontrackpoly = function(t) {
                                t.stream.addEventListener("addtrack", (function(r) {
                                    var i;
                                    i = e.RTCPeerConnection.prototype.getReceivers ? n.getReceivers().find((function(e) {
                                        return e.track && e.track.id === r.track.id
                                    })) : {
                                        track: r.track
                                    };
                                    var o = new Event("track");
                                    o.track = r.track, o.receiver = i, o.transceiver = {
                                        receiver: i
                                    }, o.streams = [t.stream], n.dispatchEvent(o)
                                })), t.stream.getTracks().forEach((function(r) {
                                    var i;
                                    i = e.RTCPeerConnection.prototype.getReceivers ? n.getReceivers().find((function(e) {
                                        return e.track && e.track.id === r.id
                                    })) : {
                                        track: r
                                    };
                                    var o = new Event("track");
                                    o.track = r, o.receiver = i, o.transceiver = {
                                        receiver: i
                                    }, o.streams = [t.stream], n.dispatchEvent(o)
                                }))
                            }, n.addEventListener("addstream", n._ontrackpoly)), t.apply(n, arguments)
                        }
                    }
                },
                shimGetSendersWithDtmf: function(e) {
                    if ("object" === r(e) && e.RTCPeerConnection && !("getSenders" in e.RTCPeerConnection.prototype) && "createDTMFSender" in e.RTCPeerConnection.prototype) {
                        var t = function(e, t) {
                            return {
                                track: t,
                                get dtmf() {
                                    return void 0 === this._dtmf && ("audio" === t.kind ? this._dtmf = e.createDTMFSender(t) : this._dtmf = null), this._dtmf
                                },
                                _pc: e
                            }
                        };
                        if (!e.RTCPeerConnection.prototype.getSenders) {
                            e.RTCPeerConnection.prototype.getSenders = function() {
                                return this._senders = this._senders || [], this._senders.slice()
                            };
                            var n = e.RTCPeerConnection.prototype.addTrack;
                            e.RTCPeerConnection.prototype.addTrack = function(e, r) {
                                var i = this,
                                    o = n.apply(i, arguments);
                                return o || (o = t(i, e), i._senders.push(o)), o
                            };
                            var i = e.RTCPeerConnection.prototype.removeTrack;
                            e.RTCPeerConnection.prototype.removeTrack = function(e) {
                                var t = this;
                                i.apply(t, arguments);
                                var n = t._senders.indexOf(e); - 1 !== n && t._senders.splice(n, 1)
                            }
                        }
                        var o = e.RTCPeerConnection.prototype.addStream;
                        e.RTCPeerConnection.prototype.addStream = function(e) {
                            var n = this;
                            n._senders = n._senders || [], o.apply(n, [e]), e.getTracks().forEach((function(e) {
                                n._senders.push(t(n, e))
                            }))
                        };
                        var a = e.RTCPeerConnection.prototype.removeStream;
                        e.RTCPeerConnection.prototype.removeStream = function(e) {
                            var t = this;
                            t._senders = t._senders || [], a.apply(t, [e]), e.getTracks().forEach((function(e) {
                                var n = t._senders.find((function(t) {
                                    return t.track === e
                                }));
                                n && t._senders.splice(t._senders.indexOf(n), 1)
                            }))
                        }
                    } else if ("object" === r(e) && e.RTCPeerConnection && "getSenders" in e.RTCPeerConnection.prototype && "createDTMFSender" in e.RTCPeerConnection.prototype && e.RTCRtpSender && !("dtmf" in e.RTCRtpSender.prototype)) {
                        var s = e.RTCPeerConnection.prototype.getSenders;
                        e.RTCPeerConnection.prototype.getSenders = function() {
                            var e = this,
                                t = s.apply(e, []);
                            return t.forEach((function(t) {
                                t._pc = e
                            })), t
                        }, Object.defineProperty(e.RTCRtpSender.prototype, "dtmf", {
                            get: function() {
                                return void 0 === this._dtmf && ("audio" === this.track.kind ? this._dtmf = this._pc.createDTMFSender(this.track) : this._dtmf = null), this._dtmf
                            }
                        })
                    }
                },
                shimSourceObject: function(e) {
                    var t = e && e.URL;
                    "object" === r(e) && (!e.HTMLMediaElement || "srcObject" in e.HTMLMediaElement.prototype || Object.defineProperty(e.HTMLMediaElement.prototype, "srcObject", {
                        get: function() {
                            return this._srcObject
                        },
                        set: function(e) {
                            var n = this;
                            this._srcObject = e, this.src && t.revokeObjectURL(this.src), e ? (this.src = t.createObjectURL(e), e.addEventListener("addtrack", (function() {
                                n.src && t.revokeObjectURL(n.src), n.src = t.createObjectURL(e)
                            })), e.addEventListener("removetrack", (function() {
                                n.src && t.revokeObjectURL(n.src), n.src = t.createObjectURL(e)
                            }))) : this.src = ""
                        }
                    }))
                },
                shimAddTrackRemoveTrack: function(e) {
                    var t = i.detectBrowser(e);
                    if (!(e.RTCPeerConnection.prototype.addTrack && t.version >= 63)) {
                        var n = e.RTCPeerConnection.prototype.getLocalStreams;
                        e.RTCPeerConnection.prototype.getLocalStreams = function() {
                            var e = this,
                                t = n.apply(this);
                            return e._reverseStreams = e._reverseStreams || {}, t.map((function(t) {
                                return e._reverseStreams[t.id]
                            }))
                        };
                        var r = e.RTCPeerConnection.prototype.addStream;
                        e.RTCPeerConnection.prototype.addStream = function(t) {
                            var n = this;
                            if (n._streams = n._streams || {}, n._reverseStreams = n._reverseStreams || {}, t.getTracks().forEach((function(e) {
                                    if (n.getSenders().find((function(t) {
                                            return t.track === e
                                        }))) throw new DOMException("Track already exists.", "InvalidAccessError")
                                })), !n._reverseStreams[t.id]) {
                                var i = new e.MediaStream(t.getTracks());
                                n._streams[t.id] = i, n._reverseStreams[i.id] = t, t = i
                            }
                            r.apply(n, [t])
                        };
                        var o = e.RTCPeerConnection.prototype.removeStream;
                        e.RTCPeerConnection.prototype.removeStream = function(e) {
                            var t = this;
                            t._streams = t._streams || {}, t._reverseStreams = t._reverseStreams || {}, o.apply(t, [t._streams[e.id] || e]), delete t._reverseStreams[t._streams[e.id] ? t._streams[e.id].id : e.id], delete t._streams[e.id]
                        }, e.RTCPeerConnection.prototype.addTrack = function(t, n) {
                            var r = this;
                            if ("closed" === r.signalingState) throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError");
                            var i = [].slice.call(arguments, 1);
                            if (1 !== i.length || !i[0].getTracks().find((function(e) {
                                    return e === t
                                }))) throw new DOMException("The adapter.js addTrack polyfill only supports a single  stream which is associated with the specified track.", "NotSupportedError");
                            var o = r.getSenders().find((function(e) {
                                return e.track === t
                            }));
                            if (o) throw new DOMException("Track already exists.", "InvalidAccessError");
                            r._streams = r._streams || {}, r._reverseStreams = r._reverseStreams || {};
                            var a = r._streams[n.id];
                            if (a) a.addTrack(t), Promise.resolve().then((function() {
                                r.dispatchEvent(new Event("negotiationneeded"))
                            }));
                            else {
                                var s = new e.MediaStream([t]);
                                r._streams[n.id] = s, r._reverseStreams[s.id] = n, r.addStream(s)
                            }
                            return r.getSenders().find((function(e) {
                                return e.track === t
                            }))
                        }, ["createOffer", "createAnswer"].forEach((function(t) {
                            var n = e.RTCPeerConnection.prototype[t];
                            e.RTCPeerConnection.prototype[t] = function() {
                                var e = this,
                                    t = arguments,
                                    r = arguments.length && "function" == typeof arguments[0];
                                return r ? n.apply(e, [function(n) {
                                    var r = c(e, n);
                                    t[0].apply(null, [r])
                                }, function(e) {
                                    t[1] && t[1].apply(null, e)
                                }, arguments[2]]) : n.apply(e, arguments).then((function(t) {
                                    return c(e, t)
                                }))
                            }
                        }));
                        var a = e.RTCPeerConnection.prototype.setLocalDescription;
                        e.RTCPeerConnection.prototype.setLocalDescription = function() {
                            var e = this;
                            return arguments.length && arguments[0].type ? (arguments[0] = u(e, arguments[0]), a.apply(e, arguments)) : a.apply(e, arguments)
                        };
                        var s = Object.getOwnPropertyDescriptor(e.RTCPeerConnection.prototype, "localDescription");
                        Object.defineProperty(e.RTCPeerConnection.prototype, "localDescription", {
                            get: function() {
                                var e = s.get.apply(this);
                                return "" === e.type ? e : c(this, e)
                            }
                        }), e.RTCPeerConnection.prototype.removeTrack = function(e) {
                            var t, n = this;
                            if ("closed" === n.signalingState) throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError");
                            if (!e._pc) throw new DOMException("Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.", "TypeError");
                            if (!(e._pc === n)) throw new DOMException("Sender was not created by this connection.", "InvalidAccessError");
                            n._streams = n._streams || {}, Object.keys(n._streams).forEach((function(r) {
                                n._streams[r].getTracks().find((function(t) {
                                    return e.track === t
                                })) && (t = n._streams[r])
                            })), t && (1 === t.getTracks().length ? n.removeStream(n._reverseStreams[t.id]) : t.removeTrack(e.track), n.dispatchEvent(new Event("negotiationneeded")))
                        }
                    }

                    function c(e, t) {
                        var n = t.sdp;
                        return Object.keys(e._reverseStreams || []).forEach((function(t) {
                            var r = e._reverseStreams[t],
                                i = e._streams[r.id];
                            n = n.replace(new RegExp(i.id, "g"), r.id)
                        })), new RTCSessionDescription({
                            type: t.type,
                            sdp: n
                        })
                    }

                    function u(e, t) {
                        var n = t.sdp;
                        return Object.keys(e._reverseStreams || []).forEach((function(t) {
                            var r = e._reverseStreams[t],
                                i = e._streams[r.id];
                            n = n.replace(new RegExp(r.id, "g"), i.id)
                        })), new RTCSessionDescription({
                            type: t.type,
                            sdp: n
                        })
                    }
                },
                shimPeerConnection: function(e) {
                    var t = i.detectBrowser(e);
                    if (e.RTCPeerConnection) {
                        var n = e.RTCPeerConnection;
                        e.RTCPeerConnection = function(e, t) {
                            if (e && e.iceServers) {
                                for (var r = [], o = 0; o < e.iceServers.length; o++) {
                                    var a = e.iceServers[o];
                                    !a.hasOwnProperty("urls") && a.hasOwnProperty("url") ? (i.deprecated("RTCIceServer.url", "RTCIceServer.urls"), (a = JSON.parse(JSON.stringify(a))).urls = a.url, r.push(a)) : r.push(e.iceServers[o])
                                }
                                e.iceServers = r
                            }
                            return new n(e, t)
                        }, e.RTCPeerConnection.prototype = n.prototype, Object.defineProperty(e.RTCPeerConnection, "generateCertificate", {
                            get: function() {
                                return n.generateCertificate
                            }
                        })
                    } else e.RTCPeerConnection = function(t, n) {
                        return o("PeerConnection"), t && t.iceTransportPolicy && (t.iceTransports = t.iceTransportPolicy), new e.webkitRTCPeerConnection(t, n)
                    }, e.RTCPeerConnection.prototype = e.webkitRTCPeerConnection.prototype, e.webkitRTCPeerConnection.generateCertificate && Object.defineProperty(e.RTCPeerConnection, "generateCertificate", {
                        get: function() {
                            return e.webkitRTCPeerConnection.generateCertificate
                        }
                    });
                    var a = e.RTCPeerConnection.prototype.getStats;
                    e.RTCPeerConnection.prototype.getStats = function(e, t, n) {
                        var r = this,
                            i = arguments;
                        if (arguments.length > 0 && "function" == typeof e) return a.apply(this, arguments);
                        if (0 === a.length && (0 === arguments.length || "function" != typeof arguments[0])) return a.apply(this, []);
                        var o = function(e) {
                                var t = {};
                                return e.result().forEach((function(e) {
                                    var n = {
                                        id: e.id,
                                        timestamp: e.timestamp,
                                        type: {
                                            localcandidate: "local-candidate",
                                            remotecandidate: "remote-candidate"
                                        } [e.type] || e.type
                                    };
                                    e.names().forEach((function(t) {
                                        n[t] = e.stat(t)
                                    })), t[n.id] = n
                                })), t
                            },
                            s = function(e) {
                                return new Map(Object.keys(e).map((function(t) {
                                    return [t, e[t]]
                                })))
                            };
                        if (arguments.length >= 2) {
                            var c = function(e) {
                                i[1](s(o(e)))
                            };
                            return a.apply(this, [c, arguments[0]])
                        }
                        return new Promise((function(e, t) {
                            a.apply(r, [function(t) {
                                e(s(o(t)))
                            }, t])
                        })).then(t, n)
                    }, t.version < 51 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach((function(t) {
                        var n = e.RTCPeerConnection.prototype[t];
                        e.RTCPeerConnection.prototype[t] = function() {
                            var e = arguments,
                                t = this,
                                r = new Promise((function(r, i) {
                                    n.apply(t, [e[0], r, i])
                                }));
                            return e.length < 2 ? r : r.then((function() {
                                e[1].apply(null, [])
                            }), (function(t) {
                                e.length >= 3 && e[2].apply(null, [t])
                            }))
                        }
                    })), t.version < 52 && ["createOffer", "createAnswer"].forEach((function(t) {
                        var n = e.RTCPeerConnection.prototype[t];
                        e.RTCPeerConnection.prototype[t] = function() {
                            var e = this;
                            if (arguments.length < 1 || 1 === arguments.length && "object" === r(arguments[0])) {
                                var t = 1 === arguments.length ? arguments[0] : void 0;
                                return new Promise((function(r, i) {
                                    n.apply(e, [r, i, t])
                                }))
                            }
                            return n.apply(this, arguments)
                        }
                    })), ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach((function(t) {
                        var n = e.RTCPeerConnection.prototype[t];
                        e.RTCPeerConnection.prototype[t] = function() {
                            return arguments[0] = new("addIceCandidate" === t ? e.RTCIceCandidate : e.RTCSessionDescription)(arguments[0]), n.apply(this, arguments)
                        }
                    }));
                    var s = e.RTCPeerConnection.prototype.addIceCandidate;
                    e.RTCPeerConnection.prototype.addIceCandidate = function() {
                        return arguments[0] ? s.apply(this, arguments) : (arguments[1] && arguments[1].apply(null), Promise.resolve())
                    }
                }
            };
        e.exports = {
            shimMediaStream: a.shimMediaStream,
            shimOnTrack: a.shimOnTrack,
            shimAddTrackRemoveTrack: a.shimAddTrackRemoveTrack,
            shimGetSendersWithDtmf: a.shimGetSendersWithDtmf,
            shimSourceObject: a.shimSourceObject,
            shimPeerConnection: a.shimPeerConnection,
            shimGetUserMedia: n(131)
        }
    }, function(e, t, n) {
        "use strict";

        function r(e) {
            return (r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                return typeof e
            } : function(e) {
                return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
            })(e)
        }
        var i = n(38),
            o = i.log;
        e.exports = function(e) {
            var t = i.detectBrowser(e),
                n = e && e.navigator,
                a = function(e) {
                    if ("object" !== r(e) || e.mandatory || e.optional) return e;
                    var t = {};
                    return Object.keys(e).forEach((function(n) {
                        if ("require" !== n && "advanced" !== n && "mediaSource" !== n) {
                            var i = "object" === r(e[n]) ? e[n] : {
                                ideal: e[n]
                            };
                            void 0 !== i.exact && "number" == typeof i.exact && (i.min = i.max = i.exact);
                            var o = function(e, t) {
                                return e ? e + t.charAt(0).toUpperCase() + t.slice(1) : "deviceId" === t ? "sourceId" : t
                            };
                            if (void 0 !== i.ideal) {
                                t.optional = t.optional || [];
                                var a = {};
                                "number" == typeof i.ideal ? (a[o("min", n)] = i.ideal, t.optional.push(a), (a = {})[o("max", n)] = i.ideal, t.optional.push(a)) : (a[o("", n)] = i.ideal, t.optional.push(a))
                            }
                            void 0 !== i.exact && "number" != typeof i.exact ? (t.mandatory = t.mandatory || {}, t.mandatory[o("", n)] = i.exact) : ["min", "max"].forEach((function(e) {
                                void 0 !== i[e] && (t.mandatory = t.mandatory || {}, t.mandatory[o(e, n)] = i[e])
                            }))
                        }
                    })), e.advanced && (t.optional = (t.optional || []).concat(e.advanced)), t
                },
                s = function(e, i) {
                    if (t.version >= 61) return i(e);
                    if ((e = JSON.parse(JSON.stringify(e))) && "object" === r(e.audio)) {
                        var s = function(e, t, n) {
                            t in e && !(n in e) && (e[n] = e[t], delete e[t])
                        };
                        s((e = JSON.parse(JSON.stringify(e))).audio, "autoGainControl", "googAutoGainControl"), s(e.audio, "noiseSuppression", "googNoiseSuppression"), e.audio = a(e.audio)
                    }
                    if (e && "object" === r(e.video)) {
                        var c = e.video.facingMode;
                        c = c && ("object" === r(c) ? c : {
                            ideal: c
                        });
                        var u, l = t.version < 66;
                        if (c && ("user" === c.exact || "environment" === c.exact || "user" === c.ideal || "environment" === c.ideal) && (!n.mediaDevices.getSupportedConstraints || !n.mediaDevices.getSupportedConstraints().facingMode || l))
                            if (delete e.video.facingMode, "environment" === c.exact || "environment" === c.ideal ? u = ["back", "rear"] : "user" !== c.exact && "user" !== c.ideal || (u = ["front"]), u) return n.mediaDevices.enumerateDevices().then((function(t) {
                                var n = (t = t.filter((function(e) {
                                    return "videoinput" === e.kind
                                }))).find((function(e) {
                                    return u.some((function(t) {
                                        return -1 !== e.label.toLowerCase().indexOf(t)
                                    }))
                                }));
                                return !n && t.length && -1 !== u.indexOf("back") && (n = t[t.length - 1]), n && (e.video.deviceId = c.exact ? {
                                    exact: n.deviceId
                                } : {
                                    ideal: n.deviceId
                                }), e.video = a(e.video), o("chrome: " + JSON.stringify(e)), i(e)
                            }));
                        e.video = a(e.video)
                    }
                    return o("chrome: " + JSON.stringify(e)), i(e)
                },
                c = function(e) {
                    return {
                        name: {
                            PermissionDeniedError: "NotAllowedError",
                            InvalidStateError: "NotReadableError",
                            DevicesNotFoundError: "NotFoundError",
                            ConstraintNotSatisfiedError: "OverconstrainedError",
                            TrackStartError: "NotReadableError",
                            MediaDeviceFailedDueToShutdown: "NotReadableError",
                            MediaDeviceKillSwitchOn: "NotReadableError"
                        } [e.name] || e.name,
                        message: e.message,
                        constraint: e.constraintName,
                        toString: function() {
                            return this.name + (this.message && ": ") + this.message
                        }
                    }
                };
            n.getUserMedia = function(e, t, r) {
                s(e, (function(e) {
                    n.webkitGetUserMedia(e, t, (function(e) {
                        r && r(c(e))
                    }))
                }))
            };
            var u = function(e) {
                return new Promise((function(t, r) {
                    n.getUserMedia(e, t, r)
                }))
            };
            if (n.mediaDevices || (n.mediaDevices = {
                    getUserMedia: u,
                    enumerateDevices: function() {
                        return new Promise((function(t) {
                            var n = {
                                audio: "audioinput",
                                video: "videoinput"
                            };
                            return e.MediaStreamTrack.getSources((function(e) {
                                t(e.map((function(e) {
                                    return {
                                        label: e.label,
                                        kind: n[e.kind],
                                        deviceId: e.id,
                                        groupId: ""
                                    }
                                })))
                            }))
                        }))
                    },
                    getSupportedConstraints: function() {
                        return {
                            deviceId: !0,
                            echoCancellation: !0,
                            facingMode: !0,
                            frameRate: !0,
                            height: !0,
                            width: !0
                        }
                    }
                }), n.mediaDevices.getUserMedia) {
                var l = n.mediaDevices.getUserMedia.bind(n.mediaDevices);
                n.mediaDevices.getUserMedia = function(e) {
                    return s(e, (function(e) {
                        return l(e).then((function(t) {
                            if (e.audio && !t.getAudioTracks().length || e.video && !t.getVideoTracks().length) throw t.getTracks().forEach((function(e) {
                                e.stop()
                            })), new DOMException("", "NotFoundError");
                            return t
                        }), (function(e) {
                            return Promise.reject(c(e))
                        }))
                    }))
                }
            } else n.mediaDevices.getUserMedia = function(e) {
                return u(e)
            };
            void 0 === n.mediaDevices.addEventListener && (n.mediaDevices.addEventListener = function() {
                o("Dummy mediaDevices.addEventListener called.")
            }), void 0 === n.mediaDevices.removeEventListener && (n.mediaDevices.removeEventListener = function() {
                o("Dummy mediaDevices.removeEventListener called.")
            })
        }
    }, function(e, t, n) {
        "use strict";
        var r = n(38),
            i = n(133);
        e.exports = {
            shimGetUserMedia: n(134),
            shimPeerConnection: function(e) {
                var t = r.detectBrowser(e);
                if (e.RTCIceGatherer && (e.RTCIceCandidate || (e.RTCIceCandidate = function(e) {
                        return e
                    }), e.RTCSessionDescription || (e.RTCSessionDescription = function(e) {
                        return e
                    }), t.version < 15025)) {
                    var n = Object.getOwnPropertyDescriptor(e.MediaStreamTrack.prototype, "enabled");
                    Object.defineProperty(e.MediaStreamTrack.prototype, "enabled", {
                        set: function(e) {
                            n.set.call(this, e);
                            var t = new Event("enabled");
                            t.enabled = e, this.dispatchEvent(t)
                        }
                    })
                }!e.RTCRtpSender || "dtmf" in e.RTCRtpSender.prototype || Object.defineProperty(e.RTCRtpSender.prototype, "dtmf", {
                    get: function() {
                        return void 0 === this._dtmf && ("audio" === this.track.kind ? this._dtmf = new e.RTCDtmfSender(this) : "video" === this.track.kind && (this._dtmf = null)), this._dtmf
                    }
                }), e.RTCPeerConnection = i(e, t.version)
            },
            shimReplaceTrack: function(e) {
                !e.RTCRtpSender || "replaceTrack" in e.RTCRtpSender.prototype || (e.RTCRtpSender.prototype.replaceTrack = e.RTCRtpSender.prototype.setTrack)
            }
        }
    }, function(e, t, n) {
        "use strict";
        var r = n(62);

        function i(e, t, n, i, o) {
            var a = r.writeRtpDescription(e.kind, t);
            if (a += r.writeIceParameters(e.iceGatherer.getLocalParameters()), a += r.writeDtlsParameters(e.dtlsTransport.getLocalParameters(), "offer" === n ? "actpass" : o || "active"), a += "a=mid:" + e.mid + "\r\n", e.rtpSender && e.rtpReceiver ? a += "a=sendrecv\r\n" : e.rtpSender ? a += "a=sendonly\r\n" : e.rtpReceiver ? a += "a=recvonly\r\n" : a += "a=inactive\r\n", e.rtpSender) {
                var s = e.rtpSender._initialTrackId || e.rtpSender.track.id;
                e.rtpSender._initialTrackId = s;
                var c = "msid:" + (i ? i.id : "-") + " " + s + "\r\n";
                a += "a=" + c, a += "a=ssrc:" + e.sendEncodingParameters[0].ssrc + " " + c, e.sendEncodingParameters[0].rtx && (a += "a=ssrc:" + e.sendEncodingParameters[0].rtx.ssrc + " " + c, a += "a=ssrc-group:FID " + e.sendEncodingParameters[0].ssrc + " " + e.sendEncodingParameters[0].rtx.ssrc + "\r\n")
            }
            return a += "a=ssrc:" + e.sendEncodingParameters[0].ssrc + " cname:" + r.localCName + "\r\n", e.rtpSender && e.sendEncodingParameters[0].rtx && (a += "a=ssrc:" + e.sendEncodingParameters[0].rtx.ssrc + " cname:" + r.localCName + "\r\n"), a
        }

        function o(e, t) {
            var n = {
                    codecs: [],
                    headerExtensions: [],
                    fecMechanisms: []
                },
                r = function(e, t) {
                    e = parseInt(e, 10);
                    for (var n = 0; n < t.length; n++)
                        if (t[n].payloadType === e || t[n].preferredPayloadType === e) return t[n]
                },
                i = function(e, t, n, i) {
                    var o = r(e.parameters.apt, n),
                        a = r(t.parameters.apt, i);
                    return o && a && o.name.toLowerCase() === a.name.toLowerCase()
                };
            return e.codecs.forEach((function(r) {
                for (var o = 0; o < t.codecs.length; o++) {
                    var a = t.codecs[o];
                    if (r.name.toLowerCase() === a.name.toLowerCase() && r.clockRate === a.clockRate) {
                        if ("rtx" === r.name.toLowerCase() && r.parameters && a.parameters.apt && !i(r, a, e.codecs, t.codecs)) continue;
                        (a = JSON.parse(JSON.stringify(a))).numChannels = Math.min(r.numChannels, a.numChannels), n.codecs.push(a), a.rtcpFeedback = a.rtcpFeedback.filter((function(e) {
                            for (var t = 0; t < r.rtcpFeedback.length; t++)
                                if (r.rtcpFeedback[t].type === e.type && r.rtcpFeedback[t].parameter === e.parameter) return !0;
                            return !1
                        }));
                        break
                    }
                }
            })), e.headerExtensions.forEach((function(e) {
                for (var r = 0; r < t.headerExtensions.length; r++) {
                    var i = t.headerExtensions[r];
                    if (e.uri === i.uri) {
                        n.headerExtensions.push(i);
                        break
                    }
                }
            })), n
        }

        function a(e, t, n) {
            return -1 !== {
                offer: {
                    setLocalDescription: ["stable", "have-local-offer"],
                    setRemoteDescription: ["stable", "have-remote-offer"]
                },
                answer: {
                    setLocalDescription: ["have-remote-offer", "have-local-pranswer"],
                    setRemoteDescription: ["have-local-offer", "have-remote-pranswer"]
                }
            } [t][e].indexOf(n)
        }

        function s(e, t) {
            var n = e.getRemoteCandidates().find((function(e) {
                return t.foundation === e.foundation && t.ip === e.ip && t.port === e.port && t.priority === e.priority && t.protocol === e.protocol && t.type === e.type
            }));
            return n || e.addRemoteCandidate(t), !n
        }

        function c(e, t) {
            var n = new Error(t);
            return n.name = e, n.code = {
                NotSupportedError: 9,
                InvalidStateError: 11,
                InvalidAccessError: 15,
                TypeError: void 0,
                OperationError: void 0
            } [e], n
        }
        e.exports = function(e, t) {
            function n(t, n) {
                n.addTrack(t), n.dispatchEvent(new e.MediaStreamTrackEvent("addtrack", {
                    track: t
                }))
            }

            function u(t, n, r, i) {
                var o = new Event("track");
                o.track = n, o.receiver = r, o.transceiver = {
                    receiver: r
                }, o.streams = i, e.setTimeout((function() {
                    t._dispatchEvent("track", o)
                }))
            }
            var l = function(n) {
                var i = this,
                    o = document.createDocumentFragment();
                if (["addEventListener", "removeEventListener", "dispatchEvent"].forEach((function(e) {
                        i[e] = o[e].bind(o)
                    })), this.canTrickleIceCandidates = null, this.needNegotiation = !1, this.localStreams = [], this.remoteStreams = [], this._localDescription = null, this._remoteDescription = null, this.signalingState = "stable", this.iceConnectionState = "new", this.connectionState = "new", this.iceGatheringState = "new", n = JSON.parse(JSON.stringify(n || {})), this.usingBundle = "max-bundle" === n.bundlePolicy, "negotiate" === n.rtcpMuxPolicy) throw c("NotSupportedError", "rtcpMuxPolicy 'negotiate' is not supported");
                switch (n.rtcpMuxPolicy || (n.rtcpMuxPolicy = "require"), n.iceTransportPolicy) {
                    case "all":
                    case "relay":
                        break;
                    default:
                        n.iceTransportPolicy = "all"
                }
                switch (n.bundlePolicy) {
                    case "balanced":
                    case "max-compat":
                    case "max-bundle":
                        break;
                    default:
                        n.bundlePolicy = "balanced"
                }
                if (n.iceServers = function(e, t) {
                        var n = !1;
                        return (e = JSON.parse(JSON.stringify(e))).filter((function(e) {
                            if (e && (e.urls || e.url)) {
                                var r = e.urls || e.url;
                                e.url && !e.urls && console.warn("RTCIceServer.url is deprecated! Use urls instead.");
                                var i = "string" == typeof r;
                                return i && (r = [r]), r = r.filter((function(e) {
                                    return 0 === e.indexOf("turn:") && -1 !== e.indexOf("transport=udp") && -1 === e.indexOf("turn:[") && !n ? (n = !0, !0) : 0 === e.indexOf("stun:") && t >= 14393 && -1 === e.indexOf("?transport=udp")
                                })), delete e.url, e.urls = i ? r[0] : r, !!r.length
                            }
                        }))
                    }(n.iceServers || [], t), this._iceGatherers = [], n.iceCandidatePoolSize)
                    for (var a = n.iceCandidatePoolSize; a > 0; a--) this._iceGatherers.push(new e.RTCIceGatherer({
                        iceServers: n.iceServers,
                        gatherPolicy: n.iceTransportPolicy
                    }));
                else n.iceCandidatePoolSize = 0;
                this._config = n, this.transceivers = [], this._sdpSessionId = r.generateSessionId(), this._sdpSessionVersion = 0, this._dtlsRole = void 0, this._isClosed = !1
            };
            Object.defineProperty(l.prototype, "localDescription", {
                configurable: !0,
                get: function() {
                    return this._localDescription
                }
            }), Object.defineProperty(l.prototype, "remoteDescription", {
                configurable: !0,
                get: function() {
                    return this._remoteDescription
                }
            }), l.prototype.onicecandidate = null, l.prototype.onaddstream = null, l.prototype.ontrack = null, l.prototype.onremovestream = null, l.prototype.onsignalingstatechange = null, l.prototype.oniceconnectionstatechange = null, l.prototype.onconnectionstatechange = null, l.prototype.onicegatheringstatechange = null, l.prototype.onnegotiationneeded = null, l.prototype.ondatachannel = null, l.prototype._dispatchEvent = function(e, t) {
                this._isClosed || (this.dispatchEvent(t), "function" == typeof this["on" + e] && this["on" + e](t))
            }, l.prototype._emitGatheringStateChange = function() {
                var e = new Event("icegatheringstatechange");
                this._dispatchEvent("icegatheringstatechange", e)
            }, l.prototype.getConfiguration = function() {
                return this._config
            }, l.prototype.getLocalStreams = function() {
                return this.localStreams
            }, l.prototype.getRemoteStreams = function() {
                return this.remoteStreams
            }, l.prototype._createTransceiver = function(e, t) {
                var n = this.transceivers.length > 0,
                    r = {
                        track: null,
                        iceGatherer: null,
                        iceTransport: null,
                        dtlsTransport: null,
                        localCapabilities: null,
                        remoteCapabilities: null,
                        rtpSender: null,
                        rtpReceiver: null,
                        kind: e,
                        mid: null,
                        sendEncodingParameters: null,
                        recvEncodingParameters: null,
                        stream: null,
                        associatedRemoteMediaStreams: [],
                        wantReceive: !0
                    };
                if (this.usingBundle && n) r.iceTransport = this.transceivers[0].iceTransport, r.dtlsTransport = this.transceivers[0].dtlsTransport;
                else {
                    var i = this._createIceAndDtlsTransports();
                    r.iceTransport = i.iceTransport, r.dtlsTransport = i.dtlsTransport
                }
                return t || this.transceivers.push(r), r
            }, l.prototype.addTrack = function(t, n) {
                if (this._isClosed) throw c("InvalidStateError", "Attempted to call addTrack on a closed peerconnection.");
                var r;
                if (this.transceivers.find((function(e) {
                        return e.track === t
                    }))) throw c("InvalidAccessError", "Track already exists.");
                for (var i = 0; i < this.transceivers.length; i++) this.transceivers[i].track || this.transceivers[i].kind !== t.kind || (r = this.transceivers[i]);
                return r || (r = this._createTransceiver(t.kind)), this._maybeFireNegotiationNeeded(), -1 === this.localStreams.indexOf(n) && this.localStreams.push(n), r.track = t, r.stream = n, r.rtpSender = new e.RTCRtpSender(t, r.dtlsTransport), r.rtpSender
            }, l.prototype.addStream = function(e) {
                var n = this;
                if (t >= 15025) e.getTracks().forEach((function(t) {
                    n.addTrack(t, e)
                }));
                else {
                    var r = e.clone();
                    e.getTracks().forEach((function(e, t) {
                        var n = r.getTracks()[t];
                        e.addEventListener("enabled", (function(e) {
                            n.enabled = e.enabled
                        }))
                    })), r.getTracks().forEach((function(e) {
                        n.addTrack(e, r)
                    }))
                }
            }, l.prototype.removeTrack = function(t) {
                if (this._isClosed) throw c("InvalidStateError", "Attempted to call removeTrack on a closed peerconnection.");
                if (!(t instanceof e.RTCRtpSender)) throw new TypeError("Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.");
                var n = this.transceivers.find((function(e) {
                    return e.rtpSender === t
                }));
                if (!n) throw c("InvalidAccessError", "Sender was not created by this connection.");
                var r = n.stream;
                n.rtpSender.stop(), n.rtpSender = null, n.track = null, n.stream = null, -1 === this.transceivers.map((function(e) {
                    return e.stream
                })).indexOf(r) && this.localStreams.indexOf(r) > -1 && this.localStreams.splice(this.localStreams.indexOf(r), 1), this._maybeFireNegotiationNeeded()
            }, l.prototype.removeStream = function(e) {
                var t = this;
                e.getTracks().forEach((function(e) {
                    var n = t.getSenders().find((function(t) {
                        return t.track === e
                    }));
                    n && t.removeTrack(n)
                }))
            }, l.prototype.getSenders = function() {
                return this.transceivers.filter((function(e) {
                    return !!e.rtpSender
                })).map((function(e) {
                    return e.rtpSender
                }))
            }, l.prototype.getReceivers = function() {
                return this.transceivers.filter((function(e) {
                    return !!e.rtpReceiver
                })).map((function(e) {
                    return e.rtpReceiver
                }))
            }, l.prototype._createIceGatherer = function(t, n) {
                var r = this;
                if (n && t > 0) return this.transceivers[0].iceGatherer;
                if (this._iceGatherers.length) return this._iceGatherers.shift();
                var i = new e.RTCIceGatherer({
                    iceServers: this._config.iceServers,
                    gatherPolicy: this._config.iceTransportPolicy
                });
                return Object.defineProperty(i, "state", {
                    value: "new",
                    writable: !0
                }), this.transceivers[t].bufferedCandidateEvents = [], this.transceivers[t].bufferCandidates = function(e) {
                    var n = !e.candidate || 0 === Object.keys(e.candidate).length;
                    i.state = n ? "completed" : "gathering", null !== r.transceivers[t].bufferedCandidateEvents && r.transceivers[t].bufferedCandidateEvents.push(e)
                }, i.addEventListener("localcandidate", this.transceivers[t].bufferCandidates), i
            }, l.prototype._gather = function(t, n) {
                var i = this,
                    o = this.transceivers[n].iceGatherer;
                if (!o.onlocalcandidate) {
                    var a = this.transceivers[n].bufferedCandidateEvents;
                    this.transceivers[n].bufferedCandidateEvents = null, o.removeEventListener("localcandidate", this.transceivers[n].bufferCandidates), o.onlocalcandidate = function(e) {
                        if (!(i.usingBundle && n > 0)) {
                            var a = new Event("icecandidate");
                            a.candidate = {
                                sdpMid: t,
                                sdpMLineIndex: n
                            };
                            var s = e.candidate,
                                c = !s || 0 === Object.keys(s).length;
                            if (c) "new" !== o.state && "gathering" !== o.state || (o.state = "completed");
                            else {
                                "new" === o.state && (o.state = "gathering"), s.component = 1, s.ufrag = o.getLocalParameters().usernameFragment;
                                var u = r.writeCandidate(s);
                                a.candidate = Object.assign(a.candidate, r.parseCandidate(u)), a.candidate.candidate = u, a.candidate.toJSON = function() {
                                    return {
                                        candidate: a.candidate.candidate,
                                        sdpMid: a.candidate.sdpMid,
                                        sdpMLineIndex: a.candidate.sdpMLineIndex,
                                        usernameFragment: a.candidate.usernameFragment
                                    }
                                }
                            }
                            var l = r.getMediaSections(i._localDescription.sdp);
                            l[a.candidate.sdpMLineIndex] += c ? "a=end-of-candidates\r\n" : "a=" + a.candidate.candidate + "\r\n", i._localDescription.sdp = r.getDescription(i._localDescription.sdp) + l.join("");
                            var d = i.transceivers.every((function(e) {
                                return e.iceGatherer && "completed" === e.iceGatherer.state
                            }));
                            "gathering" !== i.iceGatheringState && (i.iceGatheringState = "gathering", i._emitGatheringStateChange()), c || i._dispatchEvent("icecandidate", a), d && (i._dispatchEvent("icecandidate", new Event("icecandidate")), i.iceGatheringState = "complete", i._emitGatheringStateChange())
                        }
                    }, e.setTimeout((function() {
                        a.forEach((function(e) {
                            o.onlocalcandidate(e)
                        }))
                    }), 0)
                }
            }, l.prototype._createIceAndDtlsTransports = function() {
                var t = this,
                    n = new e.RTCIceTransport(null);
                n.onicestatechange = function() {
                    t._updateIceConnectionState(), t._updateConnectionState()
                };
                var r = new e.RTCDtlsTransport(n);
                return r.ondtlsstatechange = function() {
                    t._updateConnectionState()
                }, r.onerror = function() {
                    Object.defineProperty(r, "state", {
                        value: "failed",
                        writable: !0
                    }), t._updateConnectionState()
                }, {
                    iceTransport: n,
                    dtlsTransport: r
                }
            }, l.prototype._disposeIceAndDtlsTransports = function(e) {
                var t = this.transceivers[e].iceGatherer;
                t && (delete t.onlocalcandidate, delete this.transceivers[e].iceGatherer);
                var n = this.transceivers[e].iceTransport;
                n && (delete n.onicestatechange, delete this.transceivers[e].iceTransport);
                var r = this.transceivers[e].dtlsTransport;
                r && (delete r.ondtlsstatechange, delete r.onerror, delete this.transceivers[e].dtlsTransport)
            }, l.prototype._transceive = function(e, n, i) {
                var a = o(e.localCapabilities, e.remoteCapabilities);
                n && e.rtpSender && (a.encodings = e.sendEncodingParameters, a.rtcp = {
                    cname: r.localCName,
                    compound: e.rtcpParameters.compound
                }, e.recvEncodingParameters.length && (a.rtcp.ssrc = e.recvEncodingParameters[0].ssrc), e.rtpSender.send(a)), i && e.rtpReceiver && a.codecs.length > 0 && ("video" === e.kind && e.recvEncodingParameters && t < 15019 && e.recvEncodingParameters.forEach((function(e) {
                    delete e.rtx
                })), e.recvEncodingParameters.length ? a.encodings = e.recvEncodingParameters : a.encodings = [{}], a.rtcp = {
                    compound: e.rtcpParameters.compound
                }, e.rtcpParameters.cname && (a.rtcp.cname = e.rtcpParameters.cname), e.sendEncodingParameters.length && (a.rtcp.ssrc = e.sendEncodingParameters[0].ssrc), e.rtpReceiver.receive(a))
            }, l.prototype.setLocalDescription = function(e) {
                var t, n, i = this;
                if (-1 === ["offer", "answer"].indexOf(e.type)) return Promise.reject(c("TypeError", 'Unsupported type "' + e.type + '"'));
                if (!a("setLocalDescription", e.type, i.signalingState) || i._isClosed) return Promise.reject(c("InvalidStateError", "Can not set local " + e.type + " in state " + i.signalingState));
                if ("offer" === e.type) t = r.splitSections(e.sdp), n = t.shift(), t.forEach((function(e, t) {
                    var n = r.parseRtpParameters(e);
                    i.transceivers[t].localCapabilities = n
                })), i.transceivers.forEach((function(e, t) {
                    i._gather(e.mid, t)
                }));
                else if ("answer" === e.type) {
                    t = r.splitSections(i._remoteDescription.sdp), n = t.shift();
                    var s = r.matchPrefix(n, "a=ice-lite").length > 0;
                    t.forEach((function(e, t) {
                        var a = i.transceivers[t],
                            c = a.iceGatherer,
                            u = a.iceTransport,
                            l = a.dtlsTransport,
                            d = a.localCapabilities,
                            p = a.remoteCapabilities;
                        if (!(r.isRejected(e) && 0 === r.matchPrefix(e, "a=bundle-only").length) && !a.rejected) {
                            var h = r.getIceParameters(e, n),
                                f = r.getDtlsParameters(e, n);
                            s && (f.role = "server"), i.usingBundle && 0 !== t || (i._gather(a.mid, t), "new" === u.state && u.start(c, h, s ? "controlling" : "controlled"), "new" === l.state && l.start(f));
                            var m = o(d, p);
                            i._transceive(a, m.codecs.length > 0, !1)
                        }
                    }))
                }
                return i._localDescription = {
                    type: e.type,
                    sdp: e.sdp
                }, "offer" === e.type ? i._updateSignalingState("have-local-offer") : i._updateSignalingState("stable"), Promise.resolve()
            }, l.prototype.setRemoteDescription = function(i) {
                var l = this;
                if (-1 === ["offer", "answer"].indexOf(i.type)) return Promise.reject(c("TypeError", 'Unsupported type "' + i.type + '"'));
                if (!a("setRemoteDescription", i.type, l.signalingState) || l._isClosed) return Promise.reject(c("InvalidStateError", "Can not set remote " + i.type + " in state " + l.signalingState));
                var d = {};
                l.remoteStreams.forEach((function(e) {
                    d[e.id] = e
                }));
                var p = [],
                    h = r.splitSections(i.sdp),
                    f = h.shift(),
                    m = r.matchPrefix(f, "a=ice-lite").length > 0,
                    v = r.matchPrefix(f, "a=group:BUNDLE ").length > 0;
                l.usingBundle = v;
                var y = r.matchPrefix(f, "a=ice-options:")[0];
                return l.canTrickleIceCandidates = !!y && y.substr(14).split(" ").indexOf("trickle") >= 0, h.forEach((function(a, c) {
                    var u = r.splitLines(a),
                        h = r.getKind(a),
                        y = r.isRejected(a) && 0 === r.matchPrefix(a, "a=bundle-only").length,
                        g = u[0].substr(2).split(" ")[2],
                        _ = r.getDirection(a, f),
                        S = r.parseMsid(a),
                        b = r.getMid(a) || r.generateIdentifier();
                    if (y || "application" === h && ("DTLS/SCTP" === g || "UDP/DTLS/SCTP" === g)) l.transceivers[c] = {
                        mid: b,
                        kind: h,
                        protocol: g,
                        rejected: !0
                    };
                    else {
                        var E, T, C, R, A, w, k, O, I;
                        !y && l.transceivers[c] && l.transceivers[c].rejected && (l.transceivers[c] = l._createTransceiver(h, !0));
                        var P, D, N = r.parseRtpParameters(a);
                        y || (P = r.getIceParameters(a, f), (D = r.getDtlsParameters(a, f)).role = "client"), k = r.parseRtpEncodingParameters(a);
                        var L = r.parseRtcpParameters(a),
                            M = r.matchPrefix(a, "a=end-of-candidates", f).length > 0,
                            x = r.matchPrefix(a, "a=candidate:").map((function(e) {
                                return r.parseCandidate(e)
                            })).filter((function(e) {
                                return 1 === e.component
                            }));
                        if (("offer" === i.type || "answer" === i.type) && !y && v && c > 0 && l.transceivers[c] && (l._disposeIceAndDtlsTransports(c), l.transceivers[c].iceGatherer = l.transceivers[0].iceGatherer, l.transceivers[c].iceTransport = l.transceivers[0].iceTransport, l.transceivers[c].dtlsTransport = l.transceivers[0].dtlsTransport, l.transceivers[c].rtpSender && l.transceivers[c].rtpSender.setTransport(l.transceivers[0].dtlsTransport), l.transceivers[c].rtpReceiver && l.transceivers[c].rtpReceiver.setTransport(l.transceivers[0].dtlsTransport)), "offer" !== i.type || y) {
                            if ("answer" === i.type && !y) {
                                T = (E = l.transceivers[c]).iceGatherer, C = E.iceTransport, R = E.dtlsTransport, A = E.rtpReceiver, w = E.sendEncodingParameters, O = E.localCapabilities, l.transceivers[c].recvEncodingParameters = k, l.transceivers[c].remoteCapabilities = N, l.transceivers[c].rtcpParameters = L, x.length && "new" === C.state && (!m && !M || v && 0 !== c ? x.forEach((function(e) {
                                    s(E.iceTransport, e)
                                })) : C.setRemoteCandidates(x)), v && 0 !== c || ("new" === C.state && C.start(T, P, "controlling"), "new" === R.state && R.start(D)), !o(E.localCapabilities, E.remoteCapabilities).codecs.filter((function(e) {
                                    return "rtx" === e.name.toLowerCase()
                                })).length && E.sendEncodingParameters[0].rtx && delete E.sendEncodingParameters[0].rtx, l._transceive(E, "sendrecv" === _ || "recvonly" === _, "sendrecv" === _ || "sendonly" === _), !A || "sendrecv" !== _ && "sendonly" !== _ ? delete E.rtpReceiver : (I = A.track, S ? (d[S.stream] || (d[S.stream] = new e.MediaStream), n(I, d[S.stream]), p.push([I, A, d[S.stream]])) : (d.default || (d.default = new e.MediaStream), n(I, d.default), p.push([I, A, d.default])))
                            }
                        } else {
                            (E = l.transceivers[c] || l._createTransceiver(h)).mid = b, E.iceGatherer || (E.iceGatherer = l._createIceGatherer(c, v)), x.length && "new" === E.iceTransport.state && (!M || v && 0 !== c ? x.forEach((function(e) {
                                s(E.iceTransport, e)
                            })) : E.iceTransport.setRemoteCandidates(x)), O = e.RTCRtpReceiver.getCapabilities(h), t < 15019 && (O.codecs = O.codecs.filter((function(e) {
                                return "rtx" !== e.name
                            }))), w = E.sendEncodingParameters || [{
                                ssrc: 1001 * (2 * c + 2)
                            }];
                            var j, F = !1;
                            if ("sendrecv" === _ || "sendonly" === _) {
                                if (F = !E.rtpReceiver, A = E.rtpReceiver || new e.RTCRtpReceiver(E.dtlsTransport, h), F) I = A.track, S && "-" === S.stream || (S ? (d[S.stream] || (d[S.stream] = new e.MediaStream, Object.defineProperty(d[S.stream], "id", {
                                    get: function() {
                                        return S.stream
                                    }
                                })), Object.defineProperty(I, "id", {
                                    get: function() {
                                        return S.track
                                    }
                                }), j = d[S.stream]) : (d.default || (d.default = new e.MediaStream), j = d.default)), j && (n(I, j), E.associatedRemoteMediaStreams.push(j)), p.push([I, A, j])
                            } else E.rtpReceiver && E.rtpReceiver.track && (E.associatedRemoteMediaStreams.forEach((function(t) {
                                var n = t.getTracks().find((function(e) {
                                    return e.id === E.rtpReceiver.track.id
                                }));
                                n && function(t, n) {
                                    n.removeTrack(t), n.dispatchEvent(new e.MediaStreamTrackEvent("removetrack", {
                                        track: t
                                    }))
                                }(n, t)
                            })), E.associatedRemoteMediaStreams = []);
                            E.localCapabilities = O, E.remoteCapabilities = N, E.rtpReceiver = A, E.rtcpParameters = L, E.sendEncodingParameters = w, E.recvEncodingParameters = k, l._transceive(l.transceivers[c], !1, F)
                        }
                    }
                })), void 0 === l._dtlsRole && (l._dtlsRole = "offer" === i.type ? "active" : "passive"), l._remoteDescription = {
                    type: i.type,
                    sdp: i.sdp
                }, "offer" === i.type ? l._updateSignalingState("have-remote-offer") : l._updateSignalingState("stable"), Object.keys(d).forEach((function(t) {
                    var n = d[t];
                    if (n.getTracks().length) {
                        if (-1 === l.remoteStreams.indexOf(n)) {
                            l.remoteStreams.push(n);
                            var r = new Event("addstream");
                            r.stream = n, e.setTimeout((function() {
                                l._dispatchEvent("addstream", r)
                            }))
                        }
                        p.forEach((function(e) {
                            var t = e[0],
                                r = e[1];
                            n.id === e[2].id && u(l, t, r, [n])
                        }))
                    }
                })), p.forEach((function(e) {
                    e[2] || u(l, e[0], e[1], [])
                })), e.setTimeout((function() {
                    l && l.transceivers && l.transceivers.forEach((function(e) {
                        e.iceTransport && "new" === e.iceTransport.state && e.iceTransport.getRemoteCandidates().length > 0 && (console.warn("Timeout for addRemoteCandidate. Consider sending an end-of-candidates notification"), e.iceTransport.addRemoteCandidate({}))
                    }))
                }), 4e3), Promise.resolve()
            }, l.prototype.close = function() {
                this.transceivers.forEach((function(e) {
                    e.iceTransport && e.iceTransport.stop(), e.dtlsTransport && e.dtlsTransport.stop(), e.rtpSender && e.rtpSender.stop(), e.rtpReceiver && e.rtpReceiver.stop()
                })), this._isClosed = !0, this._updateSignalingState("closed")
            }, l.prototype._updateSignalingState = function(e) {
                this.signalingState = e;
                var t = new Event("signalingstatechange");
                this._dispatchEvent("signalingstatechange", t)
            }, l.prototype._maybeFireNegotiationNeeded = function() {
                var t = this;
                "stable" === this.signalingState && !0 !== this.needNegotiation && (this.needNegotiation = !0, e.setTimeout((function() {
                    if (t.needNegotiation) {
                        t.needNegotiation = !1;
                        var e = new Event("negotiationneeded");
                        t._dispatchEvent("negotiationneeded", e)
                    }
                }), 0))
            }, l.prototype._updateIceConnectionState = function() {
                var e, t = {
                    new: 0,
                    closed: 0,
                    checking: 0,
                    connected: 0,
                    completed: 0,
                    disconnected: 0,
                    failed: 0
                };
                if (this.transceivers.forEach((function(e) {
                        e.iceTransport && !e.rejected && t[e.iceTransport.state]++
                    })), e = "new", t.failed > 0 ? e = "failed" : t.checking > 0 ? e = "checking" : t.disconnected > 0 ? e = "disconnected" : t.new > 0 ? e = "new" : t.connected > 0 ? e = "connected" : t.completed > 0 && (e = "completed"), e !== this.iceConnectionState) {
                    this.iceConnectionState = e;
                    var n = new Event("iceconnectionstatechange");
                    this._dispatchEvent("iceconnectionstatechange", n)
                }
            }, l.prototype._updateConnectionState = function() {
                var e, t = {
                    new: 0,
                    closed: 0,
                    connecting: 0,
                    connected: 0,
                    completed: 0,
                    disconnected: 0,
                    failed: 0
                };
                if (this.transceivers.forEach((function(e) {
                        e.iceTransport && e.dtlsTransport && !e.rejected && (t[e.iceTransport.state]++, t[e.dtlsTransport.state]++)
                    })), t.connected += t.completed, e = "new", t.failed > 0 ? e = "failed" : t.connecting > 0 ? e = "connecting" : t.disconnected > 0 ? e = "disconnected" : t.new > 0 ? e = "new" : t.connected > 0 && (e = "connected"), e !== this.connectionState) {
                    this.connectionState = e;
                    var n = new Event("connectionstatechange");
                    this._dispatchEvent("connectionstatechange", n)
                }
            }, l.prototype.createOffer = function() {
                var n = this;
                if (n._isClosed) return Promise.reject(c("InvalidStateError", "Can not call createOffer after close"));
                var o = n.transceivers.filter((function(e) {
                        return "audio" === e.kind
                    })).length,
                    a = n.transceivers.filter((function(e) {
                        return "video" === e.kind
                    })).length,
                    s = arguments[0];
                if (s) {
                    if (s.mandatory || s.optional) throw new TypeError("Legacy mandatory/optional constraints not supported.");
                    void 0 !== s.offerToReceiveAudio && (o = !0 === s.offerToReceiveAudio ? 1 : !1 === s.offerToReceiveAudio ? 0 : s.offerToReceiveAudio), void 0 !== s.offerToReceiveVideo && (a = !0 === s.offerToReceiveVideo ? 1 : !1 === s.offerToReceiveVideo ? 0 : s.offerToReceiveVideo)
                }
                for (n.transceivers.forEach((function(e) {
                        "audio" === e.kind ? --o < 0 && (e.wantReceive = !1) : "video" === e.kind && --a < 0 && (e.wantReceive = !1)
                    })); o > 0 || a > 0;) o > 0 && (n._createTransceiver("audio"), o--), a > 0 && (n._createTransceiver("video"), a--);
                var u = r.writeSessionBoilerplate(n._sdpSessionId, n._sdpSessionVersion++);
                n.transceivers.forEach((function(i, o) {
                    var a = i.track,
                        s = i.kind,
                        c = i.mid || r.generateIdentifier();
                    i.mid = c, i.iceGatherer || (i.iceGatherer = n._createIceGatherer(o, n.usingBundle));
                    var u = e.RTCRtpSender.getCapabilities(s);
                    t < 15019 && (u.codecs = u.codecs.filter((function(e) {
                        return "rtx" !== e.name
                    }))), u.codecs.forEach((function(e) {
                        "H264" === e.name && void 0 === e.parameters["level-asymmetry-allowed"] && (e.parameters["level-asymmetry-allowed"] = "1"), i.remoteCapabilities && i.remoteCapabilities.codecs && i.remoteCapabilities.codecs.forEach((function(t) {
                            e.name.toLowerCase() === t.name.toLowerCase() && e.clockRate === t.clockRate && (e.preferredPayloadType = t.payloadType)
                        }))
                    })), u.headerExtensions.forEach((function(e) {
                        (i.remoteCapabilities && i.remoteCapabilities.headerExtensions || []).forEach((function(t) {
                            e.uri === t.uri && (e.id = t.id)
                        }))
                    }));
                    var l = i.sendEncodingParameters || [{
                        ssrc: 1001 * (2 * o + 1)
                    }];
                    a && t >= 15019 && "video" === s && !l[0].rtx && (l[0].rtx = {
                        ssrc: l[0].ssrc + 1
                    }), i.wantReceive && (i.rtpReceiver = new e.RTCRtpReceiver(i.dtlsTransport, s)), i.localCapabilities = u, i.sendEncodingParameters = l
                })), "max-compat" !== n._config.bundlePolicy && (u += "a=group:BUNDLE " + n.transceivers.map((function(e) {
                    return e.mid
                })).join(" ") + "\r\n"), u += "a=ice-options:trickle\r\n", n.transceivers.forEach((function(e, t) {
                    u += i(e, e.localCapabilities, "offer", e.stream, n._dtlsRole), u += "a=rtcp-rsize\r\n", !e.iceGatherer || "new" === n.iceGatheringState || 0 !== t && n.usingBundle || (e.iceGatherer.getLocalCandidates().forEach((function(e) {
                        e.component = 1, u += "a=" + r.writeCandidate(e) + "\r\n"
                    })), "completed" === e.iceGatherer.state && (u += "a=end-of-candidates\r\n"))
                }));
                var l = new e.RTCSessionDescription({
                    type: "offer",
                    sdp: u
                });
                return Promise.resolve(l)
            }, l.prototype.createAnswer = function() {
                var n = this;
                if (n._isClosed) return Promise.reject(c("InvalidStateError", "Can not call createAnswer after close"));
                if ("have-remote-offer" !== n.signalingState && "have-local-pranswer" !== n.signalingState) return Promise.reject(c("InvalidStateError", "Can not call createAnswer in signalingState " + n.signalingState));
                var a = r.writeSessionBoilerplate(n._sdpSessionId, n._sdpSessionVersion++);
                n.usingBundle && (a += "a=group:BUNDLE " + n.transceivers.map((function(e) {
                    return e.mid
                })).join(" ") + "\r\n"), a += "a=ice-options:trickle\r\n";
                var s = r.getMediaSections(n._remoteDescription.sdp).length;
                n.transceivers.forEach((function(e, r) {
                    if (!(r + 1 > s)) {
                        if (e.rejected) return "application" === e.kind ? "DTLS/SCTP" === e.protocol ? a += "m=application 0 DTLS/SCTP 5000\r\n" : a += "m=application 0 " + e.protocol + " webrtc-datachannel\r\n" : "audio" === e.kind ? a += "m=audio 0 UDP/TLS/RTP/SAVPF 0\r\na=rtpmap:0 PCMU/8000\r\n" : "video" === e.kind && (a += "m=video 0 UDP/TLS/RTP/SAVPF 120\r\na=rtpmap:120 VP8/90000\r\n"), void(a += "c=IN IP4 0.0.0.0\r\na=inactive\r\na=mid:" + e.mid + "\r\n");
                        var c;
                        if (e.stream) "audio" === e.kind ? c = e.stream.getAudioTracks()[0] : "video" === e.kind && (c = e.stream.getVideoTracks()[0]), c && t >= 15019 && "video" === e.kind && !e.sendEncodingParameters[0].rtx && (e.sendEncodingParameters[0].rtx = {
                            ssrc: e.sendEncodingParameters[0].ssrc + 1
                        });
                        var u = o(e.localCapabilities, e.remoteCapabilities);
                        !u.codecs.filter((function(e) {
                            return "rtx" === e.name.toLowerCase()
                        })).length && e.sendEncodingParameters[0].rtx && delete e.sendEncodingParameters[0].rtx, a += i(e, u, "answer", e.stream, n._dtlsRole), e.rtcpParameters && e.rtcpParameters.reducedSize && (a += "a=rtcp-rsize\r\n")
                    }
                }));
                var u = new e.RTCSessionDescription({
                    type: "answer",
                    sdp: a
                });
                return Promise.resolve(u)
            }, l.prototype.addIceCandidate = function(e) {
                var t, n = this;
                return e && void 0 === e.sdpMLineIndex && !e.sdpMid ? Promise.reject(new TypeError("sdpMLineIndex or sdpMid required")) : new Promise((function(i, o) {
                    if (!n._remoteDescription) return o(c("InvalidStateError", "Can not add ICE candidate without a remote description"));
                    if (e && "" !== e.candidate) {
                        var a = e.sdpMLineIndex;
                        if (e.sdpMid)
                            for (var u = 0; u < n.transceivers.length; u++)
                                if (n.transceivers[u].mid === e.sdpMid) {
                                    a = u;
                                    break
                                } var l = n.transceivers[a];
                        if (!l) return o(c("OperationError", "Can not add ICE candidate"));
                        if (l.rejected) return i();
                        var d = Object.keys(e.candidate).length > 0 ? r.parseCandidate(e.candidate) : {};
                        if ("tcp" === d.protocol && (0 === d.port || 9 === d.port)) return i();
                        if (d.component && 1 !== d.component) return i();
                        if ((0 === a || a > 0 && l.iceTransport !== n.transceivers[0].iceTransport) && !s(l.iceTransport, d)) return o(c("OperationError", "Can not add ICE candidate"));
                        var p = e.candidate.trim();
                        0 === p.indexOf("a=") && (p = p.substr(2)), (t = r.getMediaSections(n._remoteDescription.sdp))[a] += "a=" + (d.type ? p : "end-of-candidates") + "\r\n", n._remoteDescription.sdp = r.getDescription(n._remoteDescription.sdp) + t.join("")
                    } else
                        for (var h = 0; h < n.transceivers.length && (n.transceivers[h].rejected || (n.transceivers[h].iceTransport.addRemoteCandidate({}), (t = r.getMediaSections(n._remoteDescription.sdp))[h] += "a=end-of-candidates\r\n", n._remoteDescription.sdp = r.getDescription(n._remoteDescription.sdp) + t.join(""), !n.usingBundle)); h++);
                    i()
                }))
            }, l.prototype.getStats = function(t) {
                if (t && t instanceof e.MediaStreamTrack) {
                    var n = null;
                    if (this.transceivers.forEach((function(e) {
                            e.rtpSender && e.rtpSender.track === t ? n = e.rtpSender : e.rtpReceiver && e.rtpReceiver.track === t && (n = e.rtpReceiver)
                        })), !n) throw c("InvalidAccessError", "Invalid selector.");
                    return n.getStats()
                }
                var r = [];
                return this.transceivers.forEach((function(e) {
                    ["rtpSender", "rtpReceiver", "iceGatherer", "iceTransport", "dtlsTransport"].forEach((function(t) {
                        e[t] && r.push(e[t].getStats())
                    }))
                })), Promise.all(r).then((function(e) {
                    var t = new Map;
                    return e.forEach((function(e) {
                        e.forEach((function(e) {
                            t.set(e.id, e)
                        }))
                    })), t
                }))
            };
            ["RTCRtpSender", "RTCRtpReceiver", "RTCIceGatherer", "RTCIceTransport", "RTCDtlsTransport"].forEach((function(t) {
                var n = e[t];
                if (n && n.prototype && n.prototype.getStats) {
                    var r = n.prototype.getStats;
                    n.prototype.getStats = function() {
                        return r.apply(this).then((function(e) {
                            var t = new Map;
                            return Object.keys(e).forEach((function(n) {
                                var r;
                                e[n].type = {
                                    inboundrtp: "inbound-rtp",
                                    outboundrtp: "outbound-rtp",
                                    candidatepair: "candidate-pair",
                                    localcandidate: "local-candidate",
                                    remotecandidate: "remote-candidate"
                                } [(r = e[n]).type] || r.type, t.set(n, e[n])
                            })), t
                        }))
                    }
                }
            }));
            var d = ["createOffer", "createAnswer"];
            return d.forEach((function(e) {
                var t = l.prototype[e];
                l.prototype[e] = function() {
                    var e = arguments;
                    return "function" == typeof e[0] || "function" == typeof e[1] ? t.apply(this, [arguments[2]]).then((function(t) {
                        "function" == typeof e[0] && e[0].apply(null, [t])
                    }), (function(t) {
                        "function" == typeof e[1] && e[1].apply(null, [t])
                    })) : t.apply(this, arguments)
                }
            })), (d = ["setLocalDescription", "setRemoteDescription", "addIceCandidate"]).forEach((function(e) {
                var t = l.prototype[e];
                l.prototype[e] = function() {
                    var e = arguments;
                    return "function" == typeof e[1] || "function" == typeof e[2] ? t.apply(this, arguments).then((function() {
                        "function" == typeof e[1] && e[1].apply(null)
                    }), (function(t) {
                        "function" == typeof e[2] && e[2].apply(null, [t])
                    })) : t.apply(this, arguments)
                }
            })), ["getStats"].forEach((function(e) {
                var t = l.prototype[e];
                l.prototype[e] = function() {
                    var e = arguments;
                    return "function" == typeof e[1] ? t.apply(this, arguments).then((function() {
                        "function" == typeof e[1] && e[1].apply(null)
                    })) : t.apply(this, arguments)
                }
            })), l
        }
    }, function(e, t, n) {
        "use strict";
        e.exports = function(e) {
            var t = e && e.navigator,
                n = t.mediaDevices.getUserMedia.bind(t.mediaDevices);
            t.mediaDevices.getUserMedia = function(e) {
                return n(e).catch((function(e) {
                    return Promise.reject(function(e) {
                        return {
                            name: {
                                PermissionDeniedError: "NotAllowedError"
                            } [e.name] || e.name,
                            message: e.message,
                            constraint: e.constraint,
                            toString: function() {
                                return this.name
                            }
                        }
                    }(e))
                }))
            }
        }
    }, function(e, t, n) {
        "use strict";

        function r(e) {
            return (r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                return typeof e
            } : function(e) {
                return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
            })(e)
        }
        var i = n(38),
            o = {
                shimOnTrack: function(e) {
                    "object" !== r(e) || !e.RTCPeerConnection || "ontrack" in e.RTCPeerConnection.prototype || Object.defineProperty(e.RTCPeerConnection.prototype, "ontrack", {
                        get: function() {
                            return this._ontrack
                        },
                        set: function(e) {
                            this._ontrack && (this.removeEventListener("track", this._ontrack), this.removeEventListener("addstream", this._ontrackpoly)), this.addEventListener("track", this._ontrack = e), this.addEventListener("addstream", this._ontrackpoly = function(e) {
                                e.stream.getTracks().forEach(function(t) {
                                    var n = new Event("track");
                                    n.track = t, n.receiver = {
                                        track: t
                                    }, n.transceiver = {
                                        receiver: n.receiver
                                    }, n.streams = [e.stream], this.dispatchEvent(n)
                                }.bind(this))
                            }.bind(this))
                        }
                    }), "object" === r(e) && e.RTCTrackEvent && "receiver" in e.RTCTrackEvent.prototype && !("transceiver" in e.RTCTrackEvent.prototype) && Object.defineProperty(e.RTCTrackEvent.prototype, "transceiver", {
                        get: function() {
                            return {
                                receiver: this.receiver
                            }
                        }
                    })
                },
                shimSourceObject: function(e) {
                    "object" === r(e) && (!e.HTMLMediaElement || "srcObject" in e.HTMLMediaElement.prototype || Object.defineProperty(e.HTMLMediaElement.prototype, "srcObject", {
                        get: function() {
                            return this.mozSrcObject
                        },
                        set: function(e) {
                            this.mozSrcObject = e
                        }
                    }))
                },
                shimPeerConnection: function(e) {
                    var t = i.detectBrowser(e);
                    if ("object" === r(e) && (e.RTCPeerConnection || e.mozRTCPeerConnection)) {
                        e.RTCPeerConnection || (e.RTCPeerConnection = function(n, r) {
                            if (t.version < 38 && n && n.iceServers) {
                                for (var i = [], o = 0; o < n.iceServers.length; o++) {
                                    var a = n.iceServers[o];
                                    if (a.hasOwnProperty("urls"))
                                        for (var s = 0; s < a.urls.length; s++) {
                                            var c = {
                                                url: a.urls[s]
                                            };
                                            0 === a.urls[s].indexOf("turn") && (c.username = a.username, c.credential = a.credential), i.push(c)
                                        } else i.push(n.iceServers[o])
                                }
                                n.iceServers = i
                            }
                            return new e.mozRTCPeerConnection(n, r)
                        }, e.RTCPeerConnection.prototype = e.mozRTCPeerConnection.prototype, e.mozRTCPeerConnection.generateCertificate && Object.defineProperty(e.RTCPeerConnection, "generateCertificate", {
                            get: function() {
                                return e.mozRTCPeerConnection.generateCertificate
                            }
                        }), e.RTCSessionDescription = e.mozRTCSessionDescription, e.RTCIceCandidate = e.mozRTCIceCandidate), ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach((function(t) {
                            var n = e.RTCPeerConnection.prototype[t];
                            e.RTCPeerConnection.prototype[t] = function() {
                                return arguments[0] = new("addIceCandidate" === t ? e.RTCIceCandidate : e.RTCSessionDescription)(arguments[0]), n.apply(this, arguments)
                            }
                        }));
                        var n = e.RTCPeerConnection.prototype.addIceCandidate;
                        e.RTCPeerConnection.prototype.addIceCandidate = function() {
                            return arguments[0] ? n.apply(this, arguments) : (arguments[1] && arguments[1].apply(null), Promise.resolve())
                        };
                        var o = {
                                inboundrtp: "inbound-rtp",
                                outboundrtp: "outbound-rtp",
                                candidatepair: "candidate-pair",
                                localcandidate: "local-candidate",
                                remotecandidate: "remote-candidate"
                            },
                            a = e.RTCPeerConnection.prototype.getStats;
                        e.RTCPeerConnection.prototype.getStats = function(e, n, r) {
                            return a.apply(this, [e || null]).then((function(e) {
                                if (t.version < 48 && (e = function(e) {
                                        var t = new Map;
                                        return Object.keys(e).forEach((function(n) {
                                            t.set(n, e[n]), t[n] = e[n]
                                        })), t
                                    }(e)), t.version < 53 && !n) try {
                                    e.forEach((function(e) {
                                        e.type = o[e.type] || e.type
                                    }))
                                } catch (t) {
                                    if ("TypeError" !== t.name) throw t;
                                    e.forEach((function(t, n) {
                                        e.set(n, Object.assign({}, t, {
                                            type: o[t.type] || t.type
                                        }))
                                    }))
                                }
                                return e
                            })).then(n, r)
                        }
                    }
                }
            };
        e.exports = {
            shimOnTrack: o.shimOnTrack,
            shimSourceObject: o.shimSourceObject,
            shimPeerConnection: o.shimPeerConnection,
            shimGetUserMedia: n(136)
        }
    }, function(e, t, n) {
        "use strict";

        function r(e) {
            return (r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                return typeof e
            } : function(e) {
                return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
            })(e)
        }
        var i = n(38),
            o = i.log;
        e.exports = function(e) {
            var t = i.detectBrowser(e),
                n = e && e.navigator,
                a = e && e.MediaStreamTrack,
                s = function(e) {
                    return {
                        name: {
                            InternalError: "NotReadableError",
                            NotSupportedError: "TypeError",
                            PermissionDeniedError: "NotAllowedError",
                            SecurityError: "NotAllowedError"
                        } [e.name] || e.name,
                        message: {
                            "The operation is insecure.": "The request is not allowed by the user agent or the platform in the current context."
                        } [e.message] || e.message,
                        constraint: e.constraint,
                        toString: function() {
                            return this.name + (this.message && ": ") + this.message
                        }
                    }
                },
                c = function(e, i, a) {
                    var c = function(e) {
                        if ("object" !== r(e) || e.require) return e;
                        var t = [];
                        return Object.keys(e).forEach((function(n) {
                            if ("require" !== n && "advanced" !== n && "mediaSource" !== n) {
                                var i = e[n] = "object" === r(e[n]) ? e[n] : {
                                    ideal: e[n]
                                };
                                if (void 0 === i.min && void 0 === i.max && void 0 === i.exact || t.push(n), void 0 !== i.exact && ("number" == typeof i.exact ? i.min = i.max = i.exact : e[n] = i.exact, delete i.exact), void 0 !== i.ideal) {
                                    e.advanced = e.advanced || [];
                                    var o = {};
                                    "number" == typeof i.ideal ? o[n] = {
                                        min: i.ideal,
                                        max: i.ideal
                                    } : o[n] = i.ideal, e.advanced.push(o), delete i.ideal, Object.keys(i).length || delete e[n]
                                }
                            }
                        })), t.length && (e.require = t), e
                    };
                    return e = JSON.parse(JSON.stringify(e)), t.version < 38 && (o("spec: " + JSON.stringify(e)), e.audio && (e.audio = c(e.audio)), e.video && (e.video = c(e.video)), o("ff37: " + JSON.stringify(e))), n.mozGetUserMedia(e, i, (function(e) {
                        a(s(e))
                    }))
                };
            if (n.mediaDevices || (n.mediaDevices = {
                    getUserMedia: function(e) {
                        return new Promise((function(t, n) {
                            c(e, t, n)
                        }))
                    },
                    addEventListener: function() {},
                    removeEventListener: function() {}
                }), n.mediaDevices.enumerateDevices = n.mediaDevices.enumerateDevices || function() {
                    return new Promise((function(e) {
                        e([{
                            kind: "audioinput",
                            deviceId: "default",
                            label: "",
                            groupId: ""
                        }, {
                            kind: "videoinput",
                            deviceId: "default",
                            label: "",
                            groupId: ""
                        }])
                    }))
                }, t.version < 41) {
                var u = n.mediaDevices.enumerateDevices.bind(n.mediaDevices);
                n.mediaDevices.enumerateDevices = function() {
                    return u().then(void 0, (function(e) {
                        if ("NotFoundError" === e.name) return [];
                        throw e
                    }))
                }
            }
            if (t.version < 49) {
                var l = n.mediaDevices.getUserMedia.bind(n.mediaDevices);
                n.mediaDevices.getUserMedia = function(e) {
                    return l(e).then((function(t) {
                        if (e.audio && !t.getAudioTracks().length || e.video && !t.getVideoTracks().length) throw t.getTracks().forEach((function(e) {
                            e.stop()
                        })), new DOMException("The object can not be found here.", "NotFoundError");
                        return t
                    }), (function(e) {
                        return Promise.reject(s(e))
                    }))
                }
            }
            if (!(t.version > 55 && "autoGainControl" in n.mediaDevices.getSupportedConstraints())) {
                var d = function(e, t, n) {
                        t in e && !(n in e) && (e[n] = e[t], delete e[t])
                    },
                    p = n.mediaDevices.getUserMedia.bind(n.mediaDevices);
                if (n.mediaDevices.getUserMedia = function(e) {
                        return "object" === r(e) && "object" === r(e.audio) && (e = JSON.parse(JSON.stringify(e)), d(e.audio, "autoGainControl", "mozAutoGainControl"), d(e.audio, "noiseSuppression", "mozNoiseSuppression")), p(e)
                    }, a && a.prototype.getSettings) {
                    var h = a.prototype.getSettings;
                    a.prototype.getSettings = function() {
                        var e = h.apply(this, arguments);
                        return d(e, "mozAutoGainControl", "autoGainControl"), d(e, "mozNoiseSuppression", "noiseSuppression"), e
                    }
                }
                if (a && a.prototype.applyConstraints) {
                    var f = a.prototype.applyConstraints;
                    a.prototype.applyConstraints = function(e) {
                        return "audio" === this.kind && "object" === r(e) && (e = JSON.parse(JSON.stringify(e)), d(e, "autoGainControl", "mozAutoGainControl"), d(e, "noiseSuppression", "mozNoiseSuppression")), f.apply(this, [e])
                    }
                }
            }
            n.getUserMedia = function(e, r, o) {
                if (t.version < 44) return c(e, r, o);
                i.deprecated("navigator.getUserMedia", "navigator.mediaDevices.getUserMedia"), n.mediaDevices.getUserMedia(e).then(r, o)
            }
        }
    }, function(e, t, n) {
        "use strict";

        function r(e) {
            return (r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                return typeof e
            } : function(e) {
                return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
            })(e)
        }
        var i = n(38),
            o = {
                shimLocalStreamsAPI: function(e) {
                    if ("object" === r(e) && e.RTCPeerConnection) {
                        if ("getLocalStreams" in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.getLocalStreams = function() {
                                return this._localStreams || (this._localStreams = []), this._localStreams
                            }), "getStreamById" in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.getStreamById = function(e) {
                                var t = null;
                                return this._localStreams && this._localStreams.forEach((function(n) {
                                    n.id === e && (t = n)
                                })), this._remoteStreams && this._remoteStreams.forEach((function(n) {
                                    n.id === e && (t = n)
                                })), t
                            }), !("addStream" in e.RTCPeerConnection.prototype)) {
                            var t = e.RTCPeerConnection.prototype.addTrack;
                            e.RTCPeerConnection.prototype.addStream = function(e) {
                                this._localStreams || (this._localStreams = []), -1 === this._localStreams.indexOf(e) && this._localStreams.push(e);
                                var n = this;
                                e.getTracks().forEach((function(r) {
                                    t.call(n, r, e)
                                }))
                            }, e.RTCPeerConnection.prototype.addTrack = function(e, n) {
                                n && (this._localStreams ? -1 === this._localStreams.indexOf(n) && this._localStreams.push(n) : this._localStreams = [n]), t.call(this, e, n)
                            }
                        }
                        "removeStream" in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.removeStream = function(e) {
                            this._localStreams || (this._localStreams = []);
                            var t = this._localStreams.indexOf(e);
                            if (-1 !== t) {
                                this._localStreams.splice(t, 1);
                                var n = this,
                                    r = e.getTracks();
                                this.getSenders().forEach((function(e) {
                                    -1 !== r.indexOf(e.track) && n.removeTrack(e)
                                }))
                            }
                        })
                    }
                },
                shimRemoteStreamsAPI: function(e) {
                    "object" === r(e) && e.RTCPeerConnection && ("getRemoteStreams" in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.getRemoteStreams = function() {
                        return this._remoteStreams ? this._remoteStreams : []
                    }), "onaddstream" in e.RTCPeerConnection.prototype || Object.defineProperty(e.RTCPeerConnection.prototype, "onaddstream", {
                        get: function() {
                            return this._onaddstream
                        },
                        set: function(e) {
                            this._onaddstream && (this.removeEventListener("addstream", this._onaddstream), this.removeEventListener("track", this._onaddstreampoly)), this.addEventListener("addstream", this._onaddstream = e), this.addEventListener("track", this._onaddstreampoly = function(e) {
                                var t = e.streams[0];
                                if (this._remoteStreams || (this._remoteStreams = []), !(this._remoteStreams.indexOf(t) >= 0)) {
                                    this._remoteStreams.push(t);
                                    var n = new Event("addstream");
                                    n.stream = e.streams[0], this.dispatchEvent(n)
                                }
                            }.bind(this))
                        }
                    }))
                },
                shimCallbacksAPI: function(e) {
                    if ("object" === r(e) && e.RTCPeerConnection) {
                        var t = e.RTCPeerConnection.prototype,
                            n = t.createOffer,
                            i = t.createAnswer,
                            o = t.setLocalDescription,
                            a = t.setRemoteDescription,
                            s = t.addIceCandidate;
                        t.createOffer = function(e, t) {
                            var r = arguments.length >= 2 ? arguments[2] : arguments[0],
                                i = n.apply(this, [r]);
                            return t ? (i.then(e, t), Promise.resolve()) : i
                        }, t.createAnswer = function(e, t) {
                            var n = arguments.length >= 2 ? arguments[2] : arguments[0],
                                r = i.apply(this, [n]);
                            return t ? (r.then(e, t), Promise.resolve()) : r
                        };
                        var c = function(e, t, n) {
                            var r = o.apply(this, [e]);
                            return n ? (r.then(t, n), Promise.resolve()) : r
                        };
                        t.setLocalDescription = c, c = function(e, t, n) {
                            var r = a.apply(this, [e]);
                            return n ? (r.then(t, n), Promise.resolve()) : r
                        }, t.setRemoteDescription = c, c = function(e, t, n) {
                            var r = s.apply(this, [e]);
                            return n ? (r.then(t, n), Promise.resolve()) : r
                        }, t.addIceCandidate = c
                    }
                },
                shimGetUserMedia: function(e) {
                    var t = e && e.navigator;
                    t.getUserMedia || (t.webkitGetUserMedia ? t.getUserMedia = t.webkitGetUserMedia.bind(t) : t.mediaDevices && t.mediaDevices.getUserMedia && (t.getUserMedia = function(e, n, r) {
                        t.mediaDevices.getUserMedia(e).then(n, r)
                    }.bind(t)))
                },
                shimRTCIceServerUrls: function(e) {
                    var t = e.RTCPeerConnection;
                    e.RTCPeerConnection = function(e, n) {
                        if (e && e.iceServers) {
                            for (var r = [], o = 0; o < e.iceServers.length; o++) {
                                var a = e.iceServers[o];
                                !a.hasOwnProperty("urls") && a.hasOwnProperty("url") ? (i.deprecated("RTCIceServer.url", "RTCIceServer.urls"), (a = JSON.parse(JSON.stringify(a))).urls = a.url, delete a.url, r.push(a)) : r.push(e.iceServers[o])
                            }
                            e.iceServers = r
                        }
                        return new t(e, n)
                    }, e.RTCPeerConnection.prototype = t.prototype, "generateCertificate" in e.RTCPeerConnection && Object.defineProperty(e.RTCPeerConnection, "generateCertificate", {
                        get: function() {
                            return t.generateCertificate
                        }
                    })
                },
                shimTrackEventTransceiver: function(e) {
                    "object" === r(e) && e.RTCPeerConnection && "receiver" in e.RTCTrackEvent.prototype && !e.RTCTransceiver && Object.defineProperty(e.RTCTrackEvent.prototype, "transceiver", {
                        get: function() {
                            return {
                                receiver: this.receiver
                            }
                        }
                    })
                },
                shimCreateOfferLegacy: function(e) {
                    var t = e.RTCPeerConnection.prototype.createOffer;
                    e.RTCPeerConnection.prototype.createOffer = function(e) {
                        var n = this;
                        if (e) {
                            var r = n.getTransceivers().find((function(e) {
                                return e.sender.track && "audio" === e.sender.track.kind
                            }));
                            !1 === e.offerToReceiveAudio && r ? "sendrecv" === r.direction ? r.setDirection("sendonly") : "recvonly" === r.direction && r.setDirection("inactive") : !0 !== e.offerToReceiveAudio || r || n.addTransceiver("audio");
                            var i = n.getTransceivers().find((function(e) {
                                return e.sender.track && "video" === e.sender.track.kind
                            }));
                            !1 === e.offerToReceiveVideo && i ? "sendrecv" === i.direction ? i.setDirection("sendonly") : "recvonly" === i.direction && i.setDirection("inactive") : !0 !== e.offerToReceiveVideo || i || n.addTransceiver("video")
                        }
                        return t.apply(n, arguments)
                    }
                }
            };
        e.exports = {
            shimCallbacksAPI: o.shimCallbacksAPI,
            shimLocalStreamsAPI: o.shimLocalStreamsAPI,
            shimRemoteStreamsAPI: o.shimRemoteStreamsAPI,
            shimGetUserMedia: o.shimGetUserMedia,
            shimRTCIceServerUrls: o.shimRTCIceServerUrls,
            shimTrackEventTransceiver: o.shimTrackEventTransceiver,
            shimCreateOfferLegacy: o.shimCreateOfferLegacy
        }
    }, function(e, t, n) {
        "use strict";

        function r(e) {
            return (r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                return typeof e
            } : function(e) {
                return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
            })(e)
        }
        var i = n(62),
            o = n(38);
        e.exports = {
            shimRTCIceCandidate: function(e) {
                if (!(e.RTCIceCandidate && "foundation" in e.RTCIceCandidate.prototype)) {
                    var t = e.RTCIceCandidate;
                    e.RTCIceCandidate = function(e) {
                            "object" === r(e) && e.candidate && 0 === e.candidate.indexOf("a=") && ((e = JSON.parse(JSON.stringify(e))).candidate = e.candidate.substr(2));
                            var n = new t(e),
                                o = i.parseCandidate(e.candidate),
                                a = Object.assign(n, o);
                            return a.toJSON = function() {
                                return {
                                    candidate: a.candidate,
                                    sdpMid: a.sdpMid,
                                    sdpMLineIndex: a.sdpMLineIndex,
                                    usernameFragment: a.usernameFragment
                                }
                            }, a
                        },
                        function(e, t, n) {
                            if (e.RTCPeerConnection) {
                                var r = e.RTCPeerConnection.prototype,
                                    i = r.addEventListener;
                                r.addEventListener = function(e, r) {
                                    if (e !== t) return i.apply(this, arguments);
                                    var o = function(e) {
                                        r(n(e))
                                    };
                                    return this._eventMap = this._eventMap || {}, this._eventMap[r] = o, i.apply(this, [e, o])
                                };
                                var o = r.removeEventListener;
                                r.removeEventListener = function(e, n) {
                                    if (e !== t || !this._eventMap || !this._eventMap[n]) return o.apply(this, arguments);
                                    var r = this._eventMap[n];
                                    return delete this._eventMap[n], o.apply(this, [e, r])
                                }, Object.defineProperty(r, "on" + t, {
                                    get: function() {
                                        return this["_on" + t]
                                    },
                                    set: function(e) {
                                        this["_on" + t] && (this.removeEventListener(t, this["_on" + t]), delete this["_on" + t]), e && this.addEventListener(t, this["_on" + t] = e)
                                    }
                                })
                            }
                        }(e, "icecandidate", (function(t) {
                            return t.candidate && Object.defineProperty(t, "candidate", {
                                value: new e.RTCIceCandidate(t.candidate),
                                writable: "false"
                            }), t
                        }))
                }
            },
            shimCreateObjectURL: function(e) {
                var t = e && e.URL;
                if ("object" === r(e) && e.HTMLMediaElement && "srcObject" in e.HTMLMediaElement.prototype && t.createObjectURL && t.revokeObjectURL) {
                    var n = t.createObjectURL.bind(t),
                        i = t.revokeObjectURL.bind(t),
                        a = new Map,
                        s = 0;
                    t.createObjectURL = function(e) {
                        if ("getTracks" in e) {
                            var t = "polyblob:" + ++s;
                            return a.set(t, e), o.deprecated("URL.createObjectURL(stream)", "elem.srcObject = stream"), t
                        }
                        return n(e)
                    }, t.revokeObjectURL = function(e) {
                        i(e), a.delete(e)
                    };
                    var c = Object.getOwnPropertyDescriptor(e.HTMLMediaElement.prototype, "src");
                    Object.defineProperty(e.HTMLMediaElement.prototype, "src", {
                        get: function() {
                            return c.get.apply(this)
                        },
                        set: function(e) {
                            return this.srcObject = a.get(e) || null, c.set.apply(this, [e])
                        }
                    });
                    var u = e.HTMLMediaElement.prototype.setAttribute;
                    e.HTMLMediaElement.prototype.setAttribute = function() {
                        return 2 === arguments.length && "src" === ("" + arguments[0]).toLowerCase() && (this.srcObject = a.get(arguments[1]) || null), u.apply(this, arguments)
                    }
                }
            }
        }
    }, function(e, t, n) {
        var r = function(e) {
                return String(Number(e)) === e ? Number(e) : e
            },
            i = function(e, t, n) {
                var i = e.name && e.names;
                e.push && !t[e.push] ? t[e.push] = [] : i && !t[e.name] && (t[e.name] = {});
                var o = e.push ? {} : i ? t[e.name] : t;
                ! function(e, t, n, i) {
                    if (i && !n) t[i] = r(e[1]);
                    else
                        for (var o = 0; o < n.length; o += 1) null != e[o + 1] && (t[n[o]] = r(e[o + 1]))
                }(n.match(e.reg), o, e.names, e.name), e.push && t[e.push].push(o)
            },
            o = n(63),
            a = RegExp.prototype.test.bind(/^([a-z])=(.*)/);
        t.parse = function(e) {
            var t = {},
                n = [],
                r = t;
            return e.split(/(\r\n|\r|\n)/).filter(a).forEach((function(e) {
                var t = e[0],
                    a = e.slice(2);
                "m" === t && (n.push({
                    rtp: [],
                    fmtp: []
                }), r = n[n.length - 1]);
                for (var s = 0; s < (o[t] || []).length; s += 1) {
                    var c = o[t][s];
                    if (c.reg.test(a)) return i(c, r, a)
                }
            })), t.media = n, t
        };
        var s = function(e, t) {
            var n = t.split(/=(.+)/, 2);
            return 2 === n.length && (e[n[0]] = r(n[1])), e
        };
        t.parseParams = function(e) {
            return e.split(/\;\s?/).reduce(s, {})
        }, t.parseFmtpConfig = t.parseParams, t.parsePayloads = function(e) {
            return e.split(" ").map(Number)
        }, t.parseRemoteCandidates = function(e) {
            for (var t = [], n = e.split(" ").map(r), i = 0; i < n.length; i += 3) t.push({
                component: n[i],
                ip: n[i + 1],
                port: n[i + 2]
            });
            return t
        }, t.parseImageAttributes = function(e) {
            return e.split(" ").map((function(e) {
                return e.substring(1, e.length - 1).split(",").reduce(s, {})
            }))
        }, t.parseSimulcastStreamList = function(e) {
            return e.split(";").map((function(e) {
                return e.split(",").map((function(e) {
                    var t, n = !1;
                    return "~" !== e[0] ? t = r(e) : (t = r(e.substring(1, e.length)), n = !0), {
                        scid: t,
                        paused: n
                    }
                }))
            }))
        }
    }, function(e, t, n) {
        var r = n(63),
            i = /%[sdv%]/g,
            o = function(e) {
                var t = 1,
                    n = arguments,
                    r = n.length;
                return e.replace(i, (function(e) {
                    if (t >= r) return e;
                    var i = n[t];
                    switch (t += 1, e) {
                        case "%%":
                            return "%";
                        case "%s":
                            return String(i);
                        case "%d":
                            return Number(i);
                        case "%v":
                            return ""
                    }
                }))
            },
            a = function(e, t, n) {
                var r = [e + "=" + (t.format instanceof Function ? t.format(t.push ? n : n[t.name]) : t.format)];
                if (t.names)
                    for (var i = 0; i < t.names.length; i += 1) {
                        var a = t.names[i];
                        t.name ? r.push(n[t.name][a]) : r.push(n[t.names[i]])
                    } else r.push(n[t.name]);
                return o.apply(null, r)
            },
            s = ["v", "o", "s", "i", "u", "e", "p", "c", "b", "t", "r", "z", "a"],
            c = ["i", "c", "b", "a"];
        e.exports = function(e, t) {
            t = t || {}, null == e.version && (e.version = 0), null == e.name && (e.name = " "), e.media.forEach((function(e) {
                null == e.payloads && (e.payloads = "")
            }));
            var n = t.outerOrder || s,
                i = t.innerOrder || c,
                o = [];
            return n.forEach((function(t) {
                r[t].forEach((function(n) {
                    n.name in e && null != e[n.name] ? o.push(a(t, n, e)) : n.push in e && null != e[n.push] && e[n.push].forEach((function(e) {
                        o.push(a(t, n, e))
                    }))
                }))
            })), e.media.forEach((function(e) {
                o.push(a("m", r.m[0], e)), i.forEach((function(t) {
                    r[t].forEach((function(n) {
                        n.name in e && null != e[n.name] ? o.push(a(t, n, e)) : n.push in e && null != e[n.push] && e[n.push].forEach((function(e) {
                            o.push(a(t, n, e))
                        }))
                    }))
                }))
            })), o.join("\r\n") + "\r\n"
        }
    }, function(e, t, n) {
        t.Interop = n(142)
    }, function(e, t, n) {
        "use strict";

        function r(e) {
            return (r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                return typeof e
            } : function(e) {
                return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
            })(e)
        }
        var i = n(143),
            o = n(144);

        function a(e) {
            "number" == typeof e.mid && (e.mid = e.mid.toString())
        }

        function s() {
            this.cache = {
                mlB2UMap: {},
                mlU2BMap: {}
            }
        }
        e.exports = s, s.prototype.candidateToUnifiedPlan = function(e) {
            var t = new RTCIceCandidate(e);
            return t.sdpMLineIndex = this.cache.mlB2UMap[t.sdpMLineIndex], t
        }, s.prototype.candidateToPlanB = function(e) {
            var t = new RTCIceCandidate(e);
            if (0 === t.sdpMid.indexOf("audio")) t.sdpMid = "audio";
            else {
                if (0 !== t.sdpMid.indexOf("video")) throw new Error("candidate with " + t.sdpMid + " not allowed");
                t.sdpMid = "video"
            }
            return t.sdpMLineIndex = this.cache.mlU2BMap[t.sdpMLineIndex], t
        }, s.prototype.getFirstSendingIndexFromAnswer = function(e) {
            if (!this.cache.answer) return null;
            var t = i.parse(this.cache.answer);
            if (t && t.media && Array.isArray(t.media))
                for (var n = 0; n < t.media.length; n++)
                    if (t.media[n].type == e && (!t.media[n].direction || "sendrecv" === t.media[n].direction || "sendonly" === t.media[n].direction)) return n;
            return null
        }, s.prototype.toPlanB = function(e) {
            var t = this;
            if ("object" !== r(e) || null === e || "string" != typeof e.sdp) return console.warn("An empty description was passed as an argument."), e;
            var n = i.parse(e.sdp);
            if (void 0 === n.media || !Array.isArray(n.media) || 0 === n.media.length) return console.warn("The description has no media."), e;
            if (n.media.length <= 3 && n.media.every((function(e) {
                    return -1 !== ["video", "audio", "data"].indexOf(e.mid)
                }))) return console.warn("This description does not look like Unified Plan."), e;
            for (var s = e.sdp, u = !1, l = 0; l < n.media.length; l++) {
                n.media[l].rtp.forEach((function(e) {
                    if ("NULL" === e.codec) {
                        u = !0;
                        var n = i.parse(t.cache.offer);
                        e.codec = n.media[l].rtp[0].codec
                    }
                }))
            }
            u && (s = i.write(n)), this.cache[e.type] = s;
            var d = n.media;
            n.media = [];
            var p = {},
                h = [],
                f = {};
            d.forEach((function(e) {
                if (a(e), ("string" != typeof e.rtcpMux || "rtcp-mux" !== e.rtcpMux) && "inactive" !== e.direction && "application" !== e.type) throw new Error("Cannot convert to Plan B because m-lines without the rtcp-mux attribute were found.");
                void 0 !== p[e.type] && "inactive" !== p[e.type].direction || (p[e.type] = e)
            })), d.forEach((function(e) {
                var t = e.type;
                if ("application" === t) return e.mid = "data", n.media.push(e), void h.push(e.mid);
                "object" === r(e.sources) && Object.keys(e.sources).forEach((function(n) {
                    "object" !== r(p[t].sources) && (p[t].sources = {}), p[t].sources[n] = e.sources[n], void 0 !== e.msid && (p[t].sources[n].msid = e.msid)
                })), void 0 !== e.ssrcGroups && Array.isArray(e.ssrcGroups) && (void 0 !== p[t].ssrcGroups && Array.isArray(p[t].ssrcGroups) || (p[t].ssrcGroups = []), o.apply(p[t].ssrcGroups, [e.ssrcGroups]) || (p[t].ssrcGroups = p[t].ssrcGroups.concat(e.ssrcGroups)));
                var i = e.direction;
                f[t] = (f[t] || 0) | c[i || "inactive"], p[t] === e && (e.mid = t, delete e.bundleOnly, delete e.msid, "inactive" !== i && h.push(t), n.media.push(e))
            })), n.groups.some((function(e) {
                if ("BUNDLE" === e.type) return e.mids = h.join(" "), !0
            })), n.msidSemantic = {
                semantic: "WMS",
                token: "*"
            };
            var m = i.write(n);
            return new RTCSessionDescription({
                type: e.type,
                sdp: m
            })
        }, s.prototype.toUnifiedPlan = function(e) {
            var t = this;
            if ("object" !== r(e) || null === e || "string" != typeof e.sdp) return console.warn("An empty description was passed as an argument."), e;
            var n = i.parse(e.sdp);
            if (void 0 === n.media || !Array.isArray(n.media) || 0 === n.media.length) return console.warn("The description has no media."), e;
            if (n.media.length > 3 || !n.media.every((function(e) {
                    return -1 !== ["video", "audio", "data"].indexOf(e.mid)
                }))) return console.warn("This description does not look like Plan B."), e;
            var s = [];
            n.media.forEach((function(e) {
                s.push(e.mid)
            }));
            var c, u = !1;
            if (void 0 !== n.groups && Array.isArray(n.groups) && (u = n.groups.every((function(e) {
                    return "BUNDLE" !== e.type || o.apply(e.mids.sort(), [s.sort()])
                }))), !u) throw new Error("Cannot convert to Unified Plan because m-lines that are not bundled were found.");
            void 0 !== this.cache[e.type] && (c = i.parse(this.cache[e.type]));
            var l = {
                    audio: {},
                    video: {}
                },
                d = {},
                p = 0,
                h = 0;
            if (n.media.forEach((function(n) {
                    if (("string" != typeof n.rtcpMux || "rtcp-mux" !== n.rtcpMux) && "inactive" !== n.direction && "application" !== n.type) throw new Error("Cannot convert to Unified Plan because m-lines without the rtcp-mux attribute were found.");
                    if ("application" === n.type) {
                        var i = null;
                        return c && c.media && (i = c.media.find((function(e) {
                            return "application" === e.type
                        }))), void(i ? d[i.mid] = i : d[n.mid] = n)
                    }
                    var o = n.sources,
                        s = n.ssrcGroups,
                        u = n.candidates,
                        f = n.iceUfrag,
                        m = n.icePwd,
                        v = n.fingerprint,
                        y = n.port;
                    delete n.sources, delete n.ssrcGroups, delete n.candidates, delete n.iceUfrag, delete n.icePwd, delete n.fingerprint, delete n.port, delete n.mid;
                    var g = {};
                    void 0 !== s && Array.isArray(s) && s.forEach((function(e) {
                        "SIM" !== e.semantics && void 0 !== e.ssrcs && Array.isArray(e.ssrcs) && e.ssrcs.forEach((function(t) {
                            void 0 === g[t] && (g[t] = []), g[t].push(e)
                        }))
                    }));
                    var _ = {};
                    "object" === r(o) && Object.keys(o).forEach((function(i) {
                        var s;
                        if ("offer" !== e.type || o[i].msid)
                            if (void 0 !== g[i] && Array.isArray(g[i]) && g[i].some((function(e) {
                                    return e.ssrcs.some((function(e) {
                                        if ("object" === r(_[e])) return s = _[e], !0
                                    }))
                                })), "object" === r(s)) s.sources[i] = o[i], delete o[i].msid;
                            else {
                                if (s = Object.create(n), _[i] = s, void 0 !== o[i].msid && (s.msid = o[i].msid, delete o[i].msid), s.sources = {}, s.sources[i] = o[i], s.ssrcGroups = g[i], void 0 !== c && void 0 !== c.media && Array.isArray(c.media) && c.media.forEach((function(e) {
                                        "object" === r(e.sources) && Object.keys(e.sources).forEach((function(t) {
                                            t === i && (s.mid = e.mid)
                                        }))
                                    })), a(s), void 0 === s.mid) {
                                    if ("answer" === e.type) throw new Error("An unmapped SSRC was found.");
                                    s.mid = [n.type, "-", i].join("")
                                }
                                s.candidates = u, s.iceUfrag = f, s.icePwd = m, s.fingerprint = v, s.port = y, d[s.mid] = s, t.cache.mlU2BMap[h] = p, void 0 === t.cache.mlB2UMap[p] && (t.cache.mlB2UMap[p] = h), h++
                            }
                        else l[n.type][i] = o[i]
                    })), p++
                })), n.media = [], s = [], "answer" === e.type)
                for (var f = 0; f < c.media.length; f++) {
                    var m = c.media[f];
                    a(m), void 0 === d[m.mid] && (delete m.msid, delete m.sources, delete m.ssrcGroups, m.direction && "sendrecv" !== m.direction ? "sendonly" === m.direction && (m.direction = "inactive") : m.direction = "recvonly"), n.media.push(m), "string" == typeof m.mid && s.push(m.mid)
                } else void 0 !== c && void 0 !== c.media && Array.isArray(c.media) && c.media.forEach((function(e) {
                    a(e), s.push(e.mid), void 0 !== d[e.mid] ? n.media.push(d[e.mid]) : (delete e.msid, delete e.sources, delete e.ssrcGroups, e.direction && "sendrecv" !== e.direction || (e.direction = "recvonly"), e.direction && "sendonly" !== e.direction || (e.direction = "inactive"), n.media.push(e))
                })), Object.keys(d).forEach((function(e) {
                    -1 === s.indexOf(e) && (s.push(e), "recvonly" === d[e].direction ? n.media.some((function(t) {
                        if (("sendrecv" === t.direction || "sendonly" === t.direction) && t.type === d[e].type) return Object.keys(d[e].sources).forEach((function(n) {
                            t.sources[n] = d[e].sources[n]
                        })), !0
                    })) : n.media.push(d[e]))
                }));
            ["audio", "video"].forEach((function(e) {
                if (n && n.media && Array.isArray(n.media)) {
                    var r = null;
                    if (Object.keys(l[e]).length > 0 && null === (r = t.getFirstSendingIndexFromAnswer(e)))
                        for (var i = 0; i < n.media.length; i++)
                            if (n.media[i].type === e) {
                                r = i;
                                break
                            } if (r && n.media.length > r) {
                        var o = n.media[r];
                        Object.keys(l[e]).forEach((function(t) {
                            o.sources && o.sources[t] && console.warn("Replacing an existing SSRC."), o.sources || (o.sources = {}), o.sources[t] = l[e][t]
                        }))
                    }
                }
            })), n.groups.some((function(e) {
                if ("BUNDLE" === e.type) return e.mids = s.join(" "), !0
            })), n.msidSemantic = {
                semantic: "WMS",
                token: "*"
            };
            var v = i.write(n);
            return this.cache[e.type] = v, new RTCSessionDescription({
                type: e.type,
                sdp: v
            })
        };
        var c = {
            inactive: 0,
            recvonly: 1,
            sendonly: 2,
            sendrecv: 3
        }
    }, function(e, t, n) {
        var r = n(22);
        t.write = function(e, t) {
            return void 0 !== e && void 0 !== e.media && Array.isArray(e.media) && e.media.forEach((function(e) {
                void 0 !== e.sources && 0 !== Object.keys(e.sources).length && (e.ssrcs = [], Object.keys(e.sources).forEach((function(t) {
                    var n = e.sources[t];
                    Object.keys(n).forEach((function(r) {
                        e.ssrcs.push({
                            id: t,
                            attribute: r,
                            value: n[r]
                        })
                    }))
                })), delete e.sources), void 0 !== e.ssrcGroups && Array.isArray(e.ssrcGroups) && e.ssrcGroups.forEach((function(e) {
                    void 0 !== e.ssrcs && Array.isArray(e.ssrcs) && (e.ssrcs = e.ssrcs.join(" "))
                }))
            })), void 0 !== e && void 0 !== e.groups && Array.isArray(e.groups) && e.groups.forEach((function(e) {
                void 0 !== e.mids && Array.isArray(e.mids) && (e.mids = e.mids.join(" "))
            })), r.write(e, t)
        }, t.parse = function(e) {
            var t = r.parse(e);
            return void 0 !== t && void 0 !== t.media && Array.isArray(t.media) && t.media.forEach((function(e) {
                void 0 !== e.ssrcs && Array.isArray(e.ssrcs) && (e.sources = {}, e.ssrcs.forEach((function(t) {
                    e.sources[t.id] || (e.sources[t.id] = {}), e.sources[t.id][t.attribute] = t.value
                })), delete e.ssrcs), void 0 !== e.ssrcGroups && Array.isArray(e.ssrcGroups) && e.ssrcGroups.forEach((function(e) {
                    "string" == typeof e.ssrcs && (e.ssrcs = e.ssrcs.split(" "))
                }))
            })), void 0 !== t && void 0 !== t.groups && Array.isArray(t.groups) && t.groups.forEach((function(e) {
                "string" == typeof e.mids && (e.mids = e.mids.split(" "))
            })), t
        }
    }, function(e, t) {
        e.exports = function e(t) {
            if (!t) return !1;
            if (this.length != t.length) return !1;
            for (var n = 0, r = this.length; n < r; n++)
                if (this[n] instanceof Array && t[n] instanceof Array) {
                    if (!e.apply(this[n], [t[n]])) return !1
                } else if (this[n] != t[n]) return !1;
            return !0
        }
    }, function(e, t, n) {
        var r = n(22),
            i = n(146),
            o = i.parseSsrcs,
            a = i.writeSsrcs,
            s = 3;

        function c(e, t, n) {
            return e.ssrcs.filter((function(e) {
                return e.id === t
            })).filter((function(e) {
                return e.attribute === n
            })).map((function(e) {
                return e.value
            }))[0]
        }

        function u(e) {
            this.options = e || {}, this.options.numOfLayers || (this.options.numOfLayers = s), console.debug("SdpSimulcast: using " + this.options.numOfLayers + " layers"), this.ssrcCache = []
        }

        function l(e, t) {
            null != e && Array.isArray(e.media) && e.media.forEach((function(e) {
                "video" === e.type && t(e)
            }))
        }

        function d(e) {
            return e && null != e && e.type && "" != e.type && e.sdp && "" != e.sdp
        }
        u.prototype.clearSsrcCache = function() {
            this.ssrcCache = []
        }, u.prototype.setSsrcCache = function(e) {
            this.ssrcCache = e
        }, u.prototype._parseSimLayers = function(e) {
            var t = e.ssrcGroups && e.ssrcGroups.find((function(e) {
                return "SIM" === e.semantics
            }));
            return t ? t.ssrcs.split(" ").map((function(e) {
                return parseInt(e)
            })) : [e.ssrcs[0].id]
        }, u.prototype._buildNewToOldSsrcMap = function(e, t) {
            for (var n = {}, r = 0; r < e.length; ++r) {
                var i = e[r],
                    o = t[r] || null;
                n[i] = o
            }
            return n
        }, u.prototype._fillInSourceDataFromCache = function(e) {
            console.debug("SdpSimulcast restoring from cache: ", this.ssrcCache);
            var t = this._parseSimLayers(e);
            console.debug("SdpSimulcast Parsed new sim ssrcs: ", t);
            var n = c(e, t[0], "msid"),
                r = c(e, t[0], "cname"),
                i = this._buildNewToOldSsrcMap(t, this.ssrcCache);
            console.debug("SdpSimulcast built replacement map: ", i);
            var o = this.ssrcCache.filter((function(e) {
                return -1 === Object.values(i).indexOf(e)
            }));
            return console.debug("SdpSimulcast built ssrcs to add: ", o), e.ssrcs.forEach((function(e) {
                i[e.id] && (e.id = i[e.id])
            })), o.forEach((function(t) {
                e.ssrcs.push({
                    id: t,
                    attribute: "msid",
                    value: n
                }), e.ssrcs.push({
                    id: t,
                    attribute: "cname",
                    value: r
                })
            })), e.ssrcGroups = e.ssrcGroups || [], e.ssrcGroups.push({
                semantics: "SIM",
                ssrcs: this.ssrcCache.join(" ")
            }), e
        }, u.prototype._generateSourceData = function(e, t) {
            for (var n = function(e, t) {
                    e.ssrcs.push({
                        id: t,
                        attribute: "cname",
                        value: i
                    }), e.ssrcs.push({
                        id: t,
                        attribute: "msid",
                        value: r
                    })
                }, r = c(e, t, "msid"), i = c(e, t, "cname"), o = [], a = 0; a < this.options.numOfLayers - 1; ++a) {
                var s = Math.floor(4294967295 * Math.random()) + 0;
                n(e, s), o.push(s)
            }
            return e.ssrcGroups = e.ssrcGroups || [], e.ssrcGroups.push({
                semantics: "SIM",
                ssrcs: t + " " + o.join(" ")
            }), e
        }, u.prototype._restoreSimulcast = function(e) {
            var t, n = e.ssrcs && e.ssrcs.map((function(e) {
                    return e.id
                })).filter((function(e, t, n) {
                    return n.indexOf(e) === t
                })).length || 0,
                r = e.ssrcGroups && e.ssrcGroups.length || 0;
            if (0 === n || n > 2) return e;
            if (2 == n && 0 === r) return e;
            if (1 === n) t = e.ssrcs[0].id;
            else {
                var i = e.ssrcGroups.filter((function(e) {
                    return "FID" === e.semantics
                }))[0];
                if (!i) return e;
                t = parseInt(i.ssrcs.split(" ")[0])
            }
            return console.debug("SdpSimulcast: current ssrc cache: ", this.ssrcCache), console.debug("SdpSimulcast: parsed primary ssrc " + t), -1 !== this.ssrcCache.indexOf(t) ? (console.debug("SdpSimulcast: Have seen primary ssrc before, filling in data from cache"), e = this._fillInSourceDataFromCache(e)) : (console.debug("SdpSimulcast: Have not seen primary ssrc before, generating source data"), e = this._generateSourceData(e, t)), this.ssrcCache = this._parseSimLayers(e), e
        }, u.prototype.mungeRemoteDescription = function(e) {
            if (!d(e)) return e;
            var t = r.parse(e.sdp),
                n = this;
            return l(t, (function(e) {
                n.options.explodeRemoteSimulcast ? function(e) {
                        if (e && Array.isArray(e.ssrcGroups))
                            for (var t = o(e), n = [], r = e.ssrcGroups.length; r--;)
                                if ("SIM" === e.ssrcGroups[r].semantics) {
                                    for (var i = e.ssrcGroups[r].ssrcs.split(" "), s = 0; s < i.length; s++) {
                                        var c = i[s];
                                        n.push(c);
                                        var u = t[c].msid.split(" ");
                                        t[c].msid = [u[0], "/", s, " ", u[1], "/", s].join(""), t[c].cname = [t[c].cname, "/", s].join(""), e.ssrcGroups.forEach((function(e) {
                                            if ("SIM" !== e.semantics) {
                                                var r = e.ssrcs.split(" "); - 1 !== r.indexOf(c) && r.forEach((function(e) {
                                                    t[e].msid = t[c].msid, t[e].cname = t[c].cname, e !== c && n.push(e)
                                                }))
                                            }
                                        }))
                                    }
                                    e.ssrcs = a(t, n), e.ssrcGroups.splice(r, 1)
                                }
                    }(e) : function(e) {
                        if (e && Array.isArray(e.ssrcGroups)) {
                            var t = o(e);
                            e.ssrcGroups.forEach((function(n) {
                                if ("SIM" === n.semantics) {
                                    console.info("Imploding SIM group: " + n.ssrcs), n.nuke = !0;
                                    for (var r = n.ssrcs.split(" "), i = 1; i < r.length; i++) {
                                        var o = r[i];
                                        delete t[o], e.ssrcGroups.forEach((function(e) {
                                            if ("SIM" !== e.semantics) {
                                                var n = e.ssrcs.split(" "); - 1 !== n.indexOf(o) && (n.forEach((function(e) {
                                                    delete t[e]
                                                })), e.nuke = !0)
                                            }
                                        }))
                                    }
                                }
                            })), e.ssrcs = a(t);
                            for (var n = e.ssrcGroups.length; n--;) e.ssrcGroups[n].nuke && e.ssrcGroups.splice(n, 1)
                        } else console.info("Halt: There are no SSRC groups in the remote description.")
                    }(e),
                    function(e) {
                        e && (Array.isArray(e.invalid) || (e.invalid = []), e.invalid.some((function(e) {
                            return "x-google-flag:conference" === e.value
                        })) || e.invalid.push({
                            value: "x-google-flag:conference"
                        }))
                    }(e)
            })), new RTCSessionDescription({
                type: e.type,
                sdp: r.write(t)
            })
        }, u.prototype.mungeLocalDescription = function(e) {
            if (!d(e)) return e;
            var t = r.parse(e.sdp),
                n = this;
            return l(t, (function(e) {
                "recvonly" != e.direction && "inactive" != e.direction && n._restoreSimulcast(e)
            })), new RTCSessionDescription({
                type: e.type,
                sdp: r.write(t)
            })
        }, e.exports = u
    }, function(e, t) {
        t.writeSsrcs = function(e, t) {
            var n = [];
            if (void 0 !== e && 0 !== Object.keys(e).length) {
                Array.isArray(t) || (t = []);
                for (var r = 0; r < t.length; r++) {
                    var i = t[r],
                        o = e[i];
                    Object.keys(o).forEach((function(e) {
                        n.push({
                            id: i,
                            attribute: e,
                            value: o[e]
                        })
                    }))
                }
                Object.keys(e).forEach((function(r) {
                    if (r = parseInt(r), !(t.indexOf(r) >= 0)) {
                        var i = e[r];
                        Object.keys(i).forEach((function(e) {
                            n.push({
                                id: r,
                                attribute: e,
                                value: i[e]
                            })
                        }))
                    }
                }))
            }
            return n
        }, t.parseSsrcs = function(e) {
            var t = {};
            return void 0 !== e.ssrcs && Array.isArray(e.ssrcs) && e.ssrcs.forEach((function(e) {
                t[e.id] || (t[e.id] = {}), t[e.id][e.attribute] = e.value
            })), t
        }
    }, function(e, t) {
        e.exports = function(e, t, n, r) {
            this.blob = e, this.name = t, this.startTime = n, this.wordArray = r
        }
    }, function(e, t, n) {
        var r = n(149),
            i = n(150),
            o = n(64),
            a = function() {
                this.url = function() {
                    var e = "config does not contain an url to a Sphinx4 https server";
                    if (void 0 === config.sphinxURL) console.debug(e);
                    else {
                        var t = config.sphinxURL;
                        if (void 0 !== t.includes && t.includes("https://")) return t;
                        console.debug(e)
                    }
                }()
            };
        a.prototype = Object.create(r.prototype), a.constructor = a, a.prototype.sendRequest = function(e, t) {
            console.debug("sending an audio file  to ".concat(this.url)), console.debug("the audio file being sent: ".concat(e));
            var n = new XMLHttpRequest;
            n.onreadystatechange = function() {
                if (n.readyState === XMLHttpRequest.DONE && 200 === n.status) t(n.responseText);
                else if (n.readyState === XMLHttpRequest.DONE) throw new Error("unable to accept response from sphinx server. status: ".concat(n.status))
            }, n.open("POST", this.url), n.setRequestHeader("Content-Type", o.determineCorrectFileType()), n.send(e), console.debug("send ".concat(e))
        }, a.prototype.formatResponse = function(e) {
            var t = JSON.parse(e).objects;
            t.shift();
            var n = [];
            return t.forEach((function(e) {
                return e.filler || n.push(new i(e.word, e.start, e.end))
            })), n
        }, a.prototype.verify = function(e) {
            if (console.debug("response from server:".concat(e.toString())), "string" != typeof e) return !1;
            var t;
            try {
                t = JSON.parse(e)
            } catch (e) {
                return console.debug(e), !1
            }
            if (void 0 === t.objects) return !1;
            var n = t.objects;
            return !(!n[0] || !n[0]["session-id"])
        }, e.exports = a
    }, function(e, t) {
        var n = function() {
            throw new Error("TranscriptionService is abstract and cannot becreated")
        };
        n.prototype.send = function(e, t) {
            var n = this;
            this.sendRequest(e.blob, (function(r) {
                n.verify(r) ? e.wordArray = n.formatResponse(r) : (console.debug("the retrieved response from the server is not valid!"), e.wordArray = []), t(e)
            }))
        }, n.prototype.sendRequest = function(e, t) {
            throw new Error("TranscriptionService.sendRequest is abstract")
        }, n.prototype.formatResponse = function(e) {
            throw new Error("TranscriptionService.format is abstract")
        }, n.prototype.verify = function(e) {
            throw new Error("TranscriptionService.verify is abstract")
        }, e.exports = n
    }, function(e, t) {
        var n = function(e, t, n) {
            this.word = e, this.begin = t, this.end = n
        };
        n.prototype.getWord = function() {
            return this.word
        }, n.prototype.getBeginTime = function() {
            return this.begin
        }, n.prototype.getEndTime = function() {
            return this.end
        }, e.exports = n
    }])
}));