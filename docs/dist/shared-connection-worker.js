let manager,Status={ERROR:0,CONNECTING:1,CONNFAIL:2,AUTHENTICATING:3,AUTHFAIL:4,CONNECTED:5,DISCONNECTED:6,DISCONNECTING:7,ATTACHED:8,REDIRECT:9,CONNTIMEOUT:10,BINDREQUIRED:11,ATTACHFAIL:12};class ConnectionManager{constructor(){this.ports=[]}addPort(s){this.ports.push(s),s.addEventListener("message",s=>{let t=s.data[0];try{this[t](s.data.splice(1))}catch(s){console?.error(s)}}),s.start()}_connect(s){this.jid=s[1],this._closeSocket(),this.socket=new WebSocket(s[0],"xmpp"),this.socket.onopen=()=>this._onOpen(),this.socket.onerror=s=>this._onError(s),this.socket.onclose=s=>this._onClose(s),this.socket.onmessage=s=>this._onMessage(s)}_attach(){this.socket&&this.socket.readyState!==WebSocket.CLOSED?this.ports.forEach(s=>s.postMessage(["_attachCallback",Status.ATTACHED,this.jid])):this.ports.forEach(s=>s.postMessage(["_attachCallback",Status.ATTACHFAIL]))}send(s){this.socket.send(s)}close(s){if(this.socket&&this.socket.readyState!==WebSocket.CLOSED)try{this.socket.send(s)}catch(s){this.ports.forEach(t=>t.postMessage(["log","error",s])),this.ports.forEach(s=>s.postMessage(["log","error","Couldn't send <close /> tag."]))}}_onOpen(){this.ports.forEach(s=>s.postMessage(["_onOpen"]))}_onClose(s){this.ports.forEach(t=>t.postMessage(["_onClose",s.reason]))}_onMessage(s){let t={data:s.data};this.ports.forEach(s=>s.postMessage(["_onMessage",t]))}_onError(s){this.ports.forEach(t=>t.postMessage(["_onError",s]))}_closeSocket(){if(this.socket)try{this.socket.onclose=null,this.socket.onerror=null,this.socket.onmessage=null,this.socket.close()}catch(s){this.ports.forEach(t=>t.postMessage(["log","error",s]))}this.socket=null}}addEventListener("connect",s=>{(manager=manager||new ConnectionManager).addPort(s.ports[0])});